//#################################################################################################
//     						LIBRARY RT_HW_74HC595
//=================================================================================================
//struct RT_HW_STRUCT_SPI_DEV{
//	uint8_t  custom=0;
//  uint8_t  dir;
//	uint8_t  cs=255; 	//--номер пина CS;
//	uint8_t  bus=0; 	//--номер пина MOSI;
//	uint8_t  order=1;
//	uint8_t  mode=0;
//	uint8_t  codeErr=0;
//	uint32_t speed=4000000UL;	//--Скорость шины;	
//};
//-------------------------------------------------------------------------------------------------
//  ecoins (ecoins@mail.ru) 
//  2023-12-30: Begin version
//#################################################################################################
//-------------------------------------------------------------------------------------------------
#ifndef RT_HW_PLC_74HC595_h
#define RT_HW_PLC_74HC595_h
#define RT_HW_PLC_74HC595_VER 10	//--Library version number;
#include "RT_HW_BASE.h"				//--Connecting the base library;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//									DATA STRUCTURE 74HC595
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class RT_HW_PLC_74HC595{
public:
uint8_t  custom=0;				//--1.Setting option;
uint8_t  status=0;				//--2.Status device: =0 no init; =1 Master.MCU->Slave.device; =2 Slave;
uint8_t  link=0;				//--3.Completed transaction flag;
uint8_t  codeErr=0;				//--4.Code error;
uint8_t  cs=255;
uint8_t  bus=0;
uint32_t speed=0;
//-------------------------------------------------------------------------------------------------	
uint8_t  pin[8];
uint8_t  run;					//--5.Command run; 
uint8_t  dir=0;					//--6.Working  dir for direct();
uint8_t  qnt=1;					//--8.Number of bytes;
uint16_t bf,var;	
uint8_t  idx=0;
uint8_t  qntPin=4;
uint8_t  permitPin=0;
//=================================================================================================
//									0.Конструктор
//=================================================================================================
RT_HW_PLC_74HC595(){
for(idx=0; idx<8; idx++){pin[idx]=0;}
}	
//=================================================================================================
//									1.Управление устройством
//=================================================================================================
void direct(uint16_t &var, uint8_t &extRun){
//-------------------------------------------------------------------------------------------------
if(extRun==2){if(bf!=var){extRun=1;} else {extRun=0;}}; 
if(extRun==1){   bf=var;  extRun=5;           run=1;}; 
//-------------------------------------------------------------------------------------------------
//									1.000.Инициализация параметров
//-------------------------------------------------------------------------------------------------
if(dir==0) {						
if(!custom)	{return;}					//--Ожидание настройки параметров;
if(speed==0){speed=RT_HW_SPI_SPEED;}	//--Нормализация скорости;
if(qntPin>8){qntPin=8;}					//--Нормализация количество пинов;
                              if(!RT_HW_Base.spiCheckBus(bus)) {				   codeErr=52; dir=210;	return;}//--Проверка номера шины;
                              if(!RT_HW_Base.checkPinPGM(RT_HW_PGM_PIN_DOT_ID,cs)){codeErr=53;		 	return;}//--Проверка допустимости номера пина cs;
for(idx=0; idx<qntPin; idx++){if( RT_HW_Base.checkPinPGM(RT_HW_PGM_PIN_DOT_ID,pin[1])){   						//--Проверка допустимости пинов;
	                     bitSet(permitPin,idx); digitalWrite(pin[idx],0); pinMode(pin[idx],OUTPUT);}}  		//  Установка разрешения и настройка пина на выход;
dir=10;} 																									//--Переход на инициализацию устройства;
//-------------------------------------------------------------------------------------------------
//									1.010.Инициализация устройства
//-------------------------------------------------------------------------------------------------
if(dir==10){
if(!run)      				 								  {return;}	//--Ожидание запуска; 
link=0;
if(status!=1)
//-------------------------------------------------------------------------------------------------																								

if(!RT_HW_Base.spiBegin(bus))				{return;} 	//--Инициализация      шины SPI как Master. Если шина занята, будет ждать освобождения шины; 
if( RT_HW_Base.spiGetStatus(bus)!=1){codeErr=54; link=1; return;} 	//--Проверка настройки шины SPI как Master;
//-------------------------------------------------------------------------------------------------
//if(id.speed==0){id.speed=RT_HW_SPI_SPEED;}													//--Нормализация скорости;
//digitalWrite(ics,1); pinMode(cs,OUTPUT);												//--Настройка пина CS на вывод																				//--Сохранение для макросов быстрого ввода-вывода;
//id.custom=id.status=id.link=1;																//--Установка выходных параметров;	




//xxxInitDevice(id);	if(!id.link) {return;}				//--Get custom device(SPI or SPN);
//if(id.status!=1){id.dir=10;       return;}
dir=20;}


/*
//-------------------------------------------------------------------------------------------------
//									1.20.Waitting run && Prepare data; 
//-------------------------------------------------------------------------------------------------
if(id.dir==20){
if(!id.run)      				 {return;} id.run=0;
//-------------------------------------------------------------------------------------------------
if((id.qnt==0)||(id.qnt>4)) {id.qnt=1;} 
id.var=id.bf32;
if(id.qnt==1){if(!id.bitOrder){id.var=RT_HW_Base.reverseV8 (uint8_t (id.var&0xFF));    }}
if(id.qnt==2){if(!id.bitOrder){id.var=RT_HW_Base.reverseV16(uint16_t(id.var&0xFFFF));  }}
if(id.qnt==3){if(!id.bitOrder){id.var=RT_HW_Base.reverseV24(uint32_t(id.var&0xFFFFFF));}}
if(id.qnt==4){if(!id.bitOrder){id.var=RT_HW_Base.reverseV32(         id.var);          }}
id.dir=30;} 
//-------------------------------------------------------------------------------------------------
//									1.30.Process device.
//-------------------------------------------------------------------------------------------------
if(id.dir==30){
xxxWrite(id);		if(!id.link) {return;} 
id.dir=20;                        return;}	

//-------------------------------------------------------------------------------------------------
*/
};	//====END direct()=============================================================================

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//									7.Device Link Functions.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/*
//=================================================================================================
//									7.1.Getting Interface Device Parameters
//=================================================================================================
void getParamDevice(RT_HW_74HC595_DEV &id){
if(id.mi=='S'){id.custom=id.dvS.custom; id.codeErr=id.dvS.codeErr; id.status=id.dvS.status; id.link=id.dvS.link; return;}
if(id.mi=='N'){id.custom=id.dvN.custom; id.codeErr=id.dvN.codeErr; id.status=id.dvN.status; id.link=id.dvN.link; return;}
               id.custom=0;             id.codeErr=0;              id.status=0;             id.link=1;           return;};
//=================================================================================================
//									7.2.Init Device.
//=================================================================================================
void xxxInitDevice(RT_HW_74HC595_DEV &id){
if(id.mi=='S'){RT_HW_Base.spiInitDevice(id.dvS); 					getParamDevice(id);	return;}
if(id.mi=='N'){RT_HW_Base.spnInitDevice(id.dvN); 					getParamDevice(id);	return;}
getParamDevice(id);}
//=================================================================================================
//									7.3.Wtite Device.
//=================================================================================================
void xxxWrite(RT_HW_74HC595_DEV &id){	
if(id.mi=='S'){RT_HW_Base.spiWrite(id.dvS,id.var,id.qnt); 			getParamDevice(id);	return;}
if(id.mi=='N'){RT_HW_Base.spnWrite(id.dvN,id.var,id.qnt); 			getParamDevice(id);	return;}
getParamDevice(id);}
//=================================================================================================
*/

};	//++++END class RT_HW_PLC_74HC595==============================================================
#endif
//=================================================================================================

//=================================================================================================


//=================================================================================================
//					Функция управления запуском на выполнение внешних функций
//							(сенсоры, расширители и пр.)
// Параметры настройки в структуре RT_HW_STRUCT_SHED_TASK:
//	(uint8_t)periodLimit - ограничение частоты вызова в циклах вхождения в функцию [режимы С,A]; default=5;
//  (uint16_t)periodTask - период вызова в мс [режимы P,T,A] default=1000;
//  Режимы запуска: 
//	 'C'-запуск по внешним условиям(например изменения входных параметров для расширителя) 
//       с ограничением частоты вызова[periodLimit];
//   'P'-периодический безусловный запуск;       
//   'T'-периодический запуск по внешним условиям(как в режиме 'C')
//	 'A'-запуск по внешним условиям(как в режиме'C') или периодически 
//       (обычно с большим периодом для повышения устойчивости проекта); 		
//   'Q'-запуск в каждом цикле по внешним условиям (для быстрых процессов и для тестирования);
//   'E'-запуск в каждом цикле. Может быть использован для управления через вход EN, 
//       в т.ч. для периодического вызова события=1 на входе EN;
//   'F'-однократное выполнение. Для повтора можно установить id.first=1;
//   'N'-запуск отключен;
//  Вход:
//  run-может устанавливаться внешней функцией. run=5 - означает, что функция запущена на выполнение;
//  Выходы
//  run-  =0 нет запуска; 
//        =1 безусловный запуск; 
//        =2 будет запуск по проверке вншней функции (например по изменению выводимого параметра);
//=================================================================================================
/*
void setTaskID  (RT_HW_STRUCT_SHED_TASK &id, char mode, uint16_t period=1000, uint16_t Period=2500){
id.custom=1; id.mode=mode; id.period=period; id.Period=Period;}	
//=================================================================================================
uint8_t directTask (RT_HW_STRUCT_SHED_TASK &id){
//-------------------------------------------------------------------------------------------------
if(id.run==5)   {id.cntLimit=0; id.timeBegin=id.TimeBegin=millis();} id.run=0;//-Сброс параметров времени внешней функцией и сброс параметра run;
if(id.mode=='N'){id.run=0;   return id.run;}					//--Pежим "Отключено";
if(!id.extEN)   {id.run=0;   id.first=1; return id.run;}		//--Блокировка по входу EN=0, выход run=0;
//--------------------------------------------------------------------------------------------------
if(id.first==1) {id.first=0; id.agoEN=id.extEN; id.cntLimit=0;	//--Инициализация и сброс параметров; 
				 if(id.period<2){id.period=2;}					//--Нормализация периода [P,T,A];                 
				 id.cntLimit=0; id.timeBegin=millis(); 			//--Нормализация периода [P,T,A];				 
			     id.run=1;   return id.run;} 					//--Выход run=1; 
//-------------------------------------------------------------------------------------------------
if(id.mode=='F'){            return id.run;} 					//--Выполняется однократно по first=1;
if(id.mode=='E'){id.run=1;   return id.run;} 					//--Выполняется в каждом цикле;
if(id.mode=='Q'){id.run=2;   return id.run;} 					//--Выполняется в каждом цикле при изменении во внешней функции;
//-------------------------------------------------------------------------------------------------
if(id.mode=='C'){if(++id.cntLimit>=id.periodLimit){id.cntLimit=0; 				id.run=2;}   return id.run;}	//--По изменению во внешней функции;
if(id.mode=='P'){if(++id.cntLimit>=id.periodLimit){id.cntLimit=0; 
                 if(getPastMs(id.timeBegin)>id.period){id.timeBegin=millis();	id.run=1;}}  return id.run;}	//--Периодический безусловный запуск;
if(id.mode=='T'){if(++id.cntLimit>=id.periodLimit){id.cntLimit=0; 
                 if(getPastMs(id.timeBegin)>id.period){id.timeBegin=millis();	id.run=2;}}  return id.run;}	//--Периодический запуск по изменению во внешней функции; 
if(id.mode=='A'){if(++id.cntLimit<id.periodLimit)                                           {return id.run;} 	//--По изменению во внешней функции или периодическии;
				 id.cntLimit=0;																					//--
				 if(id.period==0)                                              {id.run=2;    return id.run;} 	//--При period==0              по изменению во внешней функции;
				 if(getPastMs(id.timeBegin)>id.period){id.timeBegin=millis();	id.run=2;    return id.run;}	//--При period>0  периодически по изменению во внешней функции;
				 if(id.Period==0)                                              {id.run=1;    return id.run;} 	//--При Period==0 выполнение;
				 if(getPastMs(id.TimeBegin)>id.Period){id.TimeBegin=millis();	id.run=1;    return id.run;}	//--При Period>0  периодически выполнение;
				}
//-------------------------------------------------------------------------------------------------
return id.run;
};	//++++END directTask 
//=================================================================================================
*/