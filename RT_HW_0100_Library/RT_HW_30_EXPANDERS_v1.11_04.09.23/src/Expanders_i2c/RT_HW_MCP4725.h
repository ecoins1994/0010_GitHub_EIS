//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//     			 					RT_HW_MCP4725(DAC) 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  ecoins (ecoins@mail.ru) 
//  21.05.2023: Begin version
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifndef RT_HW_MCP4725_h
#define RT_HW_MCP4725_h
#define RT_HW_MCP4725_VER 	10		//--Library version number;
#include "RT_HW_BASE.h"				//--Connecting the base library;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
struct RT_HW_MCP4725_DEV{
RT_HW_STRUCT_I2C_DEV dvI;
//-------------------------------------------------------------------------------------------------
char     mi='I';				//--0.Mode interface;
uint8_t  custom=0;				//--1.Setting option;	
uint8_t  status=0;				//--2.Status device: =0 no init; =1 Master.MCU->Slave.device; =2 Slave;
uint8_t  link=0;				//--3.Completed transaction flag;
uint8_t  codeErr=0;				//--4.Code error;	
//--------------------------------------------------------------------------------------------------
uint8_t  dir=0;					//--5.Working  dir for direct();
uint8_t  step;					//--6.Working step for add function;
uint8_t  run;    				//--7.1.Flags to start reading;
uint8_t  ok;					//--7.3.Device ok;
uint8_t  fresh;					//--7.4.Fresh data;
//-------------------------------------------------------------------------------------------------
uint8_t  cnt,cntErr;			//--8.Counters;
uint8_t  err:1,action:1;		//--9.Working flags;
//-------------------------------------------------------------------------------------------------
uint8_t  workDelay=0;			//--10.Working register; 
uint8_t  pointDelay;			//--11.Return point from a function;
uint16_t sizeDelay;				//--12.Size delay;	
uint32_t startDelay;		   	//--13.Working register;
//-------------------------------------------------------------------------------------------------
uint8_t  vEEPROM=0;				//--Flags for EEPROM;
uint16_t var;					//--Written value;	    
//-------------------------------------------------------------------------------------------------
uint8_t  bf8;					//--Buffer for reading byte;
uint8_t  arr[3];              	//--Buffer for temporary data storage
};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    Â 				CLASS MCP4725 (DAC)
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class RT_HW_MCP4725{
public:
//=================================================================================================
//									2. Direct device
//=================================================================================================
void direct(RT_HW_MCP4725_DEV &id, uint16_t var, uint8_t &run){
//-------------------------------------------------------------------------------------------------
if(run==2){if(id.var!=var){run=1;} else {run=0;}}; 
if(run==1){   id.var=var;  run=5;     id.run=1;}; 
//-------------------------------------------------------------------------------------------------
//									2.0.Initting parameters. Continue after 50 ms.
//-------------------------------------------------------------------------------------------------
if(id.dir==0) {	
getParamDevice(id);
id.step=id.workDelay=0; id.ok=0;
if(id.custom==0){return;} 								id.dir=10;} 
//-------------------------------------------------------------------------------------------------
//									2.10.Waiting run
//-------------------------------------------------------------------------------------------------
if(id.dir==10){
if(!id.run){return;} id.dir=20; id.run=0; id.step=0;} 
//-------------------------------------------------------------------------------------------------
//									2.20.Init device.
//-------------------------------------------------------------------------------------------------
if(id.dir==20){
init(id);  
if(id.err)    {id.dir=200; id.sizeDelay=1000; id.pointDelay=0; return;} 
if(!id.action){id.dir=30;  id.step=0;}}
//-------------------------------------------------------------------------------------------------
//									2.30.Process device.
//-------------------------------------------------------------------------------------------------
if(id.dir==30){
process(id);  
if(id.err)    {id.dir=200; id.sizeDelay=100; id.pointDelay=0; return;} 
if(!id.action){id.dir=10;  id.step=0; return;}}	
//-------------------------------------------------------------------------------------------------
//									2.6.Fixed Delay
//-------------------------------------------------------------------------------------------------
if(id.dir==200){
if(!RT_HW_Base.timeDelay(id.startDelay,id.workDelay,id.sizeDelay)){return;} id.dir=id.pointDelay;}	
//-------------------------------------------------------------------------------------------------
};	//====END direct()=============================================================================
//=================================================================================================
//									3.Init device.
//=================================================================================================
void init(RT_HW_MCP4725_DEV &id){
//-------------------------------------------------------------------------------------------------
//									2.0.Setting parameters with continue after 50 ms	
//-------------------------------------------------------------------------------------------------
if(id.step==0){
id.cnt=id.cntErr=id.err=0; id.action=1; 
id.pointDelay=10; id.sizeDelay=50; id.step=200; return;}
//-------------------------------------------------------------------------------------------------
//									2.10.Device initialization	
//-------------------------------------------------------------------------------------------------
if(id.step==10) {	
xxxInitDevice(id);	if(!id.link)	{return;}
if(id.status!=1){id.err=1; id.step=0;return;} 
id.cnt=id.cntErr=0; 
if(id.mi=='I')  {id.step=20;} else {id.step=30;}}	
//-------------------------------------------------------------------------------------------------
//									2.20.Address search		
//-------------------------------------------------------------------------------------------------
if(id.step==20) {
xxxFindAdr(id);   	if(!id.link){return;}	
//-------------------------------------------------------------------------------------------------
if(id.codeErr){
id.cnt=0; id.cntErr++;
if(id.cntErr<=3){id.pointDelay=id.step;	id.sizeDelay=100+(250*id.cntErr); id.step=200; return;}	
if(id.cntErr==3){id.pointDelay=id.step; id.sizeDelay=2000; 				  id.step=200; return;}
				 id.codeErr=id.step;    id.err=1; 						  id.step=0;   return;}
//-------------------------------------------------------------------------------------------------
id.cnt++; id.cntErr=0;	
if(id.cnt<5){   id.pointDelay=id.step; 	id.sizeDelay=50;	id.step=200; return;}				
				id.pointDelay=30;	  	id.sizeDelay=10;	id.step=200; return;}
//-------------------------------------------------------------------------------------------------
//									3.30. Exit init.	
//-------------------------------------------------------------------------------------------------
if(id.step==30){
id.action=0; id.step=0;
return;}
//-------------------------------------------------------------------------------------------------
//									3.200.Fixed Delay
//-------------------------------------------------------------------------------------------------
if(id.step==200){if(!RT_HW_Base.timeDelay(id.startDelay,id.workDelay,id.sizeDelay)){return;} id.step=id.pointDelay;}
};	//====END init()===============================================================================

//=================================================================================================
//									4.Process device
//=================================================================================================
void process(RT_HW_MCP4725_DEV &id){
//-------------------------------------------------------------------------------------------------
//									4.0. Initting parameters.	Goto continue after 50 ms.
//-------------------------------------------------------------------------------------------------
if(id.step==0) {	
id.cnt=id.cntErr=id.err=0; id.action=1; id.step=10;}
//-------------------------------------------------------------------------------------------------
//									4.10. Start measurement	
//-------------------------------------------------------------------------------------------------
if(id.step==10){	
if(id.vEEPROM){id.arr[0]=0x60;} else {id.arr[0]=0x40;}   
id.arr[1]= (id.var / 16);  id.arr[2]=((id.var % 16) <<4); id.step=20;}	
//-------------------------------------------------------------------------------------------------
//									4.20.Sending 3rd bytes
//-------------------------------------------------------------------------------------------------
if(id.step==20){
xxxWriteArr(id,3); 		if(checkTransaction(id)){return;} 		//--pointDelay=step; if ok->to continue(step=200) or after 3fd error err=1; step=0);
id.step=90;}	   
//-------------------------------------------------------------------------------------------------
//									4.90. Exit init.	
//-------------------------------------------------------------------------------------------------
if(id.step==90){
id.fresh=id.ok=1; id.err=id.action=id.step=0; return;}
//-------------------------------------------------------------------------------------------------
//									4.200.Fixed Delay
//-------------------------------------------------------------------------------------------------
if(id.step==200){if(!RT_HW_Base.timeDelay(id.startDelay,id.workDelay,id.sizeDelay)){return;} id.step=id.pointDelay;}
};	//====END meter()===============================================================================
//=================================================================================================

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//									7.Device Link Functions.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//									7.0.Function error check.
//=================================================================================================
uint8_t checkTransaction(RT_HW_MCP4725_DEV &id){
if(!id.link) {return 1;}
id.pointDelay=id.step; id.step=200;
if(id.codeErr!=0){id.sizeDelay=40+(10*id.cntErr); id.cntErr++; 
                  if(id.cntErr>3){id.codeErr=id.pointDelay; id.err=1; id.step=0;} 
				  return 1;}
id.cntErr=0; return 0;};
//=================================================================================================
//									7.1.Getting Interface Device Parameters
//=================================================================================================
void getParamDevice(RT_HW_MCP4725_DEV &id){
if(id.mi=='I'){id.custom=id.dvI.custom; id.codeErr=id.dvI.codeErr; id.status=id.dvI.status; id.link=id.dvI.link; id.bf8=id.dvI.bf8;          return;}
			   id.custom=0;             id.codeErr=0;              id.status=0;             id.link=1;           id.bf8=0;                   return;};
//=================================================================================================
//									7.3.Init Device.
//=================================================================================================
void xxxInitDevice(RT_HW_MCP4725_DEV &id){
if(id.mi=='I'){RT_HW_Base.i2cInitDevice(id.dvI); 			getParamDevice(id); return;}		
getParamDevice(id); return;};
//=================================================================================================
//									5.2.Find address Device.
//=================================================================================================
void xxxFindAdr(RT_HW_MCP4725_DEV &id){
if(id.mi=='I'){RT_HW_Base.i2cFindAdr(id.dvI); 				getParamDevice(id); return;}	
getParamDevice(id); return;};
//=================================================================================================
//									5.3.Wtite byte to register.
//=================================================================================================
void xxxWriteArr(RT_HW_MCP4725_DEV &id, uint8_t qnt){	
if(id.mi=='I'){RT_HW_Base.i2cWriteArr(id.dvI,id.arr,qnt); 	getParamDevice(id); return;}
getParamDevice(id); return;};
//=================================================================================================
};	//++++END class RT_HW_MCP4725==================================================================
extern RT_HW_MCP4725 	RT_HW_mcp4725; 						//--Create an object RT_HW_mcp4725;
#endif
//=================================================================================================
