//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//            					ADS1115 (ADC)
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  ecoins (ecoins@mail.ru) 
//  21.05.2023: Begin version
//-------------------------------------------------------------------------------------------------
//  
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifndef RT_HW_ADS1115_h
#define RT_HW_ADS1115_h
#define RT_HW_ADS1115_VER 	10	//--Номер версии ;
#include "RT_HW_BASE.h"			//--Connecting the base library;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
struct RT_HW_ADS1115_DEV{
RT_HW_STRUCT_I2C_DEV 	dvI;	//--Параметры для работы с устройством i2c;
RT_HW_STRUCT_TIME		dTm;	//--Параметры для функции задержки;
//-------------------------------------------------------------------------------------------------
char     mi='I';				//--0.Тип интерфейса;
uint8_t  custom=0;				//--1.Флаг настройки параметров;	
uint8_t  status=0;				//--2.Статус устройства связи: =0 no init; =1 Master.MCU->Slave.device; =2 Slave;
uint8_t  link=0;				//--3.Флаг успешной связи;
uint8_t  codeErr=0,cntErr;		//--4.Код и счетчик ошибок;
//--------------------------------------------------------------------------------------------------;
uint8_t  dir,step;				//--5.Этапы основной программы и функций;
uint8_t  err,action;			//--9.Флаги функций;
//-------------------------------------------------------------------------------------------------
uint8_t  cnt;					//--8.Counters;
//-------------------------------------------------------------------------------------------------
uint16_t sizeDelay;				//--10.Рабочий регистр для размера задержки;	
//-------------------------------------------------------------------------------------------------
uint8_t  run,ok,fresh,first=0;	//--11.Флаги run,ok,fresh,first;
uint8_t  meterOk=0;		//--16.Fresh, meterOk data;
//-------------------------------------------------------------------------------------------------
uint8_t  permitA0=1, permitA1=1, permitA2=1, permitA3=1,
         permitA01=0,permitA03=0,permitA13=0,permitA23=0;
//-------------------------------------------------------------------------------------------------
//						Регистр конфигурации
//-------------------------------------------------------------------------------------------------
								//--bit[15]     Рабочее состояние/запуск однократного преобразования: 
								//  	Для записи: 0: Нет эффекта; 1: Начать одиночное преобразование.
								//  	Для чтения: 0: Выполняется преобразование; 1: Не выполняется преобразование.
uint8_t  codeMux=4;           	//--bits[14:12] Номер канала мультиплексора :
								//  	000[0]: AIN0-AIN1;		100[4]: AIN0-GND;
								//  	001[1]: AIN0-AIN3;		101[5]: AIN1-GND;								
								//  	010[2]: AIN1-AIN3;		110[6]: AIN2-GND;								
								//  	011[3]: AIN2-AIN3;		111[7]: AIN3-GND;								
uint8_t codePGA=0;				//--bits[11:19] Диапазон измерения:
								//  	000[0]: FS= ±6.144V;	100[4]: FS= ±0.512V;
								//		001[1]: FS= ±4.096V;	101[5]: FS= ±0.256V;
								//		010[2]: FS= ±2.048V;	110[6]: FS = ±0.256V;
								//		011[3]: FS =±1.024V;	111[7]: FS = ±0.256V;
uint8_t codeMode=1;				//--bit[8]      Выбор режима преобразования:
								// 		     0: Непрерывное преобразование;
								//		     1: Однократное преобразование с выключением питания;
uint8_t codeSPS=4;				//--bits[7:5]   Скорость измерения: 
								//		000[0]:  8SPS;		 	100[4]: 128SPS;
								//		001[1]: 16SPS;		 	101[5]: 250SPS;
								//		010[2]: 32SPS;		 	110[6]: 475SPS;
								//		011[3]: 64SPS;		 	111[7]: 860SPS;								
uint8_t codeComparator=3;		//--bits[1:0]   Постановка компаратора в очередь и отключение :
								//		00 [0]: Подтвердить после одного преобразования;
								//      01 [1]: Подтвердить после двух преобразований;
								//		10 [2]: Подтвердить после четырех преобразований;
								//		11 [3]: Отключить компаратор.
uint8_t  codeCnt=0;				//--Счетчик проверки завершения преобразования;								
uint8_t  configH, configL;
uint32_t timeMeter=780;			//--12.Регистр для времени преобразования ADS1115 (1000000/codeSPS);
//-------------------------------------------------------------------------------------------------
int16_t  vMeter;				//--21.Meter value;
int16_t  vA0,vA1,vA2,vA3,vA01,vA03,vA13,vA23;		    
float    vTemp;
//-------------------------------------------------------------------------------------------------
uint8_t  bf8;					//--Buffer for reading byte;
uint8_t  arr[3];              	//--Buffer for temporary data storage
uint8_t  idx;					//--Indexs;
};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=================================================================================================
//                            		CLASS ADS1115
//=================================================================================================
class RT_HW_ADS1115{
public:
//=================================================================================================
//									1.УПРАВЛЕНИЕ УСТРОЙСТВОМ
//=================================================================================================
void direct(RT_HW_ADS1115_DEV &id, uint8_t &run){
//-------------------------------------------------------------------------------------------------
id.meterOk=id.fresh=0;														//--Сброс флагов завершенных измерений;
if(run>0){id.run=1; run=5;};												//--Фиксация внешней команды запуска цикла измерений;
//-------------------------------------------------------------------------------------------------
//									1.0.Установка параметров с продолжением через 50ms
//-------------------------------------------------------------------------------------------------
if(id.dir==0){	
getParamDevice(id);															//--Получение параметров по интерфейсу связи;
id.step=id.ok=id.fresh=0; 	id.first=1;										//--Инициализация флагов;
id.vA0=id.vA1=id.vA2=id.vA3=id.vA01=id.vA03=id.vA13=id.vA23=0;				//--Сброс начальных значений 
if(id.custom==0){return;}													//--Выход, если устройство не настроено; 								
               id.dTm.pointTime=10; id.sizeDelay=50;  id.dir=200; return;} 
//-------------------------------------------------------------------------------------------------
//									1.10.Инициализация устройства
//-------------------------------------------------------------------------------------------------
if(id.dir==10){if(!id.run){return;}	 
init(id);  																	//--Вызов инициализации;
if(id.err)    {id.dTm.pointTime=0; id.sizeDelay=1000; id.dir=200; return;}	//--Выход по ошибке инициализации с задержкой 1000ms; 
if(id.action) {return;}	          			          id.dir=20;}			//--Ожидание   завершения инициализации;
//-------------------------------------------------------------------------------------------------
//									1.20.Ожидание команды запуска цикла измерения
//-------------------------------------------------------------------------------------------------
if(id.dir==20){if(!id.run){return;}	id.run=0; 		  id.dir=30;}			//--Ожидание команды запуска цикла измерения;                			
//-------------------------------------------------------------------------------------------------
//									1.30.Обработка сигнала A0-GND
//-------------------------------------------------------------------------------------------------
if(id.dir==30){if(!id.permitA0) {id.dir=40;}     else {id.dir=31; return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==31){process(id,4);   											//--bits[14:12] 100 A0-GND. Вызов функции измерения;
if(id.err)    {id.dTm.pointTime=0; id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms; 
if(id.action) {return;}	           id.vA0=id.vMeter;  id.dir=40;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.40.Обработка сигнала A1-GND
//-------------------------------------------------------------------------------------------------
if(id.dir==40){if(!id.permitA1) {id.dir=50;}    else {id.dir=41;  return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==41){process(id,5);   											//--bits[14:12] 101 A1-GND. Вызов функции измерения;  
if(id.err)    {id.dTm.pointTime=0; id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms; 
if(id.action) {return;}            id.vA1=id.vMeter;  id.dir=50;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.50.Обработка сигнала A2-GND
//-------------------------------------------------------------------------------------------------
if(id.dir==50){if(!id.permitA2) {id.dir=60;}    else {id.dir=51;  return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==51){process(id,6);   											//--bits[14:12] 110 A2-GND. Вызов функции измерения;   
if(id.err)   {id.dTm.pointTime=0;  id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms;
if(id.action){return;}			   id.vA2=id.vMeter;  id.dir=60;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.60.Обработка сигнала A3-GND
//-------------------------------------------------------------------------------------------------
if(id.dir==60){if(!id.permitA3) {id.dir=70;}    else {id.dir=61;  return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==61){process(id,7);   											//--bits[14:12] 111 A3-GND. Вызов функции измерения;  
if(id.err)   {id.dTm.pointTime=0;  id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms;
if(id.action){return;}			   id.vA3=id.vMeter;  id.dir=70;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.70.Обработка сигнала A0-A1
//-------------------------------------------------------------------------------------------------
if(id.dir==70){if(!id.permitA01) {id.dir=80;}   else {id.dir=71;  return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==71){process(id,0);   											//--bits[14:12] 000 A0-A1. Вызов функции измерения;
if(id.err)   {id.dTm.pointTime=0;  id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms;
if(id.action){return;}			   id.vA01=id.vMeter; id.dir=80;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.80.Обработка сигнала A0-A3
//-------------------------------------------------------------------------------------------------
if(id.dir==80){if(!id.permitA03) {id.dir=90;}   else {id.dir=81;  return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==81){process(id,1);    											//--bits[14:12] 001 A0-A3. Вызов функции измерения;
if(id.err)   {id.dTm.pointTime=0;  id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms;
if(id.action){return;}			   id.vA03=id.vMeter; id.dir=90;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.90.Обработка сигнала A1-A3
//-------------------------------------------------------------------------------------------------
if(id.dir==90){if(!id.permitA13) {id.dir=100;}  else {id.dir=91;  return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==91){process(id,2);  												//--bits[14:12] 010 A1-A3; Вызов функции измерения;
if(id.err)   {id.dTm.pointTime=0;  id.sizeDelay=250;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 250ms;
if(id.action){return;}			   id.vA13=id.vMeter; id.dir=100;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.100.Обработка сигнала A2-A3
//-------------------------------------------------------------------------------------------------
if(id.dir==100){if(!id.permitA23){id.dir=150;}  else {id.dir=101; return;}}	//--Проверка разрешения обработки входа;
//-------------------------------------------------------------------------------------------------
if(id.dir==101){process(id,3);  											//--bits[14:12] 011 A2-A3. Вызов функции измерения;
if(id.err)   {id.dTm.pointTime=0;  id.sizeDelay=200;  id.dir=200; return;}	//--Выход по ошибке измерения с задержкой 200ms;
if(id.action){return;}			   id.vA23=id.vMeter; id.dir=150;}			//--Ожидание  завершения измерения;
//-------------------------------------------------------------------------------------------------
//									1.90.End device management 
//-------------------------------------------------------------------------------------------------
if(id.dir==150){id.ok=1; id.fresh=1;
/*
RT_HW_Base.consoleTest(String(F("ADS fresh")),id.fresh,';');
RT_HW_Base.consoleTest(String(F(" timeMeter")),id.timeMeter,';');
RT_HW_Base.consoleTest(String(F(" timeSPS")),id.codeSPS,';');
RT_HW_Base.consoleTest(String(F(" A0 ")),id.vA0, ';','I');
RT_HW_Base.consoleTest(String(F(" A1 ")),id.vA1, ';','I');
RT_HW_Base.consoleTest(String(F(" A2 ")),id.vA2, ';','I');
RT_HW_Base.consoleTest(String(F(" A3 ")),id.vA3, ';','I');
RT_HW_Base.consoleTest(String(F(" A01")),id.vA01,';','I');
RT_HW_Base.consoleTest(String(F(" A03")),id.vA03,';','I');
RT_HW_Base.consoleTest(String(F(" A13")),id.vA13,';','I');
RT_HW_Base.consoleTest(String(F(" A23")),id.vA23,';','I');
RT_HW_Base.consoleCR();	
*/			
				id.dTm.pointTime=20;	id.sizeDelay=10;  	id.dir=200;} //--Ограничение периода вызова; 
//-------------------------------------------------------------------------------------------------
//									1.200.Dynamic Delay
//-------------------------------------------------------------------------------------------------
if(id.dir==200){if(!RT_HW_Base.checkDelay(id.dTm,id.sizeDelay)){id.dir=id.dTm.pointTime;} return;}
//-------------------------------------------------------------------------------------------------
};	//====END direct()=============================================================================

//=================================================================================================
//									2.ИНИЦИАЛИЗАЦИЯ УСТРОЙСТВА
//=================================================================================================
void init(RT_HW_ADS1115_DEV &id){
//-------------------------------------------------------------------------------------------------
//									2.0.Установка параметров с продолжением через 50ms
//-------------------------------------------------------------------------------------------------
if(id.step==0){
id.cnt=id.cntErr=id.err=0; id.action=1; 
id.dTm.pointTime=10; id.sizeDelay=50; id.step=200; return;}  
//-------------------------------------------------------------------------------------------------
//									2.10.Инициализация устройства
//-------------------------------------------------------------------------------------------------
if(id.step==10) {	
xxxInitDevice(id);															    if(!id.link) {return;}
if(id.status!=1)                                                     {id.err=1;	id.step=0;	  return;} 
id.cnt=id.cntErr=0;                                                             id.step=20;   return;}	
//-------------------------------------------------------------------------------------------------
//									2.20.Поиск устройства				
//-------------------------------------------------------------------------------------------------
if(id.step==20) {
xxxFindAdr(id);   	if(!id.link){return;}	
//-------------------------------------------------------------------------------------------------
if(id.codeErr){id.cnt=0; id.cntErr++;	//--При ошибке поиска устройства 3-х кратный повтор с увеличивающейся задержкой; 		
if(id.cntErr<=3){id.dTm.pointTime=id.step;	id.sizeDelay=100+(250*id.cntErr);	id.step=200; return;}	
if(id.cntErr==3){id.dTm.pointTime=id.step;	id.sizeDelay=2000; 					id.step=200; return;}
				 id.codeErr=10;             id.err=1; 							id.step=0;   return;}
//-------------------------------------------------------------------------------------------------
id.cnt++; id.cntErr=0;					//--При обнаружении устройства 5-ти кратный повтор через 50ms(для надежности обнаружения);			
if(id.cnt<5)   {id.dTm.pointTime=id.step;	id.sizeDelay=50;					id.step=200; return;}				
				id.dTm.pointTime=50;	  	id.sizeDelay=10;					id.step=200; return;}
//-------------------------------------------------------------------------------------------------
//									2.50.Общий сброс
//-------------------------------------------------------------------------------------------------
if(id.step==50){ 
id.arr[0]=6;
xxxWriteArr(id,1); if(!id.link) {return;}	//--Отправка команды сброса;
id.step=90;};
//-------------------------------------------------------------------------------------------------
//									2.90.Завершение инициализации
//-------------------------------------------------------------------------------------------------
if(id.step==90){id.err=id.action=id.step=0; return;}
//-------------------------------------------------------------------------------------------------
//									2.200.Задержка с возвратом в заданную точку функции
//-------------------------------------------------------------------------------------------------
if(id.step==200){if(!RT_HW_Base.checkDelay(id.dTm,id.sizeDelay)) {id.step=id.dTm.pointTime;} return;}
};	//====END init()===============================================================================

//=================================================================================================
//									3.Device process
//=================================================================================================
void process(RT_HW_ADS1115_DEV &id, uint8_t mux){
//-------------------------------------------------------------------------------------------------
//									3.0.Установка параметров
//-------------------------------------------------------------------------------------------------
if(id.step==0){
if(mux>7){id.err=1;id.action=0; id.codeErr=70; return;}
id.codeMux=mux;
id.codeCnt=id.cnt=id.cntErr=id.err=0; id.action=1; 
id.step=5;} 
//-------------------------------------------------------------------------------------------------
//									3.5.Общий сброс
//-------------------------------------------------------------------------------------------------
if(id.step==5){ 
id.arr[0]=6;
xxxWriteArr(id,1); if(!id.link) {return;}	//--Отправка команды сброса;
id.step=10;};
//-------------------------------------------------------------------------------------------------
//									3.10.Запуск преобразования 
//-------------------------------------------------------------------------------------------------
if(id.step==10){ 
id.timeMeter=7800;
if(id.codeSPS==0){id.timeMeter=125000;} //--Задержка в mcs=1000000/16;
if(id.codeSPS==1){id.timeMeter=62500;} 	//--Задержка в mcs=1000000/16;
if(id.codeSPS==2){id.timeMeter=31250;} 	//--Задержка в mcs=1000000/32;
if(id.codeSPS==3){id.timeMeter=15600;} 	//--Задержка в mcs=1000000/64;
if(id.codeSPS==4){id.timeMeter=7800;}	//--Задержка в mcs=1000000/128;
if(id.codeSPS==5){id.timeMeter=4000;} 	//--Задержка в mcs=1000000/250;
if(id.codeSPS==6){id.timeMeter=2100;} 	//--Задержка в mcs=1000000/475;
if(id.codeSPS==7){id.timeMeter=1100;} 	//--Задержка в mcs=1000000/860;
//-------------------------------------------------------------------------------------------------
id.configH=0x80 | ((id.codeMux&0x7)<<4) | ((id.codePGA&0x7)<<1) | id.codeMode;	
id.configL=0x03 | ((id.codeSPS&0x7)<<5);
//id.configL=0x03 | (((uint8_t)2)<<5);
//-------------------------------------------------------------------------------------------------
id.arr[0]=6;
xxxWriteArr(id,3);if(!id.link) {return;}	//--Отправка команды запуска преобразования;
//--------------------------------------------------------------------------------------------------
id.arr[0]=1;							//--Адрес регистра конфигурации;
id.arr[1]=id.configH;					//--Старший байт регистра конфигурации;
id.arr[2]=id.configL;					//--Младший байт регистра конфигурации;

id.cntErr=0; id.step=12;}
//-------------------------------------------------------------------------------------------------
if(id.step==12){
xxxWriteArr(id,3);													 			if(!id.link) {return;}	//--Отправка команды запуска преобразования;
if(id.codeErr)  {if(++id.cntErr<=3){id.dTm.pointTime=id.step; 	 				id.step=200;}  	  		//--При ошибке повтор после динамической задержки
	             else              {id.err=1; id.codeErr=20;  	 				id.step=0;}   return;}	//  			   или выход из функции по ошибке;
id.cntErr=id.codeCnt=0; id.step=20;}													  				//--Переход на задержку по времени;
//-------------------------------------------------------------------------------------------------
//									3.20.Задержка для преобразования в устройстве
//-------------------------------------------------------------------------------------------------
if(id.step==20){if(!RT_HW_Base.checkDelay(id.dTm,id.timeMeter,0)) 			   {id.step=30;}  return;}	//--Задержка для преобразования в устройстве в mcs;	 		
//-------------------------------------------------------------------------------------------------
//									3.30.Проверка завершения преобразования
//-------------------------------------------------------------------------------------------------
if(id.step==30){
xxxREADArr(id,1,2);													 			if(!id.link) {return;}	//--Чтение регистра конфигурации;
if(id.codeErr)  {if(++id.cntErr<=3){id.dTm.pointTime=id.step; 					id.step=200;}  	 		//--При ошибке повтор после динамической задержки
				 else              {id.err=1; id.codeErr=21;      				id.step=0;}   return;}	//  			   или выход из функции по ошибке;
//-------------------------------------------------------------------------------------------------
if((id.arr[0]>>7)) 															   {id.step=40;} 		 	//--Успешное завершение по биту завершения,
else               {if(++id.codeCnt<=5)                             		   {id.step=35;} 		 	//     или повторное чтение через задержку,  
	                else              {id.err=1; id.codeErr=22;      		    id.step=0;}   return;}	//           или выход из функции по ошибке;
}
//-------------------------------------------------------------------------------------------------
//									3.30.Задержка для преобразования в устройстве
//-------------------------------------------------------------------------------------------------
if(id.step==35){if(!RT_HW_Base.checkDelay(id.dTm,2))                		   {id.step=30;}  return;} //--Задержка для преобразования в устройстве;	
//-------------------------------------------------------------------------------------------------
//									3.40.Чтение результата
//-------------------------------------------------------------------------------------------------
if(id.step==40){
xxxREADArr(id,0,2);													 			if(!id.link) {return;}	//--Чтение результата преобразования;
if(id.codeErr)     {if(++id.cntErr<=3){id.dTm.pointTime=id.step; 	 			id.step=200;}  	  		//--При ошибке повтор после динамической задержки
	                else              {id.err=1; id.codeErr=22;  	 			id.step=0;}   return;}	//  			   или выход из функции по ошибке; 
																				id.step=50;}	
//-------------------------------------------------------------------------------------------------
//									3.50.Обработка результата
//-------------------------------------------------------------------------------------------------
if(id.step==50){
id.vMeter=(id.arr[0] << 8) | id.arr[1]; 
id.err=id.action=id.step=0; bitSet(id.meterOk,id.codeMux); 
return;}
//-------------------------------------------------------------------------------------------------
//									3.200.Динамическая задержка
//-------------------------------------------------------------------------------------------------
if(id.step==200){id.sizeDelay=40+(10*id.cntErr);        						id.step=210;}
if(id.step==210){if(!RT_HW_Base.checkDelay(id.dTm,50)) 			  {id.step=id.dTm.pointTime;} return;}
};	//====END process()============================================================================

//=================================================================================================
//									6.УТИЛИТЫ
//=================================================================================================
float getVar_V(RT_HW_ADS1115_DEV &id, int16_t adc){
if(id.codePGA==0){return adc*6.144f/32768;}
if(id.codePGA==1){return adc*4.096f/32768;}
if(id.codePGA==2){return adc*2.048f/32768;}
if(id.codePGA==3){return adc*1.024f/32768;}
if(id.codePGA==4){return adc*0.512f/32768;}
if(id.codePGA==5){return adc*0.256f/32768;}
return 0.0f;}
//=================================================================================================
float getVar_mV(RT_HW_ADS1115_DEV &id, int16_t adc){
if(id.codePGA==0){return adc*6144.0f/32768;}
if(id.codePGA==1){return adc*4096.0f/32768;}
if(id.codePGA==2){return adc*2048.0f/32768;}
if(id.codePGA==3){return adc*1024.0f/32768;}
if(id.codePGA==4){return adc* 512.0f/32768;}
if(id.codePGA==5){return adc* 256.0f/32768;}
return 0.0f;}
//=================================================================================================
int16_t getVar_sys(RT_HW_ADS1115_DEV &id, int16_t adc){
if(id.codePGA==0){return adc*6144/32768;}
if(id.codePGA==1){return adc*4096/32768;}
if(id.codePGA==2){return adc*2048/32768;}
if(id.codePGA==3){return adc*1024/32768;}
if(id.codePGA==4){return adc* 512/32768;}
if(id.codePGA==5){return adc* 256/32768;}
return 0;}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//									7.ФУНКЦИИ ОБМЕНА С УСТРОЙСТВОМ
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//									7.1.Getting Interface Device Parameters
//=================================================================================================
void getParamDevice(RT_HW_ADS1115_DEV &id){
id.custom=id.dvI.custom; id.codeErr=id.dvI.codeErr; id.status=id.dvI.status; id.link=id.dvI.link; id.bf8=id.dvI.bf8; return;}
//=================================================================================================
//									7.3.Init Device.
//=================================================================================================
void xxxInitDevice(RT_HW_ADS1115_DEV &id){
RT_HW_Base.i2cInitDevice(id.dvI); 				getParamDevice(id); return;}		
//=================================================================================================
//									7.2.Find address Device.
//=================================================================================================
void xxxFindAdr(RT_HW_ADS1115_DEV &id){
RT_HW_Base.i2cFindAdr(id.dvI); 					getParamDevice(id); return;}	
//=================================================================================================
//									7.4.Wtite byte to register.
//=================================================================================================
void xxxWriteArr(RT_HW_ADS1115_DEV &id, uint8_t qnt){	
RT_HW_Base.i2cWriteArr(id.dvI,id.arr,qnt); 	 	getParamDevice(id); return;}
//=================================================================================================
//									7.6.Read bytes from register
//=================================================================================================
void xxxREADArr(RT_HW_ADS1115_DEV &id, uint8_t reg, uint8_t qnt){	
//-------------------------------------------------------------------------------------------------
RT_HW_Base.i2cREADArr(id.dvI,reg,id.arr,qnt);	getParamDevice(id); return;}
//=================================================================================================
//									7.11.Get bytes.
//=================================================================================================
void xxxReadArr(RT_HW_ADS1115_DEV &id, uint8_t qnt){	
RT_HW_Base.i2cReadArr(id.dvI,id.arr,qnt); 		getParamDevice(id); return;};
//=================================================================================================
};	//++++END class RT_HW_RT_HW_ADS1115====================================================================
extern RT_HW_ADS1115 	RT_HW_ads1115; 						//--Create an object RT_HW_ADS1115;
#endif
//=================================================================================================