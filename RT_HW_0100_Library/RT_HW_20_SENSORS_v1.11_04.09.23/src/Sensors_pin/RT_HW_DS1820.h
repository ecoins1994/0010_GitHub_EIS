//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//            			СЕНСОР DS1820
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/*
Описание для FLProg(параметры времени запуска определяются самим блоком FLProg).
---------------------------------------------------------------------------------------------------
DS1820 - датчик температуры.
Поддерживается "горячее" подключение, ошибочные измерения отфильтровываются.
Основные параметры:
  1. Пользовательский номер пина[plug=OFF].
  2. Режим измерения - периодический, по переднему фронту eN 
                       или в каждом цикле[plug=OFF,default=периодический].
  3. Пользовательский период измерения[plug=OFF,default=2200ms].
  4. Период измерения [default=1000ms].
Входы:
  1. Номер пина [plug=ON].
  2. EN - разрешение работы блока [plug=OFF].
  3. eN - запуск измерения по переднему фронту [для режима измерения по переднему фронту].
Выходы:
  1. ok - флаг готовности устройства [plug=ON].
  2. T - температура (в градусах C).
  3. fresh - флаг готовности измерений(событие) [plug=OFF].
  4. cntOk - счетчик успешных измерений [plug=OFF].
  5. cntErr - счетчик успешных измерений [plug=OFF].
---------------------------------------------------------------------------------------------------
Рекомендации для FLProg: 
1.Использовать "Диспетчер задач". 
2.Блок устанавливать на плате, управляемой "Диспетчером задач" как "Свободная задача".
3.Если "Диспетчер задач" не используется, обеспечить регулярный вызов блока не реже периода измерения.
---------------------------------------------------------------------------------------------------
Блок  ds1820  измеряет температуру одного сенсора типа ds1820, подключенного через отдельный пин.
Примененный алгоритм работы позволяет минимизировать влияния на работу ds1820 аппаратных прерываний 
(например WiFi, быстрые счетчики и ультразвуковые сонары и т.п), помех, плохих контактов и т.п. 
Это достигается дроблением "длинных" инструкций от контроллера к сенсору на укороченные инструкции.
Укороченные инструкции отправляются  периодически с изменяемым периодом до получения достоверных ответов.

Алгоритм работы блока
1.По флагу run  начинается цикл измерения.
2.По при первом запуске или при смене номера пина проверяется допустимость номера выбранного пина.
3.При первом запуске или смене пина осуществляется поиск устройства на шине.
  При ошибочных транзакциях выполняются многократные до ds.maxRptAddr(default=5) повторы c изменяющимся периодом. 
  Если устройство не обнаружено, то повторный поиск возобновляется через 2сек.
  Если устройство обнаружено, то на следующих этапах транзакции поиска устройства пропускаются.
  Если достоверные результаты получить не удается, поиск устройства повторяется. 
  Из адреса выделяются  дополнительные параметры - тип сенсора  DS182S20 (устаревшая модель), 
    DS18B20(наиболее распостраненная модель),DS1822, разрядность измерения (9,10,11 или 12 бит).
4.Выполняется последовательность команд для измерения температуры. 
  При ошибочных транзакциях выполняются многократные до ds.maxRptData(default=10) повторы c изменяющимся периодом. 
  Если достоверные результаты получить не удается, фиксируется ошибка, сбрасывается флаг ok, 
  сбрасываеся значение температуры ds.vTemp до значения, опредленного при инициализации (default=0.47), 
  увеличивается счетчик ошибок ds.cntErr, устанавливается флаг ds.frеsh.
  Если температура измерена, устанавливаетс флаг ds.ok, сохраняется измеренное значение температуры ds.vTemp, увеличивается 
  счетчик успешных измерений ds.cntOk, устанавливается флаг ds.frеsh.
  Флаг ds.fresh может сбрасываться внешней функцией при передачи актуальных значений ds.ok, ds.vTemp. 
---------------------------------------------------------------------------------------------------  
ecoins@mail.ru 03.11.2022.      
---------------------------------------------------------------------------------------------------
*/
//-------------------------------------------------------------------------------------------------
//  ecoins (ecoins@mail.ru)  
//  22.10.2022: Begin version
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//-------------------------------------------------------------------------------------------------
#ifndef RT_HW_DS1820_h
#define RT_HW_DS1820_h
#define RT_HW_DS1820_VER 					10		//--Номер версии библиотеки;
#include "RT_HW_BASE.h"								//--Подключение базовой библиотеки;
//-------------------------------------------------------------------------------------------------
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//							Структура для DS1820
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
struct RT_HW_STRUCT_DS1820_ID{
uint8_t  custom=0;
uint8_t  extPin=255;    //--Новое значение пина (можно считать перед началом измерения);
uint8_t  pin=255;       //--Номер пина;
//-------------------------------------------------------------------------------------------------
uint8_t  typeMdf=0;     //--Модификация сенсора: если addr[0]=0x10(DS18s20) =1(старая), иначе =0(новая).
uint8_t  power=1;       //--Питание сенсора: =0-паразитное питание; =1-активное питание;
                        //--Модель сенсора addr[0]: Не определена=0, DS18S20=0x10, DS18B20=0x22, DS1822=0x28;
uint8_t  depth=12;      //--Разрядность сенсора (9,10,11,12) (может меняться в EEPROM) 
                        //  Биты 6,5 data[4]: 00=9bit(93.75ms),01=10bit(187.5ms),10=11bit(375ms),12=12bit(750ms)[default];
//-------------------------------------------------------------------------------------------------
int16_t  raw;           //--Результаты измерения в кодах из сенсора;
float    vTemp=0.47;    //--Нормализованная температура(float);
//-------------------------------------------------------------------------------------------------
uint8_t  addr[8];       //--Буфер для адреса из сенсора ds1820;
uint8_t  crcAddr;       //--Контрольная сумма CRC8 адреса;
uint8_t  data[9];       //--Буфер для данных из сенсора ds1820;
uint8_t  crcData;       //--Контрольная сумма CRC8 данных;
//-------------------------------------------------------------------------------------------------
uint8_t  run=1;         //--Флаг для внешнего запуска измерений;
uint8_t  finish=0;      //--Флаг завершения измерения;
uint8_t  ok=0;          //--Флаг устойчивой работы(с учетом отброса ошибочных измерений);
uint8_t  fresh=1;       //--Флаги готовности достоверных измерений;
uint16_t cntOk=0;       //--Счетчик успешных измерений;
uint16_t cntErr=0;      //--Cчетчик ошибок;
uint8_t  codeErr;       //--Код последней ошибки;
uint8_t  codeErrAddr;   //--Код последней ошибки чтения адреса;
uint8_t  codeErrData;   //--Код последней ошибки измерения данных;
//-------------------------------------------------------------------------------------------------
uint8_t  okAddr:1,okErrAddr:1,okData:1,okErrData:1,okErr:1,//--Флаги внутренних функций: готовности адреса addr[],данных data[],codeErr;
         idAddr:1;      //--Флаг адрес установлен; 
uint8_t  action:1,err:1;//--Флаги активности, выход add function;
uint8_t  cntRptAddr,cntRptData; //--Счетчик повторений для успешных измерений адреса,данных;
uint8_t  maxRptAddr=5;  //--Максимальное кол-во повторов для успешных запросов адреса;
uint8_t  maxRptData=10; //--Максимальное кол-во повторов для успешных запросов данных;
//-------------------------------------------------------------------------------------------------
uint8_t  dir=0;         //--Управление этапами управления main function;
uint8_t  dirReturn;     //--Номер шага для возврата       main function;
uint16_t dirSetBack;    //--Задержка перед возвратом      main function;
//-------------------------------------------------------------------------------------------------
uint8_t  step=0;        //--Управление этапами управления add  function;
uint8_t  stepReturn;    //--Номер шага для возврата       add  function;
uint16_t stepSetBack;   //--Задержка перед возвратом      add  function;
//-------------------------------------------------------------------------------------------------
uint32_t timeDelay;      //--Рабочий параметр              add  function (timeDelay в timeDelayMs());
uint8_t  stepDelay=0;   //--Рабочий параметр              add  function (stepDelay в timeDelayMs());
//-------------------------------------------------------------------------------------------------
uint8_t  ix;            //--Рабочий индекс для использования в циклах;
uint8_t  bf8;           //--Рабочий буфер для использования в функциях; 
};


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                     КЛАСС УПРАВЛЕНИЯ DS1820
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class RT_HW_DS1820{
public:
//=================================================================================================
void setParam(RT_HW_STRUCT_DS1820_ID &id, uint8_t vPin=255){ 	//++++НАСТРОЙКА параметров=====================================
if(id.custom==0){	//++++Однократная настройка параметров---------------------------------------------
	id.extPin=vPin; id.dir=0; id.custom=1;}	//--Настройка номера пина;
};	//+++++END setParam()==========================================================================
//=================================================================================================
//                      1.Работа c ds1820 (основная функция)
//  1.Опрашивает одиночный сенсора (одно устройство на шине).
//  2.После определения адреса устройства, для сокращения цикла измерения опрашивается только данные.
//    Если при опросе данных выявляются ошибки, возобновляется определение адреса устройства.
//  3.При каждой ошибке сохраняется последнее значение, сбрасывается флаг ok, взводится флаг fresh.
//=================================================================================================
void direct(RT_HW_ONEWIRE &z, RT_HW_STRUCT_DS1820_ID &id){
//===========Инициализация параметров и шины 1-Wire==============================================
if(id.dir==0) { 
 id.step=0; id.stepDelay=0; id.idAddr=0; id.codeErr=0; id.okAddr=0; id.okData=0; id.bf8=0;        //--Инициализация параметров;            
 if(id.extPin==255){return;}																	  //--Проверка установку номера пина;						
 if(!RT_HW_Base.checkPinPGM( RT_HW_PGM_PIN_DIN_ID, id.extPin)) {id.codeErr=11; id.bf8=1; return;} //--Проверка пина на дискретный ввод;
 if(!RT_HW_Base.checkPinPGM( RT_HW_PGM_PIN_DOT_ID, id.extPin)) {id.codeErr=12; id.bf8=1; return;} //--Проверка пина на дискретный вывод;  
 if(id.bf8==1){id.dirSetBack=5000; id.dirReturn=0; id.dir=80; return;} //++ERR: возврат на полный повтор в dir=0 с  задержкой 5сек;                                                                                   //--Сохранение пина;
 id.pin=id.extPin;                                                     //--Присвоение номера пина;
 z.begin(id.pin);                                                      //--Инициализация шины 1-Wire;
 id.dir=10; return;}                                                   //--Продолжение в следующий этап без задержки; 
//============Ожидание внешней команды запуска====================================================
if(id.dir==10){
 if(!id.run){return;} id.run=0;  id.finish=0;   //--Ожидание внешней команды запуска;
 if(id.pin!=id.extPin){id.dir=0; return;} 		//--Переход начало при смене номера пина;
 id.codeErr=0; id.okAddr=0; id.okData=0;        //--Сброс run, инициализация параметров; 
 id.step=0;    id.dir=11;        return;} 		//--Продолжение в следующий этап без задержки;      
//===========Поиск адреса=========================================================================
if(id.dir==11){
 if(id.idAddr){id.dir=12; return;}                                      //--Если адрес уже установлен, то переход на следующий этап;
 search_addr(z,id);                                                     //--Вызов функции Поиска адреса;
 if(id.action) {return;}                                                //--Ожидание завершения функции;
 if(id.err)    {id.codeErr=id.codeErrAddr; id.cntErr++;                 //++ERR: присвоение кода ошибки и увеличение счетчика Err;
                id.ok=0;  id.okErr=1;  id.fresh=1;                      //++ERR: сброс и установка флагов;
                id.idAddr=0; id.cntRptAddr=0; id.cntRptData=0;          //++ERR: очистка рабочих параметров;  
				id.dirSetBack=2000; id.dirReturn=100;id.dir=80; return;}//++ERR: возврат на ожидание run с задержкой; 
                id.idAddr=1;                                            //--Установка флага получения адреса,   
 id.step=0;     id.dirSetBack=10;   id.dirReturn=12; id.dir=80; return;}//--Продолжение в следующий этап  с задержкой;
//===========Измерение температуры=================================================================
if(id.dir==12){  
 meter(z,id);                                                      //--Вызов функции измерения температуры;
 if(id.action) {return;}                                                 //--Ожидание завершения функции;
 if(id.err)    {id.codeErr=id.codeErrAddr; id.cntErr++;                  //++ERR: фиксация ошибки;
                id.ok=0; id.okErr=1;id.idAddr=0;id.cntRptAddr=0; id.cntRptData=0; id.fresh=1; //++ERR: сброс параметров, и установка флагов;  
				id.dirSetBack=2000; id.dirReturn=100; id.dir=80; return;}//++ERR: возврат на ожидание run с задержкой;  
 id.vTemp=((float)id.raw/16.0); id.cntOk++;                              //--Расчет температуры, увеличение счетчика;
                id.ok=1; id.okErr=0;                  id.fresh=1;        //--Установка и сброс флагов;
 id.step=0;     id.dirSetBack=500;  id.dirReturn=100; id.dir=80; return;}//--Возврат на ожидание run с задержкой; ;
//=================Задержка=dirSetback с возвратом на step=stepReturn==============================
if(id.dir==80){if(RT_HW_Base.timeDelayMs(id.timeDelay,id.stepDelay,id.dirSetBack)){id.dir=id.dirReturn;} return;}
//=================Заверщения цикла измерения==============================
if(id.dir==100){id.finish=1; id.dir=10; return;}
//-------------------------------------------------------------------------------------------------            
} //--END ds1820();

//=================================================================================================
//                      2.Функция поиска адреса
//  Возвращает: action,err,codeErr,okAddr,addr[],cntRpt
//  1.Если ok: action=0, err=0; полученные адрес addr[], контрольную сумму crc_addr, 
//    тип дисплея(новый/старый) typeMdf(0/1), ok_addr=1;
//  2.Иначе  : action=0, err=1; код ошибки codeErr;
//  3.В процесе работы: action=1, кол-во повторов cntRpt;
//    При  ошибочных транзакциях выполняются поторы до maxRptAddr(настраиваемый параметр) 
//                                                    с увеличивающимся временем между повторами;  
//=================================================================================================
void search_addr(RT_HW_ONEWIRE &z, RT_HW_STRUCT_DS1820_ID &id){
if(id.step==0) {    //=========Подготовка параметров===============================================
  id.err=0; id.action=1; id.codeErrAddr=0; id.cntRptAddr=0; id.typeMdf=0; id.step++; return;} //--Подготовка параметров и рродолжение в следующий этап без задержки;
if(id.step==1) {    //=========Сброс шины 1-Wire=================================================== 
 id.bf8=z.reset();                                                                            //--Сброс шины (=1 получен ответ от устройств);             
  if(id.bf8==0){id.codeErrAddr=20;                                                            //++ERR: присвоение кода ошибки; 
                if(++id.cntRptAddr>=id.maxRptAddr){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptAddr неудачных попыток; 
                id.stepSetBack=212+(id.cntRptAddr*3);  id.stepReturn=1;   id.step=80; return;}//++ERR: возврат на повтор с изменяемой задержкой;
                id.stepSetBack=11;                     id.stepReturn=2;   id.step=80; return;}//--Продолжение в следующий этап  с задержкой;  
if(id.step==2) {  //===========Поиск устройства на шине 1-Wire=====================================
  id.bf8=z.search(id.addr);                                                                   //--Поиск устройства (=1 успешный поиск);
  if(id.bf8==0){id.codeErrAddr=21;                                                            //++ERR: присвоение кода ошибки; 
                if(++id.cntRptAddr>=id.maxRptAddr){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptAddr неудачных попыток; 
                id.stepSetBack=216+(id.cntRptAddr*11); id.stepReturn=2;   id.step=80; return;}//++ERR: возврат на повтор с изменяемой задержкой;                 
  id.step++;}                                                                                 //--Продолжение в следующий этап без задержки; 
if(id.step==3) {  //===========Обработка полученного адреса=======================================
  id.okAddr=1; id.bf8=0; id.crcAddr=z.crc8(id.addr,7);                                        //--Расчет контрольной суммы CRC8;  
  if(id.crcAddr==id.addr[7]){id.bf8=1;}                                                       //--Установка флага совпадения CRC8;
  if(id.bf8==0){id.codeErrAddr=22;                                                            //++ERR: присвоение кода ошибки; 
                if(++id.cntRptAddr>=id.maxRptAddr){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptAddr неудачных попыток;
                id.stepSetBack=218+(id.cntRptAddr*17); id.stepReturn=1;   id.step=80; return;}//++ERR: возврат на полный повтор в step=1 с изменяемой задержкой;                
//-------------------------------------------------------------------------------------------------
  id.bf8=id.addr[0]; id.typeMdf=0; if(id.bf8==0x10){id.typeMdf=1;}                            //--Сохранение типа сенсора:=1 старый;=0 новый;           
  id.okAddr=1; id.err=0; id.action=0; id.step=0; 
  return;}                                     //++УСПЕШНЫЙ ВЫХОД; 
//=================Задержка=stepSetBack с возвратом на step=stepReturn=============================
if(id.step==80){if(RT_HW_Base.timeDelayMs(id.timeDelay,id.stepDelay,id.stepSetBack)){id.step=id.stepReturn;} return;} 
} //--END search_addr();

//=================================================================================================
//                      3.Функция измерения
//   При  ошибочных транзакциях выполняются повторы до maxRptAddr(настраиваемый параметр) 
//                                                    с увеличивающимся временем между повторами; 
//   Помимо CRC8 проверяется конфигурационный регистр - он должен быть не нулевым.  
//=================================================================================================
void meter(RT_HW_ONEWIRE &z, RT_HW_STRUCT_DS1820_ID &id){
if(id.step==0) {  //===========Подготовка параметров===============================================
  id.err=0; id.action=1; id.cntRptData=0;                                  id.step++; return;} //--Подготовка параметров и рродолжение в следующий этап без задержки;     
if(id.step==1) {  //===========Сброс шины 1-Wire=================================================== 
  id.bf8=z.reset();                                                                            //--Сброс шины (=1 получен ответ от устройств); 
  if(id.bf8==0){id.codeErrData=30;                                                             //++ERR: присвоение кода ошибки; 
                if(++id.cntRptData>=id.maxRptData){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptData неудачных попыток; 
                id.stepSetBack=52+(3*id.cntRptData);   id.stepReturn=1;   id.step=80; return;}//++ERR: возврат на повтор с изменяемой задержкой;              
                id.stepSetBack=10;                     id.stepReturn=2;   id.step=80; return;}//--Продолжение в следующий этап с задержкой;                                                  
if(id.step==2) { //============Команды "Пропуск адреса","Преобразование температуры"===============
  z.skip(); z.write(0x44,id.power);                                                           //--Команды 0xCC,0x44;
  id.stepSetBack=1000;                                 id.stepReturn=3;   id.step=80; return;}//--Продолжение в следующий этап с задержкой 800мс;                
if(id.step==3) { //============Сброс шины 1-Wire===================================================
  id.bf8=z.reset();                                                                           //--Сброс шины 1-Wire;
  if(id.bf8==0){id.codeErrData=31;                                                            //++ERR: присвоение кода ошибки; 
                if(++id.cntRptData>=id.maxRptData){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptData неудачных попыток; 
                id.stepSetBack=57+(14*id.maxRptData);  id.stepReturn=3;   id.step=80; return;}//++ERR: возврат на повтор с изменяемой задержкой;
                id.stepSetBack=10;                     id.stepReturn=4;   id.step=80; return;}//--Продолжение в следующий этап с задержкой;   
if(id.step==4) { //=============Команды "Пропуск адреса" и "Чтение памяти"=========================
  z.skip(); z.write(0xBE,id.power);                                                           //--Команды "Пропуск адреса" и "Чтение памяти";
  for(id.ix=0; id.ix<9; id.ix++){id.data[id.ix]=z.read();} id.okData=1;                       //--Последовательнон чтение 9 байт;
                id.stepSetBack=10;                     id.stepReturn=5;   id.step=80; return;}//--Продолжение в следующий этап с задержкой;
if(id.step==5) {  //===========Обработка полученных данных=========================================
  id.crcData=z.crc8(id.data,8); id.bf8=1;                                                     //--Расчет контрольной суммы;
       if(id.data[4]==0)          {id.bf8=0; id.codeErr=32;}                                  //--Ошибка по конфигурационному регистру;
  else if(id.crcData!=id.data[8]) {id.bf8=0; id.codeErr=33;}                                  //--Ошибка по CRC8;
  if(id.crcData==id.data[8])      {id.bf8=1;}                                                 //--Установка флага совпадения CRC8; 
  if(id.data[4]==0)               {id.bf8=1;}                                                 //--Проверка конфигурационного регистра;
  if(id.bf8==0){id.codeErr=32;                                                                //++ERR: присвоение кода ошибки; 
                if(++id.cntRptData>=id.maxRptData){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptData неудачных попыток;  
                id.stepSetBack=63+(17*id.cntRptData);  id.stepReturn=3;   id.step=80; return;}//++ERR: возврат на полный повтор в step=3 с изменяемой задержкой; 
//------------------------------Формирование температуры data[0,1,4,6,7----------------------------              
  id.depth=12;   id.bf8=1;                                                                    //--Предварительная установка разрядности измерения;
  id.raw=(id.data[1] << 8) | id.data[0];                                                      //--Обработка первых 2-х байт;
  if(id.typeMdf){id.raw=id.raw<<3;if(id.data[7]==0x10){id.raw=(id.raw&0xFFF0)+12-id.data[6];}}//--Расчет для старого сенсора (DS18S20); 
  else          {id.bf8=id.data[4] & 0x60;                                                    //--Расчет для новых сенсоров;
                      if(id.bf8==0x00){id.raw = id.raw & ~7; id.depth=9;}                     //    9 bit res, 93.75 ms;
                 else if(id.bf8==0x20){id.raw = id.raw & ~3; id.depth=10;}                    //   10 bit res, 187.5 ms;
                 else if(id.bf8==0x40){id.raw = id.raw & ~1; id.depth=11;}}                   //   11 bit res, 375   ms; default is 12 bit res, 750 ms; 
  if((id.raw>2000) || (id.raw<(-640))){id.bf8=0;}                                             //--Контроль диапазона температуры (-40 - +125гр.С)
  if(id.bf8==0){id.codeErrData=34;                                                            //++ERR: присвоение кода ошибки;
                if(++id.cntRptData>id.maxRptData){id.action=0; id.err=1; id.step=0;  return;} //++ERR: ВЫХОД после maxRptData неудачных попыток; 
                id.stepSetBack=72+(21*id.cntRptData);  id.stepReturn=1;  id.step=80; return;} //++ERR: возврат на полный повтор в step=1 с изменяемой задержкой; 
//-------------------------------------------------------------------------------------------------  
  id.step=0; id.err=0; id.action=0; return;}                                                  //--Успешный выход; 
//=================Задержка=stepSetBack с возвратом на step=stepReturn=============================
if(id.step==80){if(RT_HW_Base.timeDelayMs(id.timeDelay,id.stepDelay,id.stepSetBack)){id.step=id.stepReturn;} return;} 
}  //--END measurement();

//=================================================================================================


//=================================================================================================
//                              4.1.Вывод результатов измерений
//=================================================================================================
void messDS1820(RT_HW_STRUCT_DS1820_ID &id, uint8_t cmnd=0){  
if(!id.fresh) {return;}; id.fresh=0;
id.bf8=id.addr[0];    
//--------------------------------------------------------------------------------------------------
if(cmnd>=1){
                      RT_HW_Base.consoleVar(String(F("Chip=")));               
     if(id.bf8==0x10){RT_HW_Base.consoleVar(String(F("DS18S20")));}
else if(id.bf8==0x28){RT_HW_Base.consoleVar(String(F("DS18B20")));}
else if(id.bf8==0x22){RT_HW_Base.consoleVar(String(F("DS1822")));}
else                 {RT_HW_Base.consoleVar(String(F("ANON")));}
}
//--------------------------------------------------------------------------------------------------
if(cmnd>=2){
RT_HW_Base.consoleTest(String(F(" bit")),id.depth,' ');}
//-------------------------------------------------------------------------------------------------- 
if(id.ok){RT_HW_Base.consoleChar('+');} else {RT_HW_Base.consoleChar('-');} 
RT_HW_Base.consoleVar(String(F("Temp=")));    RT_HW_Base.consoleVar(id.vTemp,';'); //--Вывод температуры; 
RT_HW_Base.consoleVar(String(F(" CntOk=")));  RT_HW_Base.consoleVar(id.cntOk,   ';',0,'U');
//--------------------------------------------------------------------------------------------------
if(cmnd>=3){
if(id.codeErrData){
RT_HW_Base.consoleVar(String(F(" codeErrData="))); RT_HW_Base.consoleVar(id.codeErrData,';');}}
//--------------------------------------------------------------------------------------------------
if(id.cntErr>0){
RT_HW_Base.consoleVar(String(F(" CntErr=")));      RT_HW_Base.consoleVar(id.cntErr,  ';',0,'U');}
RT_HW_Base.consoleCR();
}

//=================================================================================================
//                              4.2.Вывод массива с адресом
//=================================================================================================
void messAddr(RT_HW_STRUCT_DS1820_ID &id){  
if(id.okAddr){id.okAddr=0;
id.bf8=id.addr[0]; //-Cохранение модикациии
RT_HW_Base.consoleVar(String(F("Addr->ds1820="))); RT_HW_Base.consoleArr(id.addr, ';',0,'H',8); 
RT_HW_Base.consoleVar(String(F(" CRC8=")));        RT_HW_Base.consoleVar(id.crcAddr,';',0,'H');
RT_HW_Base.consoleVar(String(F(" type=")));        RT_HW_Base.consoleVar((uint8_t)id.typeMdf,';');
if(id.codeErrAddr){
RT_HW_Base.consoleVar(String(F(" codeErrAddr="))); RT_HW_Base.consoleVar(id.codeErrAddr,';');
RT_HW_Base.consoleVar(String(F(" cntRptAddr=")));  RT_HW_Base.consoleVar(id.cntRptAddr,';');
}
RT_HW_Base.consoleCR();                            //--Перевод строки;
RT_HW_Base.consoleLine('-',80);                    //--Вывод линии;
}}
//=================================================================================================
//                              4.3.Вывод массива с данными
//=================================================================================================
void messData(RT_HW_STRUCT_DS1820_ID &id){  
if(id.okData){id.okData=0;
RT_HW_Base.consoleVar(String(F("Data=")));  	   RT_HW_Base.consoleArr(id.data,';',0,'H',9);
RT_HW_Base.consoleVar(String(F(" CRC8="))); 	   RT_HW_Base.consoleVar(id.crcData,';',0,'H');
if(id.codeErrData){
RT_HW_Base.consoleVar(String(F(" codeErrData="))); RT_HW_Base.consoleVar(id.codeErrData,';');
RT_HW_Base.consoleVar(String(F(" cntRptData=")));  RT_HW_Base.consoleVar(id.cntRptData,';');
}
RT_HW_Base.consoleCR(); 
}}
//=================================================================================================
//                              4.4.Вывод ошибок
//=================================================================================================
void messErr(RT_HW_STRUCT_DS1820_ID &id, uint8_t &agoCodeErr, uint8_t &agoCntRptAddr, uint8_t &agoCntRptData){
if((agoCodeErr!=id.codeErr) || (agoCntRptAddr!=id.cntRptAddr) || (agoCntRptData!=id.cntRptData)){   
agoCodeErr=id.codeErr; agoCntRptAddr=id.cntRptAddr; agoCntRptData=id.cntRptData;
RT_HW_Base.consoleTest(String(F("ERR: codeErr")),    id.codeErr,';');
RT_HW_Base.consoleTest(String(F(" ->codeErrAddr")),  id.codeErrAddr,';');
RT_HW_Base.consoleTest(String(F(" cntRptAddr")),     id.cntRptAddr,';');
RT_HW_Base.consoleTest(String(F(" ->codeErrData")),  id.codeErrData,';');
RT_HW_Base.consoleTest(String(F(" cntRptData")),     id.cntRptData,';');
RT_HW_Base.consoleCR();
}}
//=================================================================================================
//                              4.5.Вывод этапов работы
//=================================================================================================
void messDebugDir(RT_HW_STRUCT_DS1820_ID &id, uint8_t &agoDir, uint8_t &agoStep){
if((agoDir!=id.dir) || (agoStep!=id.step)){
agoDir=id.dir; agoStep=id.step;
RT_HW_Base.consoleTest(String(F(" dir")),         id.dir,';');
RT_HW_Base.consoleTest(String(F(" step")),        id.step,';');
RT_HW_Base.consoleTest(String(F(" stepReturn")),  id.stepReturn,';');
RT_HW_Base.consoleTest(String(F(" stepSetBack")), id.stepSetBack,';');
RT_HW_Base.consoleCR(); 
}}
//=================================================================================================
};
//=================================================================================================
extern RT_HW_DS1820 	RT_HW_ds1820; 				//--Создание объекта RT_HW_SR04;
//=================================================================================================
#endif
//=================================================================================================