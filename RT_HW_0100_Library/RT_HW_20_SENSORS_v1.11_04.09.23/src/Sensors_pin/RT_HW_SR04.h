//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//            ЧТЕНИЕ СЕНСОРА  HC-SR04
//
/*
HC-SR04 (и аналоги)  Ультразвуковой дальномер.
Поддерживается "горячее" подключение и работа по прерываниям.
Имеется подключаемый медианный фильтром 3,5,7 или 9 порядка. 
Датчик может подключаться через один или два пина.
Показания могут корректироваться с учетом внешнего значения температуры воздуха(Temp.Air).
 
Основные параметры:
  1. Выбор номеров пинов.
  2. Пользовательские номера пинов[plug=OFF].
  3. Подключение через один пин Trig(соединить с Echo R=470)[default=ON]. 
  4. Режим измерения - периодический,по переднему фронту eN или в каждом цикле[default=периодический].
Период измерения:
  1. Период измерения  [default=75ms].
  2. Пользовательский период измерения[default=100ms].
Дополнительные параметры:
  1. Количество повторов при ошибке измерения[default=4].
  2. Максимальная дистация(см)[default=450].
  3. Режим фильтрации[default=медианный 3-го порядка(ускоренный)].
Входы: 
  1. eN - запуск измерения по переднему фронту [для режима измерения по переднему фронту].
  2. Temp.Air - температура окружающего воздуха[plug=OFF].
  3. EN - разрешение работы блока [plug=OFF].
Выходы:
  1. ok - флаг готовности устройства [plug=ON].
  2. Lсм - расстояние в см [plug=1].
  3. Lмм - расстояние в мм [plug=0].
  4. fresh - флаг готовности измерений(событие) [plug=OFF]. 
---------------------------------------------------------------------------------------------------
Работа по прерываниям поддерживается для пина Echo с аппаратным прерыванием,
в противном случае измерения проводится в режиме программного ожидания ответного
импульса, что приводит к задержке работы контроллера дл 16мс(в зависимости от измеренного расстояния). 
---------------------------------------------------------------------------------------------------
Рекомендации для использовании в FLProg: 
использовать Диспетчер задач и устанавливать на плате, управляемой  как "Свободная задача"
или обеспечить частый вызов блока [например в каждом цикле loop()].
---------------------------------------------------------------------------------------------------
 ecoins@mail.ru 01.10.2022. 
*/
//-------------------------------------------------------------------------------------------------
/*
Last measurement error code:
203 - не допустимый пин Trig;
204 - не допустимый пин Echo прни подключении через два пина;
210 - тайм-аут при обработке ответного импульса Echo в режиме с прерыванием;
211 - тайм-аут при обработке ответного импульса Echo в режиме без прерываний;
211 - преждевременность переднего фронта ответного импульса Echo;
*/
// При измерении параметров ответного эхо-импульса c аппаратным прерывание в скетч или в блок FLProg 
// должны быть включены определения переменных и функции 
// volatile uint8_t  state; 
// volatile uint32_t timeBegin;
// volatile uint32_t timeEnd;
// volatile uint32_t timeStart;
//
//if(z.state==1) {z.state++;  attachInterrupt(z.numIRQ, RT_HW_IRQ_SR04_handler_120905424,CHANGE);} //--start IRQ_handler; 
//RT_HW_IRAM_ATTR void RT_HW_IRQ_SR04_handler_120905424(){          
//(z.state==2) {if( RT_HW_PIN_DIR_READ(z.ddPin)){z.timeBegin=micros(); z.state=3;}}
//(z.state==3) {if(!RT_HW_PIN_DIR_READ(z.ddPin)){z.timeEnd  =micros(); z.state=4;}}}
// state=0 - отключен
// state=2 - готовность к определению переднего фронта;
// state=3 - готовность к определению заднего   фронта;
// state=4 - обработка по прерываниям завершена;
// state=5 - измерение завершено успешно;
// state=6 - измерение завершено по timeOut заднего в режиме без прерывания);
// state=7 - ошибка по преждевренному переднему фронту;
// state=8 - ошибка по timeOut переднего фронта;
// state=9 - ошибка по timeOut заднего    фронта;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//-------------------------------------------------------------------------------------------------
#ifndef RT_HW_SR04_h
#define RT_HW_SR04_h
#define RT_HW_SR04_VER 		 	   10	//--Номер версии библиотеки;
#include "RT_HW_BASE.h"					//--Подключение базовой библиотеки;
//-------------------------------------------------------------------------------------------------
#define RT_HW_SR04_timePulse	   10	//--Длительность (mcs) генерируемого импульса на пине Trig; 
#define RT_HW_SR04_maxBegin      1200	//--Максимальное время (mcs) появления ответного импульса Echo; 
#define RT_HW_SR04_minBegin       200	//--Минимальное время  (mcs) появления ответного импульса Echo; 
#define RT_HW_SR04_maxDurate    49000	//--Максимальная длительность ответного импульса;
#define RT_HW_SR04_convert        582 	//--Коэффициент пересчета мкс в мм;
#define RT_HW_SR04_CmToMcs	   	   70 	//--Коэффициент преобразования; 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//		Структура для сенсора HC-SR04
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
struct RT_HW_STRUCT_SR04_ID{
RT_HW_PIN_DIR_ID ddPin;
uint8_t  custom=0;
uint8_t  dir=0;					//--Этапы управления основной программы;
uint8_t	 extPinEcho=255;		//--Новое значение пина Echo(можно считать перед началом измерения);
uint8_t  extPinTrig=255;		//--Новое значение пина Trig(можно считать перед началом измерения);
uint8_t	 pinEcho=255;			//--Номер пина Echo;
uint8_t  pinTrig=255;			//--Номер пина Trig;
uint8_t  maxQntErr=4;			//--Максимальное допустимое подряд кол-во ошибочных измерений;
uint8_t  ok;					//--Флаг устойчивой работоспособности сенсора;
uint8_t  fresh;					//--Готовность данных;
uint8_t  run=1;					//--Флаг "Кeоманда на запуск измерения;
uint8_t  finish=0;              //--Флаг завершения измерения;
uint8_t  codeErr;				//--Код последней ошибки измерения;
uint8_t  cntErrCur; 			//--Cчетчик ошибок;
uint16_t cntOk;					//--Счетчик успешных измерений;
uint16_t cntErr;				//--Счетчик ошибочных измерений;
//---------------------------------------------------------------------------------------------------
uint16_t maxLen=400;			//--Максимальное расстояние измерения;
int8_t   tmpAir=-100;			//--Температура воздуха;
int8_t   extAir=23;				//--Внешнее значение температуры воздуха
//---------------------------------------------------------------------------------------------------
uint8_t	 enableIRQ=1;			//--Разрешение режима с прерываниями;
int8_t 	 numIRQ;				//--Номер аппаратного прерывания;
uint8_t  modeIRQ;				//--Режим работы: =0 -без прерываний; =1 -с прерываниями на пине Echo; 
uint8_t  begin,end;				//--Флаги для отслеживания прерываний;
uint8_t  modeFilter=3;			//--Тип фильтра;
float    speedSoundAir;			//--Скорость звука (функция от температуры);
uint16_t echoMcs, LenMcs;		//--Расстояние в mcs от сенсора и с фильтром(внешним); 
uint16_t Len;
volatile uint8_t  state;
volatile uint32_t timeStart;
volatile uint32_t timeCur;
volatile uint32_t timeBegin;
volatile uint32_t timeEnd;
//-------------------------------------------------------------------------------------------------
uint8_t  stepReturn;     //--Номер шага для возврата       add  function;
uint16_t stepSetBack;    //--Задержка перед возвратом      add  function;
uint32_t timeDelay;      //--Рабочий параметр              add  function (timeDelay в timeDelayMs());
uint8_t  stepDelay=0;    //--Рабочий параметр              add  function (stepDelay в timeDelayMs());
};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                     КЛАСС УПРАВЛЕНИЯ SHT3X
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class RT_HW_SR04{
public:
//-------------------------------------------------------------------------------------------------
void setParamID(RT_HW_STRUCT_SR04_ID &z, uint8_t pin)                                      {z.custom=1; z.extPinTrig=pin;}
void setParamID(RT_HW_STRUCT_SR04_ID &z, uint8_t pin, uint16_t maxLen)                     {z.custom=1; z.extPinTrig=pin; z.maxLen=maxLen;}
void setParamID(RT_HW_STRUCT_SR04_ID &z, uint8_t pinEcho, uint8_t pinTrig, uint16_t maxLen){z.custom=1; z.extPinTrig=pinTrig; z.extPinEcho=pinEcho; z.maxLen=maxLen;}
//-------------------------------------------------------------------------------------------------
void direct(RT_HW_STRUCT_SR04_ID &z){	
//=================================================================================================
if(z.dir==0){
z.run=1; z.fresh=1; z.ok=0;
z.LenMcs=z.maxLen*RT_HW_SR04_CmToMcs;;				//--Установка начальных состояний;
z.codeErr=0; z.cntErrCur=0; z.maxQntErr=3;			//--Параметры ошибок измерений;
z.cntOk=z.cntErr=0;									//--Очистка счетчиков наработки;
sr04_air(z);										//--Расчет скорости воздуха;
//-------------------------------------------------------------------------------------------------
z.pinTrig=z.extPinTrig;
if(!RT_HW_Base.checkPinPGM(RT_HW_PGM_PIN_DIN_ID,z.pinTrig)){z.codeErr=203; z.dir=90; return;}
//-------------------------------------------------------------------------------------------------
z.pinEcho=z.extPinEcho; 
if(z.pinEcho==255){z.pinEcho=z.pinTrig;} 
if(!RT_HW_Base.checkPinPGM(RT_HW_PGM_PIN_DIN_ID,z.pinEcho)){z.codeErr=204; z.dir=90; return;}
//-------------------------------------------------------------------------------------------------
//consoleVar(String(F("1.extPinTrig, pinTrig, first->"))); consoleVar(z.extPinTrig,','); consoleVar(z.pinTrig,','); consoleVar(z.first,'E');
//consoleVar(String(F("2.extPinEcho, pinEcho, first->"))); consoleVar(z.extPinEcho,','); consoleVar(z.pinEcho,','); consoleVar(z.first,'E');
z.dir++;}
//=================================================================================================
//					По команде запуска(run) проверка входных параметров и запуск измерения
//=================================================================================================
if(z.dir==1){
if(!z.run) {return;} z.run=0; z.finish=0;																//--Ожидание команды запуска;
//-------------------------------------------------------------------------------------------------
z.numIRQ=digitalPinToInterrupt(z.pinEcho);								//--Проверка пина Echo на наличие прерываний, возвращает -1,;
if((z.numIRQ>=0) && (z.enableIRQ)){z.modeIRQ=1;} else{z.modeIRQ=0;}		//--Выбор режима обработки (с прерываниями/без прерываний);
//-------------------------------------------------------------------------------------------------
if(z.modeIRQ){detachInterrupt(z.numIRQ);}			//--Блокировка прерываний на Echo; 
z.state=0; z.begin=z.end=false;						//--Очистка регистров; 
//----------Формирование запускающего импульса------------------------------------------------------
pinMode(z.pinTrig,OUTPUT); 
digitalWrite(z.pinTrig,1); 
delayMicroseconds(10); 
digitalWrite(z.pinTrig,0);	 
//---------------------------------------------------------------------------------------------------
RT_HW_PIN_DIR_SET_ID(z.ddPin,z.pinEcho);			//--Настройка ddPin на пин Trig;
RT_HW_PIN_DIR_MODE_PULLUP(z.ddPin);					//--Пин Echo на ввод с подтяжкой к Vcc; 		   
//----------Проверка входа Echo (должен быть =0 нем менее 200mcs)-----------------------------------
if(RT_HW_PIN_DIR_READ(z.ddPin)){z.state=7; z.dir=10;}//--Чтение Echo. При наличии датчика HIGH не появляется ранее400mcs;		
z.timeStart=RT_HW_MICROS; z.timeBegin=z.timeEnd=micros();//--Фиксация начальных времен;	
//----------Переход на обработку по прерыванию/без прерывания--------------------------------------
if(z.modeIRQ){z.state=1; z.dir=2;}  else{z.state=2; z.dir=3;}
}
//=================================================================================================
// 					Обработка импульса Echo в режиме C ПРЕРЫВАНИЯ
//=================================================================================================
if(z.dir==2){if(z.state==4){detachInterrupt(z.numIRQ); z.dir=10;}}
if(z.dir==2){
	z.timeCur=RT_HW_MICROS; 
    if(RT_HW_Base.calcPastTime(z.timeStart,z.timeCur)>RT_HW_SR04_maxDurate){
	detachInterrupt(z.numIRQ); 
	z.state=9; z.codeErr=210;  z.dir=90;
	}
};						
//=================================================================================================
// 					Обработка импульса Echo в режиме БЕЗ ПРЕРЫВАНИЯ
//=================================================================================================
if(z.dir==3){															
//-------------------------------------------------------------------------------------------------
//				Фиксация переднего фронта на пине Echo c контролем тайм-аута
//------------------------------------------------------------------------------------------------- 
if(z.state==2){do{z.timeBegin=RT_HW_MICROS; if( RT_HW_PIN_DIR_READ(z.ddPin)){z.state=3; break;}  		 
 if(RT_HW_Base.calcPastTime(z.timeStart,z.timeBegin)>(RT_HW_SR04_maxBegin)){z.state=8; z.timeEnd=z.timeBegin;break;}}while(1);}
//-------------------------------------------------------------------------------------------------
//				Фиксация заднего фронта на пине Echo c контролем тайм-аута
//------------------------------------------------------------------------------------------------- 
if(z.state==3){do{z.timeEnd=micros();   if(!RT_HW_PIN_DIR_READ(z.ddPin)){z.state=5; break;} //---Выход по тайм-ауту ожидания заднего фронта;
   if(RT_HW_Base.calcPastTime(z.timeBegin,z.timeEnd)>(z.maxLen*RT_HW_SR04_CmToMcs)){z.state=6; break;}}while(1);}
//-------------------------------------------------------------------------------------------------
//				Переход на этап, в зависимости от результатов обработки импульса Echo; 
//-------------------------------------------------------------------------------------------------
if((z.state==5) || (z.state==6)) {z.dir=10;} else {z.codeErr=211; z.dir=90;};}  
//=================================================================================================
//       	   Проверка на преждевременность переднего фронта
//=================================================================================================
if(z.dir==10){if(RT_HW_Base.calcPastTime(z.timeStart,z.timeBegin)< RT_HW_SR04_minBegin){z.state=7; z.codeErr=212; z.dir=90;}}  
//=================================================================================================
//				Расчет длительности ответного импульса и расстояние в мм
//=================================================================================================
if(z.dir==10){z.run=0; z.cntOk++; z.LenMcs=z.echoMcs=(uint16_t)RT_HW_Base.calcPastTime(z.timeBegin,z.timeEnd); z.cntErrCur=0; z.ok=1; z.fresh=1; z.dir=100;
//RT_HW_Base.consoleTest(String(F("SR04 Len.mcs")),z.LenMcs);
}	
//=================================================================================================
//       				Обработка ошибочных измерений
//=================================================================================================
if(z.dir==90){z.run=0; z.cntErr++; if(++z.cntErrCur>z.maxQntErr){z.cntErrCur=0; z.ok=0; z.fresh=1; z.LenMcs=z.echoMcs=z.maxLen*RT_HW_SR04_CmToMcs;} z.dir=100;}
//=================================================================================================
//====Задержка 30мс перед завершением цикла измерения (для устранения влияния остаточного эха======
if(z.dir==100){if(RT_HW_Base.timeDelayMs(z.timeDelay,z.stepDelay,30)){z.finish=1; z.dir=1;} return;}
};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//            				Расчет скорости звука с учетом окружающей температуры;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void sr04_air(RT_HW_STRUCT_SR04_ID &z){if(z.tmpAir!=z.extAir){z.tmpAir=z.extAir; z.speedSoundAir=(331.3+(0.606*float(z.tmpAir)))/2000.0;}}
//=================================================================================================
};
//=================================================================================================
extern RT_HW_SR04 	RT_HW_sr04; 									//--Создание объекта RT_HW_SR04;
//=================================================================================================
#endif
//=================================================================================================