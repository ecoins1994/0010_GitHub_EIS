//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                                  BASIC TEST №05 ver.2.4 25.09.2023  
//                              ТЕСТИРОВАНИЕ УСТРОЙСТВ С ВЫВОДОМ НА ДИСПЛЕИ
//                        (совместим с визуальной системой программирования FLProg)
//    1.1.Настройка параметров в т.ч. тестовые пины, которые могут быть изменены.
//    1.2.В каждом цикле loop() вызывается "Диспетчер задач".
//    1.3.Каждую секунду обрабатываюся секундные параметры - быстродействие проекта, время наработки).
//    2.1.Инициализируется консоль (в терминах Arduino IDE - монитор порта). 
//    2.2.После готовности консоли (проверка консоли особо критична для контроллеров с USB на кристалле - STM32,Raspberry Pi,ESP32-C3,S2,S3),
//        в монитор порта однократно выводяся отчет о проекте (пины, наличие коммуникаций и др.),
//        сканируется шина i2c (SDA,SCL необходимо подтянуть к Vcc резисторами 10-47к).
//    3.1.В каждом цикле loop() меняется значение на пине Control (для логического анализатора).
//    3.2.На пин Led выводится меандр 500ms.
//    4.1.Периодически читается пин ADC(period 100ms). Отфильтрованное значение ADC выводится на пин PWM.
//    4.2.Читается значение пина "Кнопка" с защитой от дребезга 50ms.
//    5.  Сенсоры чере пины: DHT22,DS1820,HC-SR04;
//    6.  Sensors via i2c:  AHTxx(T,H),BMP280(P),SHT3x(T,H),HTU21(T,H); 
//    8.  Extenders via i2c: MCP4725(DAC);
//    9.  Extenders via SPI: 74HC595 "Running 1" ;
//    10. Вывод на Lcd1.i2c(0x27)
//          Кнопка=0:  строка 1:Blink(*),ADC,флаг второго ядра(+/-), счетчик второго ядра, ,Speed/1000.
//                     строка 2:Ok CombiSensor,Temp,Hum(AHTxx).  
//          Кнопка=1:  строка 1:Blink(#),DS1820.ok,DS1280.Temp,HC-SR04.ok,HC-SR04.Len;
//                     строка 2:SHT3x.ok,SHT3x.Temp,SHT3x.Hum.  
//=================================================================================================
//
//    Подключение к выполнению различных устройств выполняется через снятие символов комментариев(//) 
//    с соответствующего макроса.
//-------------------------------------------------------------------------------------------------
//    Перечень поддерживаемых плат размещен во вкладке Readme.hpp.
//    Там же размещены инструкции по настройке Arduino IDE, 
//    для ESP32 дополнительная инструкция для достижения большего удобства.
//-------------------------------------------------------------------------------------------------
// ecoins@mail.ru 14.10.23
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    0.1.Разрешения использования системных устройств [Asystem.hpp]
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
  #define RT_HW_TEST_PERMIT_AHTx        //--Разрешение использования сенсора SHT3x;
//#define RT_HW_TEST_PERMIT_74HC595     //--Разрешение использования расширителя 74HC595;
  
  #define RT_HW_TEST_PERMIT_74HC165     //--Разрешение использования расширителя 74HC165;  
  #define RT_HW_TEST_PERMIT_MCP4725     //--Разрешение использования расширителя MCP4725;


  #define RT_HW_TEST_PERMIT_DOT_PLC     //--Разрешение использования выходов PLC RP2040;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    0.2.Разрешения использования дополнительных сенсоров [Csensor.hpp]
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++   
//#define RT_HW_TEST_PERMIT_SHT3x       //--Разрешение использования сенсора SHT3x;
  #define RT_HW_TEST_PERMIT_BME280      //--Разрешение использования сенсора BME280;
//#define RT_HW_TEST_PERMIT_BMP180      //--Разрешение использования сенсора BMP180;
  #define RT_HW_TEST_PERMIT_BH1750      //--Разрешение использования сенсора BH1750;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    0.3.Разрешения использования дополнительных расширителей [Expander.hpp]
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#define RT_HW_TEST_PERMIT_MCP23017    //--Разрешение использования расширителя MCP23017(i2c);
//#define RT_HW_TEST_PERMIT_PCF8575     //--Разрешение использования расширителя PCF8575 (i2c);
  #define RT_HW_TEST_PERMIT_ADS1115     //--Разрешение использования расширителя ADS1115(i2c);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    0.4.Разрешения использования дополнительных дисплeeв [Expander.hpp]
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  #define RT_HW_TEST_PERMIT_LCD1_i2c    //--Разрешение подключения дисплея Lcd1.i2c  16x2;
  #define RT_HW_TEST_PERMIT_LCD2_i2c    //--Разрешение подключения дисплея Lcd2.i2c  20x4; 
  #define RT_HW_TEST_PERMIT_LCD6_i2c    //--Разрешение подключения дисплея Lcd6.i2c  20x4;
  #define RT_HW_TEST_PERMIT_LCD5_NEXT   //--Разрешение подключения дисплея Lcd5.Next 20x4 (Nextion);  
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    0.5.Разрешения использования работы с Ethernet
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  #define RT_HW_TEST_PERMIT_ETHERNET        //--Разрешение тестов работы с Ethernet;
//#define RT_HW_TEST_PERMIT_ETHERNET_NTP    //--Разрешение тестов работы c NTP-cерверами(серверы точного времени);
//#define RT_HW_TEST_PERMIT_ETHERNET_SERVER //--Разрешение тестов работы c cервером;
//=================================================================================================
//                    0.6.Подключение библиотек
//=================================================================================================
  #include "RT_HW_BASE.h"               //--Подключение базовой библиотеки;
  #include "RT_HW_LCD44780.h"           //--Подключение библиотеки дисплеев типа HD44780;
  #include "RT_HW_NEXT.h"               //--Подключение библиотеки дисплеев типа Nextion;
  #include "RT_HW_SENSORS.h"            //--Подключение библиотек базовых сенсоров(DHT22,DS1820,HC-SR04,AHTx,BH1750,BME280,BMP180,HTU21,SHT3x,PAJ602U2,MAX6675);
  #include "RT_HW_EXPANDERS.h"          //--Подключение библиотек базовых расширителей(MCP4725,PCF8575,ADS1115,74HC595,74HC165,MCP23x17);
//=================================================================================================
//                    0.7.Подключение библиотек вместе с созданием необходимых объектов
//=================================================================================================
//                    0.7.1. Ethernet
//-------------------------------------------------------------------------------------------------
#if defined (RT_HW_TEST_PERMIT_ETHERNET) 
  #define   RT_HW_TEST_ETH                    //--Макрос подключения Ethernet;
  #include "RT_HW_ETHERNET.h"                 //--Подключение библиотеки  Ethernet(включает подключение flprogEthernet.h);  
  RT_HW_ETHERNET_LINK     ethDEV;             //--Создание объекта данных Ethernet(со временем возможно уйдет в библиотеку flprogEthernet.h);  
  FLProgWiznetInterface   eth;                //--Создание объекта класса Ethernet;
#endif
//------------------------------------------------------------------------------------------------
//                    0.7.2. NTP-сервер через Ethernet
//-------------------------------------------------------------------------------------------------
#if defined (RT_HW_TEST_PERMIT_ETHERNET) &&  defined(RT_HW_TEST_PERMIT_ETHERNET_NTP)
  #define   RT_HW_TEST_ETH_NTP                //--Макрос подключения NTP-сервера через Ethernet;
  #include "RT_HW_ETHERNET_NTP.h"             //--Подключение библиотеки  NTP (включает подключение flprogEthernet.h,RT_HW_ETHERNET.h);
  RT_HW_ETHERNET_NTP_DEV  ntpDEV;             //--Создание объекта данных NTP (со временем возможно уйдет в библиотеку flprogEthernet.h);
  RT_HW_STRUCT_SHED_TASK  shNTP;              //--Создание объекта управления вызовом NTP;
  FLProgUdpClient         ethUDP(&eth);       //--Создание объекта класса Ethernet UDP для использования сервером точного времени;
#endif
//------------------------------------------------------------------------------------------------
//                    0.7.3. Cервер через Ethernet
//-------------------------------------------------------------------------------------------------
#if defined (RT_HW_TEST_PERMIT_ETHERNET) &&  defined(RT_HW_TEST_PERMIT_ETHERNET_SERVER)
  #define   RT_HW_TEST_ETH_SERVER             //--Макрос подключения cервера через Ethernet;
  FLProgEthernetServer    ethServer(&eth,80); //--Создание объекта класса Ethernet Server;
  uint8_t ethServerStatus = 255;
  uint8_t ethServerError  = 255;
#endif
//=================================================================================================
//                    0.8.Подключение внутренних вкладок
//=================================================================================================
  #include "A1system.hpp"               //--Системные параметры и функции (ADC,PWM,Кнопка,DHT22,DS1820,HC-SR04,AHTxx);
  #include "A2console.hpp"              //--Функции вывода на консоль;
  #include "B1deviceBase.hpp"           //--Сенсоры;
  #include "B2sensorAdd.hpp"            //--Сенсоры дополнительные;  
  #include "B3expanderAdd.hpp"          //--Расширители дополнительные;
  #include "B4_PLC.hpp"                 //--Расширители PLC RP2040;
  #include "Fethernet.hpp"              //--Ehernet;
//-------------------------------------------------------------------------------------------------
  #include "D1Lcd1.hpp"                 //--Подключение вкладки Lcd1(i2c) 16x4;       
  #include "D2Lcd2.hpp"                 //--Подключение вкладки Lcd2(i2c) 20x4; 
  #include "D6Lcd6.hpp"                 //--Подключение вкладки Lcd2(i2c) 20x4;
//-------------------------------------------------------------------------------------------------
  #include "Lcd5_Nxt.hpp"               //--Подключение вкладки Lcd5_Nxt(дисплей Nextion через UART); 
//=================================================================================================
//                                    I.Секция SETUP()
//=================================================================================================
void setup(){}
//=================================================================================================
//                                    II.Секция LOOP()
//=================================================================================================
void loop(){
//================================================================================================= 
//                     2.1.Инициализация параметров и диспетчер
//================================================================================================= 
  initProject();                               //--Инициализация параметров;
  RT_HW_Base.sheduler(shed);                   //--Диспетчер задач(CORE0);
//================================================================================================= 
//                     2.2.Управление консолью
//=================================================================================================
  RT_HW_Base.consoleBegin();                   //--Инициализация консоли;
  if(RT_HW_Base.consoleHead()){consoleHead();} //--Однократный вывод отчета по MC;
//=================================================================================================
//                     2.3.Управление через Ethernet
//================================================================================================= 
#ifdef RT_HW_TEST_ETH
  eth.pool();                                  //--Управление Ethernet. Вызывается в каждом цикле;
  if(shed.frdm.num==2){                        //--Вызов выполнения через диспетчер задач;                            
//-------------------------------------------------------------------------------------------------
  if(ethDEV.custom==0){ethDEV.custom=1;        //--Проверка настройки параметров Ethernet (для однократной настройки);
  eth.setPinCs(csEthernet);  eth.setSpiBus(0); //--Настройка номера пина CS и номера шины SPi;
  eth.mac(RT_HW_Base.buff.mac[0],RT_HW_Base.buff.mac[1],RT_HW_Base.buff.mac[2],RT_HW_Base.buff.mac[3],RT_HW_Base.buff.mac[4],RT_HW_Base.buff.mac[5]); //--Установка MAC-адреса;
  }
  RT_HW_Ethernet.printEthMess(eth,ethDEV);     //--Вывод контрольных сообщений;
//-------------------------------------------------------------------------------------------------
} //--END if(shed.frdm.num==2);
#endif
//=================================================================================================
//                    2.4.Управление NTP-сервером через Ethernet
//================================================================================================= 
#ifdef  RT_HW_TEST_ETH_NTP                     //--Макрос разрешения при подключении библиотек ETHERNET и ETHERNET_NTP;
  if(shed.frdm.num==4){                         //--Вызов выполнения через диспетчер задач;   
//-------------------------------------------------------------------------------------------------
  if(ntpDEV.custom==0){ntpDEV.custom=1;         //--Проверка настройки парамеров NTP-серверE (для однократной настройки); 
  ethUDP.setDnsCacheStorageTime(600000);        //--Установка для клиента время хранения DNS кэша=10 минут (default=60000);
  RT_HW_Base.setTaskID(shNTP,'P',5000); }       //--Настройка периодического вызова с период 5000ms(5сек)  (default=5000);
//-------------------------------------------------------------------------------------------------
  RT_HW_Base.directTask(shNTP);                 //--Управление вызова    задачи "Запрос времени от NTP";      
  RT_HW_EthNTP.direct(eth,ethUDP,ntpDEV,shNTP.run); //--Вызов            задачи "Запрос времени от NTP";   
  if(ntpDEV.fresh){ntpDEV.fresh=0; RT_HW_Base.unixID.timeUNIX=ntpDEV.timeUNIX;} //--Корректировка времени от NTP-сервера; 
//-------------------------------------------------------------------------------------------------
} //--END if(shed.frdm.num==4);
#endif

//=================================================================================================
//                    2.5 Управление сервером через Ethernet
//================================================================================================= 
#ifdef RT_HW_TEST_ETH_SERVER                    //--Макрос разрешения ;
  if(shed.frdm.num==5){                         //--Вызов выполнения через диспетчер задач;   
//-------------------------------------------------------------------------------------------------
workEthServer(ethServer);
//-------------------------------------------------------------------------------------------------
} //--END if(shed.frdm.num==4);
#endif




//================================================================================================= 
//                   2.5.Обработка секундных событий
//=================================================================================================
  if(shed.eventSec){                             //--Обработка секундных событий:
  vSpeedMCU=shed.cycle;                          //  кол-во циклов в сек;
  vSpeedMCUF=filterSpeed.filtered(vSpeedMCU);    //  кол-во циклов в сек с фильтром; 
  vSpeedSmall=round(((float)vSpeedMCUF)/1000);   //  кол-во циклов в сек с фильтром/1000;
  vMotorSec=shed.cntSec;                         //  кол-во секунд с начала работы программы;
  RT_HW_Base.unixID.timeUNIX++;                  //--Инкремент UNIX времени;
  RT_HW_Base.unixGetTimeDate();                  //--Получение времени и даты;
  RT_HW_Base.unixGetWeekDay();                   //--Получение дня недели;
} //--END if(shed.eventSec);
//================================================================================================= 
//                    2.10.1.Работа системными пинами
//=================================================================================================

//================================================================================================= 
//                    2.10.2.Системные устройства через пины
//================================================================================================= 
  if(shed.frdm.num==10) {setFlagStatus();}         //--Установка флагов состояния системных и других устройств; 
//if(shed.frdm.num==11) {snsDS1820();}             //--DS1820. При опросе задержка 4-6 ms; 
//if(shed.frdm.num==12) {snsDHT22();}              //--DHT22.  При опросе задержка 6 ms;   
//if(shed.frdm.num==13) {snsSR04();}               //--HC-SR04(по прерываниям); 
//================================================================================================= 
//                    2.10.3.Системные устройства через i2c
//================================================================================================= 
  if(shed.frdm.num==15){snsAHTxx();}              //--AHTxx;
//================================================================================================= 
//                    2.10.5.Системные устройства через SPI
//================================================================================================= 
//  if(shed.frdm.num==16){exp74HC595();}            //--Вывод на 74HC595;
  if(shed.frdm.num==16){expDotPLC();} 
//-------------------------------------------------------------------------------------------------
  if(shed.frdm.num==17){exp74HC165();}            //--Вывод на 74HC165;
  if(shed.frdm.num==18){expMCP4725();}            //--Вывод на MCP4725 (0x60); 
//================================================================================================= 
//                    2.12.Сенсоры через i2c дополнительные
//=================================================================================================
//if(shed.frdm.num==20){snsBMP180();}             //--BMP180;
//if(shed.frdm.num==21){snsBME280();}             //--BME280;
//if(shed.frdm.num==22){snsSHT3x();}              //--Sensor SHT3x;
//if(shed.frdm.num==23){snsHTU21();}              //--Sensor HTU21;
//if(shed.frdm.num==24){snsBH1750();}             //--Sensor BH1750
//================================================================================================= 
//                    2.13.Сенсоры через SPI дополнительные
//=================================================================================================
//if(shed.frdm.num==25){snsMAX6675();}            //--Sensor MAX6675;
//================================================================================================= 
//                    2.14.Расширители через i2c дополнительные
//=================================================================================================
//if(shed.frdm.num==26){expMCP23017();}           //--MCP23017(16-разрядный дискретный ввод-вывод);
//if(shed.frdm.num==27){expPCF8575();}            //--PCF8575 (16-разрядный дискретный ввод-вывод);
  if(shed.frdm.num==28){expADS1115();}            //--ADS1115 (16-разрядный ADC, 4 канала);
//================================================================================================= 
//                    2.15.Расширители через SPI дополнительные
//=================================================================================================
//if(shed.frdm.num==29){expDM13C();}              //--DM13C;
//=================================================================================================
//                   2.20.ДИСПЛЕИ
//=================================================================================================
  if(shed.frdm.num==40){Lcd1();}            //--Output Lcd1(16x2,i2c,0x27);
  if(shed.frdm.num==41){Lcd2();}            //--Output Lcd2(20x4,i2c,0x3E);
  if(shed.frdm.num==45){Lcd5_Nextion();}    //--Output Lcd5 Nextion(UART);
  if(shed.frdm.num==41){Lcd6();}            //--Output Lcd6(20x4,i2c,0x28);
//-------------------------------------------------------------------------------------------------
//#################################################################################################
//                       III. Переключение на ядро CORE 1 для  RP2040
//#################################################################################################
#if defined(RT_HW_PERMIT_CORE1)
} 
void loop1() {vcoreOk=1;                            //--Флаг подключения второго ядра;
#endif
//=================================================================================================   
  RT_HW_Base.sheduler(shed1);                       //--Диспетчер задач для CORE 1;
//================================================================================================= 
//                   2.1.Обработка секундных событий для CORE1
//=================================================================================================
  if(shed1.eventSec){                               //--Обработка секундных параметров:
  vspeedMCU=shed1.cycle;                            //--Кол-во циклов в сек;
  vspeedMCUF=filterSpeed.filtered(vspeedMCU);       //--Кол-во циклов в сек после фильтра; 
  vspeedSmall=round(((float)vspeedMCUF)/1000);      //--Кол-во циклов в сек после фильтра/1000;
}
//=================================================================================================
  if(shed1.back.num==1){if(vcoreOk){coreGenCnt();}} //--Тестовый счетчик(500ms) для CORE1 (считает только на ядре CORE1);
//-------------------------------------------------------------------------------------------------
}; //++++END loop() or loop1=======================================================================
