# -----------------------------------
# Raspberry Pi Pico
# -----------------------------------
rpipico.name=Raspberry Pi Pico
rpipico.build.board=RASPBERRY_PI_PICO
rpipico.build.mcu=cortex-m0plus
rpipico.build.variant=rpipico
rpipico.build.f_cpu=125000000
rpipico.build.core=rp2040
rpipico.build.mcu=rp2040
rpipico.build.ram_length=256k
rpipico.build.usb_manufacturer="Raspberry Pi"
rpipico.build.usb_product="Pico"

#pragma once

// Pin definitions taken from:
//    https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf


// LEDs
#define PIN_LED        (25u)

// Serial
#define PIN_SERIAL1_TX (0u)
#define PIN_SERIAL1_RX (1u)

#define PIN_SERIAL2_TX (8u)
#define PIN_SERIAL2_RX (9u)

// SPI
#define PIN_SPI0_MISO  (16u)
#define PIN_SPI0_MOSI  (19u)
#define PIN_SPI0_SCK   (18u)
#define PIN_SPI0_SS    (17u)

#define PIN_SPI1_MISO  (12u)
#define PIN_SPI1_MOSI  (15u)
#define PIN_SPI1_SCK   (14u)
#define PIN_SPI1_SS    (13u)

// Wire
#define PIN_WIRE0_SDA  (4u)
#define PIN_WIRE0_SCL  (5u)

#define PIN_WIRE1_SDA  (26u)
#define PIN_WIRE1_SCL  (27u)

#define SERIAL_HOWMANY (3u)
#define SPI_HOWMANY    (2u)
#define WIRE_HOWMANY   (2u)

#include "../generic/common.h"


# -----------------------------------
# Raspberry Pi Pico (Picoprobe)
# -----------------------------------
rpipicopicoprobe.name=Raspberry Pi Pico (Picoprobe)
rpipicopicoprobe.build.board=RASPBERRY_PI_PICO
rpipicopicoprobe.build.mcu=cortex-m0plus
rpipicopicoprobe.build.variant=rpipico
rpipicopicoprobe.upload.tool=picoprobe
rpipicopicoprobe.upload.maximum_size=2097152
rpipicopicoprobe.build.f_cpu=125000000
rpipicopicoprobe.build.core=rp2040
rpipicopicoprobe.build.mcu=rp2040
rpipicopicoprobe.build.ram_length=256k
rpipicopicoprobe.build.usb_manufacturer="Raspberry Pi"
rpipicopicoprobe.build.usb_product="Pico (Picoprobe)"


//============================================================================
Analog Input
------------
Устройство RP2040 имеет 4-канальный 12-битный АЦП + датчик температуры на пинах A0 ... A3.
Стандартные вызовы Arduino можно использовать для чтения их значений (с 3,3 В, номинальное значение - 4095).

int analogRead(pin_size_t pin = A0..A3)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Возвращает значение от 0 до 4095, соответствующее показанию АЦП соответствующего  пина.

float analogReadTemp()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Возвращает температуру встроенного термодатчика в градусах Цельсия.

Analog Outputs
--------------
RP2040 не имеет встроенных ЦАП, поэтому аналоговые выходы моделируется стандартным методом 
с использованием широтно-импульсной модуляции (PWM) с использованием аппаратных модулей PWM RP20400.
Хотя можно сгенерировать до 16 каналов ШИМ, они не являются независимыми.
и существуют значительные ограничения в отношении разрешенных параллельных выводов.
Подробную информацию см. В техническом описании RP2040 <https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf> `_.

void analogWriteFreq(uint32_t freq)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Устанавливает используемую главную частоту ШИМ (т.е. как часто циклы выходного сигнала ШИМ).
Поддерживаются от 100 Гц до 60 кГц. 

void analogWriteRange(uint32_t range) and analogWriteResolution(int res)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Эти вызовы устанавливают максимальное значение ШИМ (т.е. запись этого значения приведет к
рабочий цикл ШИМ 100%) / либо явно (range), либо как степень двойки (res). 
Поддерживается диапазон от 16 до 65535.

void analogWrite(pin_size_t pin, int val)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Записывает значение ШИМ на определенный вывод. 
ШИМ-вывод включена и настроен на установленные частоты и частота, и вывод будет выполнен. 
Это будет продолжайте до тех пор, пока не будет выполнен digitalWrite() или другой цифровой вывод. 

Board-Specific Pins
-------------------
Чип Raspberry Pi Pico RP2040 поддерживает до 30 цифровых контактов ввода / вывода,
однако не все платы обеспечивают доступ ко всем контактам. 

Tone/noTone
-----------
Генерация простого прямоугольного тона возможна для 8 каналов с использованием
стандартных тональных вызовов Arduino. 
Поскольку они используют PIO для генерации формы волны, они должны использовать ресурсы 
совместно с другими вызовами, такими как I2S или Servo объекты.

EEPROM Library
==============
Хотя Raspberry Pi Pico RP2040 не имеет встроенной EEPROM, она имитируйте один, используя один сектор 4K в конце Flash.
** Это смоделированная EEPROM и поддерживает только количество перезаписей во встроенный флеш-чип, 
а не как 100 000 или около того как в реальной EEPROM. **

EEPROM.begin (size= 256 ... 4096)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Вызывается перед первым использованием данных EEPROM для чтения или записи. 
Создаеь копию смоделированного сектора EEPROM в ОЗУ, чтобы обеспечить произвольное обновление и доступ.

EEPROM.read (адрес), EEPROM [адрес]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Возвращает данные по определенному смещению в EEPROM. См. EEPROM.get() для большего понимания.

EEPROM.write (адрес, данные), EEPROM [адрес] = данные
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Записывает байт данных по указанному смещению. Не продолжалось мигать до тех пор, пока
Вызывается EEPROM.commit ().

EEPROM.commit ()
~~~~~~~~~~~~~~~
Записывает обновленные данные во флеш-память, поэтому при следующей перезагрузке они будут доступны для чтения.

EEPROM.end ()
~~~~~~~~~~~~
EEPROM.commit () и освобождает всю используемую память. Необходимо вызвать `EEPROM.begin ()`
прежде, чем EEPROM можно будет снова использовать.

EEPROM.get (адрес, значение)
~~~~~~~~~~~~~~~~~~~~~
Копирует (потенциально многобайтовые) данные в EEPROM в определенный байт
смещение в возвращаемое значение. Полезно для чтения структур из EEPROM.

EEPROM.put (адрес, значение)
~~~~~~~~~~~~~~~~~~~~~
Копирует (потенциально многобайтовое) значение в EEPROM с байтовым смещением.
поставляется. Полезно для хранения структуры в EEPROM. Обратите внимание, что любые указатели
внутри письменной структуры не будет действительным, и что большинство объектов C ++
например, String не может быть записан в EEPROM таким образом из-за этого.

EEPROM.length ()
~~~~~~~~~~~~~~~
Возвращает длину EEPROM (т.е. значение, указанное в EEPROM.begin() ).

Примеры EEPROM
---------------
Включены три примера EEPROM <https://github.com/earlephilhower/arduino-pico/tree/master/libraries/EEPROM> `_. Biblioteka EEPROM
==============

Меню IDE
=========
Модель
-----
Используйте меню плат, чтобы выбрать вашу модель платы RP2040. Будет два варианты: Boardname и Boardname (Picoprobe).
Если вы хотите использовать Picoprobe для загрузки ваших эскизов, а не автоматическая загрузка UF2 по умолчанию,
используйте опцию (Picoprobe), в противном случае используйте обычное имя. 
Нет функционала или из-за этого делаются изменения кода.

Существует также доска «Generic», которая позволяет вам индивидуально выбирать
такие вещи, как размер флэш-памяти или тип флэш-памяти boot2. Используйте это, если ваша доска не
но полностью поддерживается и не работает с обычным `Raspberry Pi Pico` вариант.

Размер вспышки
----------
Arduino-Pico поддерживает встроенные файловые системы, что позволяет отказаться от некоторых
прошить на вашей плате для файловой системы, уменьшив максимальный размер кода
разрешается. Используйте это меню, чтобы выбрать желаемое соотношение файловой системы к эскизу.

Скорость процессора
---------
Хотя он не поддерживается, Raspberry Pi Pico RP2040 часто может много работать.
быстрее стоковой 125МГц. Используйте меню «CPU Speed», чтобы выбрать
желаемая скорость увеличения или уменьшения тактовой частоты. ** Если скетч терпит неудачу на более высоком
скорости, удерживайте BOOTSEL при подключении, чтобы войти в режим обновления, и попробуйте
меньший разгон. **

Порт отладки и уровень отладки
--------------------------
Сообщения отладки из `printf` и ядра могут быть напечатаны на последовательный порт
чтобы упростить отладку. Выберите желаемый порт и степень детализации.
Выбор порта для вывода отладки не останавливает его использование в скетче для нормальной работы.

Последовательные порты (USB и UART)
===========================
Ядро Arduino-Pico реализует программный порт Serial-over-USB.
Использование этой модели USB ACM-CDC поддержтвается широким спектром операционных системы.

Serial - это последовательный порт USB, а Serial.begin () позволяет указав скорость передачи данных, 
эта скорость игнорируется, поскольку она основана на USB.
(Также имейте в виду, что этот последовательный порт USB отвечает за сброс RP2040 во время процесса загрузки, 
в соответствии со стандартом Arduino 1200bps = сброс на загрузчик).

RP2040 предоставляет два аппаратных UARTS с настраиваемыми выбором пинов.
Serial1 - это UART0, а Serial2 - это UART1.
Пины настраиваются  с помощью вызовов setXXX перед вызовом begin().
        Serial1.setRX (пин);
        Serial1.setTX (пин);
        Serial1.begin (скорость);

Для получения подробной информации о последовательных портах см.
Arduino `Serial Reference <https://www.arduino.cc/reference/en/language/functions/communication/serial/>` 
===========================


USB (Arduino и Adafruit_TinyUSB)
==================================
В ядре присутствуют два стека USB. 
Пользователи могут выбрать более простой версии Pico-SDK или более мощный библиотека Adafruit TinyUSB.

Поддержка Pico SDK USB
--------------------
Это режим по умолчанию, автоматически включает для USB последовательный порт Serial, 
а также поддерживает автоматический сброс для загрузки из среды IDE.

Ядро Arduino-Pico включает в себя портированные версии базовой Arduino.
Библиотеки Keyboard и Mouse позволяют имитировать клавиатуру или мышь с помощью Pico в ваших скетчах.

См. Примеры и справочник по Arduino на
https://www.arduino.cc/reference/en/language/functions/usb/keyboard/
https://www.arduino.cc/reference/en/language/functions/usb/mouse

Поддержка Adafruit TinyUSB Arduino
--------------------------------
Примеры представлены в Adafruit_TinyUSB_Arduino для большего расширенный стек USB.

Чтобы использовать последовательный порт с TinyUSB, вы должны включить заголовок TinyUSB в свой
эскиз, чтобы избежать ошибки компиляции.
    #include <Adafruit_TinyUSB.h>

Если вам нужно быть совместимым с другой стек USB, вы можете использовать ifdef:
    #ifdef USE_TINYUSB
    #include <Adafruit_TinyUSB.h>
    #endif

Кроме того, этот стек требует, чтобы эскизы вызывались вручную Serial.begin (115200) 
для включения последовательного порта USB и автоматическоой загрузки скетча из IDE. 
Если скетч запускается без этой команды в "setup ()" пользователю нужно будет использовать стандартный "hold BOOTSEL"
для подключения USB ", чтобы войти в режим загрузки программы.

Pin Assignments
===============
Raspberry Pi Pico имеет невероятно гибкую конфигурацию ввода-вывода и большинство встроенных периферийные устройства (кроме АЦП) 
можно использовать на нескольких наборах пинов.
Однако не все периферийные устройства могут использовать все операции ввода-вывода. 
Более подробно в документации на RP2040 или онлайн-схеме распиновки.

Были добавлены дополнительные методы, позволяющие выбрать периферийное устройство.
Контакты ввода-вывода ** перед вызовом :: begin **. 
Это особенно полезно, при использования сторонних библиотек: библиотеку изменять не нужно,
для настройки распиновки нужен только ваш собственный код в setup ().

I2S
---
        ::setBCLK(pin)
        ::setDOUT(pin)

Serial1 (UART0), Serial2 (UART1)
--------------------------------
        ::setRX(pin)
        ::setTX(pin)

SPI (SPI0), SPI1 (SPI1)
-----------------------
        ::setSCK(pin)
        ::setCS(pin)
        ::setRX(pin)
        ::setTX(pin)

Wire (I2C0), Wire1 (I2C1)
-------------------------
        ::setSDA(pin)
        ::setSCL(pin)

Например, перед использованием SD библиотеки через SPI` библиотеку, можно определить пины library, we can make
        SPI.setRX(4);
        SPI.setTX(7);
        SPI.setSCK(6);
        SPI.setCS(5);
        SD.begin(5);


Using the Raspberry Pi Pico SDK (PICO-SDK)
==========================================
Included SDK
------------
Полная копия Raspberry Pi Pico SDK <https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf> `_
входит в состав ядра Arduino, и все функции ядра доступны внутри стандартных библиотек ссылок.
Для простых программ, желающих вызвать эти функции, просто включите
соответствующий заголовок, как показано ниже
------------
        #include "pico/stdlib.h"
        void setup() {
            const uint LED_PIN = 25;
            gpio_init(LED_PIN);
            gpio_set_dir(LED_PIN, GPIO_OUT);
            while (true) {
                gpio_put(LED_PIN, 1);
                sleep_ms(250);
                gpio_put(LED_PIN, 0);
                sleep_ms(250);
            }
        }
        void loop() {}
** Примечание. ** Когда вы вызываете функции SDK в собственном приложении, ядро и
библиотеки не знают о каких-либо изменениях в Pico, который вы выполняете. Так,
при этом вы можете нарушить функциональность некоторых библиотек.

Multicore (CORE1) Processing
----------------------------
** Предупреждение: ** Хотя вы можете запускать многоядерные приложения на CORE1
при использовании SDK ядро Arduino может неправильно работать с ними.
В частности, все, что связано с записью во флэш-память (например, EEPROM, файловые системы), 
вероятно будет не работать из-за попытки CORE1 читать из памяти, пока CORE0 пишет в неё.

PIOASM (Compiling for the PIO processors)
-----------------------------------------
Предварительно скомпилированная версия инструмента PIOASM включена в загрузку.
пакет и может быть запущен из интерфейса командной строки.

Существует также полностью онлайн-версия PIOASM, работающая в сети.
браузер без использования интерфейса командной строки, спасибо @ jake653: https://wokwi.com/tools/pioasm
(Источник GitHub: https://github.com/wokwi/pioasm-wasm)


Wire (ведущий и ведомый I2C)
===========================
RP2040 имеет два устройства i2c: i2c0 (Wire) и i2c1 (Wire1).
Контакты по умолчанию для Wire и Wire1 различаются в зависимости от того, какую плату вы используете.
Для Pi Pico <https://datasheets.raspberrypi.org/pico/Pico-R3-A4-Pinout.pdf> =i2c - _
и `Adafruit Feather <https://learn.adafruit.com/assets/100740>` _.)

Вы можете изменить эти контакты ** перед вызовом Wire.begin () или Wire1.begin () **, используя:
        bool setSDA (pin_size_t sda);
        bool setSCL (pin_size_t scl);

Обязательно используйте контакты с маркировкой i2c0 для шины i2cб и i2c1 для шины i2c1.
диаграмму для вашей платы, иначе она не сработает.

В остальном API совместим со стандартом Arduino. Поддерживаются как ведущие, так и ведомые операции.

Передачи мастера буферизуются (до 128 байт) и выполняются только на endTransmission, 
что является стандартом для современных реализаций Arduino Wire.

Более подробная информации в документации Arduino Wire <https://www.arduino.cc/en/reference/wire>

SPI (Serial Peripheral Interface)
=================================
RP2040 имеет два аппаратных интерфейса SPI: spi0 (SPI) и spi1 (SPI1).
Эти интерфейсы поддерживаются библиотекой SPI в ведущем режиме.
Распиновку SPI можно установить ** перед SPI.begin () **, используя следующие вызовы:
    bool setRX (pin_size_t pin);
    bool setCS (pin_size_t pin);
    bool setSCK (pin_size_t pin);
    bool setTX (pin_size_t pin);

Обратите внимание, что штифт CS может быть аппаратным или программным, управляемым эскизом.
При программном управлении вызов setCS () игнорируется.

Документация Arduino SPI <https://www.arduino.cc/en/reference/SPI> дает подробный обзор библиотеки, 
за исключением следующих специфичных для RP2040 изменения:

* SPI.begin (bool hwCS) может принимать параметр опций hwCS. 
  Передав значение true для hwCS, скетчу не нужно беспокоиться об утверждении и отключении вывода CS между транзакциями. 
  Значение по умолчанию - false, и требуется, чтобы скетч обрабатывал сам вывод CS, как это обычно делается в Arduino.
* Вызовы прерывания (usingInterrupt, notUsingInterrupt, attachInterrupt и detachInterrpt) не реализованы.

Servo Library
=============
Аппаратный сервоконтроллер предоставляется с использованием библиотеки Servo.
Он использует конечные автоматы PIO и генерирует управляющие импульсы без сбоев и дрожания (в пределах кристалла).
До 8 сервоприводов могут управляться параллельно, не предполагая никаких других задач требующих использования машины PIO.

См. Стандарт Arduino Серводокументация <https://www.arduino.cc/reference/en/libraries/servo/>
для получения подробных инструкций по использованию. Также имеется включенный пример sweep.

Multicore Processing
====================
Чип RP2040 имеет 2 ядра, которые могут работать независимо друг от друга, разделяя периферийные устройства и память друг с другом. 
Код Arduino обычно выполняется только на ядре 0, при этом 2-е ядро ​​простаивает в состоянии низкого энергопотребления.

Добавив в свой скетч функции setup1 () и loop1 (), вы можете сделать использование второго ядра. 
Все, что вызывается из setup1() или подпрограммы loop1 () будут выполняться на втором ядре.

setup() и setup1() будут вызываться одновременно, а loop() или loop1() будут запущены, 
как только завершится настройка ядра  setup () (т. е. не обязательно одновременно!).

См. Пример Multicore.ino в каталоге примеров rp2040.

ПРИОСТАНОВКА ЯДЕР {Pausing Cores}
-------------------
Иногда приложению необходимо приостановить работу другого ядра на кристалле 
(т.е. запись во флэш-память или требуется остановить обработку, пока происходит какое-либо другое событие).

void rp2040.idleOtherCore ()
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Отправляет сообщение для остановки другого ядра (т.е. при вызове из ядра 0 оно
приостанавливает ядро ​​1, и наоборот). Ожидает подтверждения от другого ядра перед возвращением.

На другом ядре будут отключены прерывания, и оно будет занято в ожидании
процедура на основе ОЗУ, поэтому можно получить доступ к флеш-памяти и другим периферийным устройствам.

** ПРИМЕЧАНИЕ ** Если вы слишком долго не используете ядро ​​0, порт USB может зависнуть.
Это связано с тем, что ядро ​​0 управляет USB и должно обслуживать IRQ в своевременно (чего не может быть на холостом ходу).

void rp2040.resumeOtherCore ()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Возобновляет обработку в другом ядре, где она была остановлена.

СВЯЗЬ МЕЖДУ ЯДРАМИ
-------------------
RP2040 предоставляет аппаратный FIFO для связи между ядрами, но он используется исключительно для вызовов 
ожидания / возобновления, описанных выше. 
Вместо этого, правильнее использовать следующие функции для доступа к программно управляемому, многоядерному безопасному FIFO:

void rp2040.fifo.push (uint32_t)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Передает значение другому ядру. Будет заблокирован, если FIFO заполнен.

bool rp2040.fifo.push_nb (uint32_t)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Передает значение другому ядру. Если FIFO заполнен, возвращает false.
сразу и не блокирует. Если отправка прошла успешно, возвращается true.

uint32_t rp2040.fifo.pop ()
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Считывает значение из FIFO этого ядра. Блокирует до тех пор, пока не станет доступен один.

bool rp2040.fifo.pop_nb (uint32_t * dest)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Считывает значение из FIFO этого ядра и помещает его в dest. Возвращает true в случае успеха или false в случае блокировки.

int rp2040.fifo.available ()
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Возвращает количество значений, доступных в FIFO этого ядра.

//=================================================================================================
//									Installation
//=================================================================================================
Ядро Arduino-Pico можно установить с помощью диспетчера плат Arduino IDE Boards Manager или используя git.
Если вы хотите просто писать программы для своей платы RP2040, установки Boards Manager будет достаточно, 
но если вы хотите попробовать последние предварительные версии и внесенные улучшения, вам понадобится git установка.

** Примечание для пользователей Windows **: пожалуйста, не используйте версию для  Windows приложение Arduino, 
потому что у него есть проблемы с обнаружением подключенного Pico.
Используйте "Windows ZIP" или простой исполняемый файл "Windows" (EXE) для загрузки прямо с https://arduino.cc
и разрешить установку любых драйверов устройств
В противном случае плата Pico может не быть обнаружена. 
Кроме того, если вы попытаетесь из бета-версии 2.0 Arduino, 
то установите версию 1.8 перед этим, чтобы обеспечить наличие необходимых драйверов устройств.

1. Откройте IDE Arduino и перейдите в File-> Preferences.
2. В появившемся диалоговом окне введите следующий URL-адрес в поле «Дополнительные URL-адреса диспетчера плат»: 
   https://github.com/earlephilhower/arduino-pico/releases/download/global/package_rp2040_index.json
3. Нажмите ОК, чтобы закрыть диалоговое окно.
4. Перейдите в Tools-> Boards-> Board Manager в IDE.
5. Введите «pico» в поле поиска и выберите «Добавить»:

Installing via GIT
------------------
Для установки через GIT (для последних и самых лучших версий):
        mkdir -p ~/Arduino/hardware/pico
        git clone https://github.com/earlephilhower/arduino-pico.git ~/Arduino/hardware/pico/rp2040
        cd ~/Arduino/hardware/pico/rp2040
        git submodule update --init
        cd pico-sdk
        git submodule update --init
        cd pico-extras
        git submodule update --init
        cd ../tools
        python3 ./get.py

Installing both Arduino and CMake
---------------------------------
Tom's Hardware представил очень хорошую рецензию на установку arduino-pico на как Windows, 
так и Linux, доступные на `Tom's Hardware <https://www.tomshardware.com/how-to/program-raspberry-pi-pico-with-arduino-ide>

Если вы будете следовать их пошаговым инструкциям, у вас также будет полностью функциональную систему.
Среда на основе CMake для создания приложений Pico, если вы перерастете Arduino экосистема.

Uploading Sketches
------------------
Чтобы загрузить свой первый скетч, вам нужно будет удерживать кнопку BOOTSEL нажатой при подключении Pico к компьютеру.
Затем нажмите кнопку загрузки, и скетч должен быть передан и запущен.

После первой загрузки в этом нет необходимости, поскольку ядро arduino-pico имеет поддержку автоматического сброса.
Выберите соответствующий последовательный порт, показанный в меню Arduino Tools-> Port-> Serial Port, 
один раз (этот параметр останется неизменным, и его не нужно менять для следующих загрузок). 
Этот выбор позволяет инструменту автоматического сброса определить правильное устройство для сброса.
Они нажимают кнопку загрузки, и ваш скетч должен быть загружен и запущен.

В некоторых случаях Pico сталкивается с жестким зависанием, и его порт USB не отвечает на запрос автоматического сброса. 
Если это произойдет, просто выполните начальную процедуру, удерживая нажатой кнопку BOOTSEL при подключении Pico, чтобы войти в загрузчик ROM.

Windows 7 Driver Notes
----------------------
Windows 10, Linux и Mac будут поддерживать последовательный порт USB Pico CDC / ACM автоматически. 
Однако Windows 7 может не включать нужный драйвер и поэтому нет обнаружения Pico для автоматической загрузки или последовательного монитора.

В Windows 7, если это произойдет, вы можете использовать Zadig <https://zadig.akeo.ie/> для установки соответствующего драйвера. 
Выберите USB-идентификатор 2E8A и используйте драйвер USB Serial (CDC).

Windows 7 Installation Problems
-------------------------------
При запуске антивируса MalwareBytes (или другого) сканер может заблокировать компилятор или другие исполняемые файлы инструментальной цепочки, что приведет к сбою установки или сборки.  
(Thanks to @Andy2No)

Симптомы включают:
* Доступ запрещен во время обновления в менеджере досок - влияет на файлы .exe, потому что MalwareBytes заблокировал их.
* Отказано в доступе во время компиляции к одному из файлов .exe - по той же причине.
* Невозможно удалить файлы .exe - они заблокированы MalwareBytes.

Возможен обходной путь, включающий настройку цепочки инструментов как «исключенный каталог» и переустановку.
1. В настройках MalwareBytes перейдите на вкладку «Исключения». Добавьте исключение для эквивалента этого пути к папке:
C: \ Users {ЗДЕСЬ ИМЯ_ПОЛЬЗОВАТЕЛЯ} \ AppData \ Local \ Arduino15 \ packages \ rp2040 \ tools \ pqt-gcc \ 1.1.0-a-81a1771
2. Перезагрузитесь, чтобы разблокировать файлы.
3. Снова выполните установку / обновление менеджера плат.
4. Установите тип платы, например, в Raspberry Pi Pico и убедитесь, что он компилируется.

Загрузка изображений файловой системы (Uploading Filesystem Images)
---------------------------
Встроенная флеш-файловая система для Pico, LittleFS, позволяет загружать образ файловой системы из каталога скетча для использования в скетче. 
Загрузите необходимый плагин из
* https://github.com/earlephilhower/arduino-pico-littlefs-plugin/releases

Для установки следуйте инструкциям в
* https://github.com/earlephilhower/arduino-pico-littlefs-plugin/blob/master/README.md

Для получения подробной информации об использовании, пожалуйста, проверьте документацию репо, доступную на
* https://arduino-pico.readthedocs.io/en/latest/fs.html 


Загрузка эскизов с помощью Picoprobe (Uploading Sketches with Picoprobe)
---------------------------------
Если вы создали Raspberry Pi Picoprobe, вы можете использовать OpenOCD для обработки загрузки скетчей и для отладки с помощью GDB.
В Windows локальный администратор должен иметь возможность автоматически получить доступ к порту Picoprobe, 
но в Linux udev необходимо сообщить об устройстве и разрешить доступ обычным пользователям.
Чтобы настроить доступ к Picoprobes на уровне пользователя в Ubuntu (и других операционных системах, использующих udev):
        echo 'SUBSYSTEMS == "usb", ATTRS {idVendor} == "2e8a", ATTRS {idProduct} == "0004", GROUP = "users", MODE = "0666"' | sudo tee -a /etc/udev/rules.d/98-PicoProbe.rules
        sudo udevadm control --reload

Первая строка создает файл с поставщиком USB и идентификатором Picoprobe и сообщает UDEV предоставить пользователям полный доступ к нему. 
Второй заставляет udev загрузить это новое правило. 
Обратите внимание, что вам нужно будет отключить и снова подключить ваше устройство в первый раз, когда вы создадите этот файл, 
чтобы позволить udev правильно создать узел устройства.
После того, как разрешения Picoprobe настроены правильно, выберите плату «Raspberry Pi Pico (Picoprobe)» в меню «Инструменты» и загрузите как обычно.


(Uploading Sketches with pico-debug)
----------------------------------
pico-debug отличается от Picoprobe тем, что pico-debug - это виртуальный модуль отладки, который работает параллельно на том же RP2040, 
на котором вы запускаете свой код; Итак, вам понадобится только одна плата RP2040 вместо двух. 
pico-debug также отличается от Picoprobe тем, что pico-debug основан на стандартах; 
 он использует протокол CMSIS-DAP, что означает, что даже программное обеспечение, не написанное специально для Raspberry Pi Pico, 
 может его поддерживать. pico-debug использует OpenOCD для обработки загрузки ваших скетчей, 
 а отладку можно выполнять с помощью отладчиков с поддержкой CMSIS-DAP, включая GDB.

В Windows и macOS любой пользователь должен иметь возможность автоматически получить доступ к pico-debug, 
но в Linux udev необходимо сообщить об устройстве и разрешить доступ обычным пользователям.

Чтобы настроить доступ на уровне пользователя ко всем адаптерам CMSIS-DAP в Ubuntu (и других ОС, использующих udev):
        echo 'ATTRS {product} == "* CMSIS-DAP *", MODE = "664", GROUP = "plugdev"' | sudo tee -a /etc/udev/rules.d/98-CMSIS-DAP.rules
        sudo udevadm control --reload

Первая строка создает файл, который распознает все адаптеры CMSIS-DAP и сообщает UDEV предоставить пользователям полный доступ к нему. 
Второй заставляет udev загрузить это новое правило. Обратите внимание, что вам нужно будет отключить и снова подключить ваше устройство в первый раз, когда вы создадите этот файл, чтобы позволить udev правильно создать узел устройства.

После того, как разрешения CMSIS-DAP настроены правильно, выберите доску «Raspberry Pi Pico (pico-debug)» в меню «Инструменты».
При первом подключении USB-порта к компьютеру вы должны скопировать pico-debug-gimmecache.uf2 в Pi Pico, 
чтобы загрузить pico-debug в ОЗУ; после этого загрузите как обычно.

Отладка с помощью Picoprobe / pico-debug, OpenOCD и GDB
-------------------------------------------------- ---
Установленные инструменты включают версию OpenOCD (в каталоге pqt-openocd) и GDB (в каталоге pqt-gcc). 
Их можно использовать для запуска GDB в интерактивном окне, как описано в руководствах по началу работы с Pico от Raspberry Pi Foundation. 
Для pico-debug замените аргументы OpenOCD raspberrypi-swd и picoprobe в «-f interface / raspberrypi-swd.cfg -f target / rp2040.cfg» 
или «-f interface / picoprobe.cfg -f target / rp2040.cfg. 
Соответственно в руководстве по началу работы с Pico с помощью -f board / pico-debug.cfg.

Если вы создали Raspberry Pi Picoprobe, вы можете использовать OpenOCD для обработки загрузки скетчей и для отладки с помощью GDB.
В Windows локальный администратор должен иметь возможность автоматически получить доступ к порту Picoprobe, 
но в Linux udev необходимо сообщить об устройстве и разрешить доступ обычным пользователям.

Чтобы настроить доступ к Picoprobes на уровне пользователя в Ubuntu (и других операционных системах, использующих udev):
        echo 'SUBSYSTEMS == "usb", ATTRS {idVendor} == "2e8a", ATTRS {idProduct} == "0004", GROUP = "users", MODE = "0666"' | sudo tee -a /etc/udev/rules.d/98-PicoProbe.rules
        sudo udevadm control --reload

Первая строка создает файл с поставщиком USB и идентификатором Picoprobe и сообщает UDEV предоставить пользователям полный доступ к нему. 
Второй заставляет udev загрузить это новое правило. Обратите внимание, что вам нужно будет отключить и снова подключить ваше устройство в первый раз, 
когда вы создадите этот файл, чтобы позволить udev правильно создать узел устройства.
После того, как разрешения Picoprobe настроены правильно, выберите плату «Raspberry Pi Pico (Picoprobe)» в меню «Инструменты» и загрузите как обычно.

Getting Help and Contributing
=============================
Это проект, поддерживаемый сообществом, и у него есть несколько способов получить помощь.
Публикация полной информации в вежливой и организованной форме - лучший результат отклик.

Для ошибок в ядре или для отправки исправлений используйте
Проблемы с GitHub <https://github.com/earlephilhower/arduino-pico/issues> или
Запросы на извлечение GitHub <https://github.com/earlephilhower/arduino-pico/pulls>

Для общих вопросов / обсуждений используйте либо обсуждения GitHub <https://github.com/earlephilhower/arduino-pico/discussions>
или в чате с gitter.im <https://gitter.im/arduino-pico/community>


//=================================================================================================
// Библиотеки, перенесенные / оптимизированные для RP2040 (Libraries Ported/Optimized for the RP2040)
//=================================================================================================
Большинство библиотек Arduino, которые работают на современных платах Arduino на базе 32-битных процессоров
будет нормально работать с Arduino-Pico.

Следующие библиотеки подверглись дополнительному портированию и оптимизации специально для RP2040, 
и вам следует подумать об их использовании вместо общие версии, доступные в Менеджере библиотек.
Most Arduino libraries that work on modern 32-bit CPU based Arduino boards
will run fine using Arduino-Pico.

* `Adafruit GFX Library <https://github.com/Bodmer/Adafruit-GFX-Library>`_ by @Bodmer, 2-20x faster than the standard version on the Pico
* `Adafruit ILI9341 Library <https://github.com/Bodmer/Adafruit_ILI9341>`_ again by @Bodmer
* `ESP8266Audio <https://github.com/earlephilhower/ESP8266Audio>`_ ported to use the included ``I2S`` library
