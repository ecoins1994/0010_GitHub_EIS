//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//            			СЕНСОР DS1820
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/*
Описание для FLProg(параметры времени запуска определяются самим блоком FLProg).
---------------------------------------------------------------------------------------------------
DS1820 - датчик температуры.
Поддерживается "горячее" подключение, ошибочные измерения отфильтровываются.
Основные параметры:
  1. Пользовательский номер пина[plug=OFF].
  2. Режим измерения - периодический, по переднему фронту eN 
                       или в каждом цикле[plug=OFF,default=периодический].
  3. Пользовательский период измерения[plug=OFF,default=2200ms].
  4. Период измерения [default=1000ms].
Входы:
  1. Номер пина [plug=ON].
  2. EN - разрешение работы блока [plug=OFF].
  3. eN - запуск измерения по переднему фронту [для режима измерения по переднему фронту].
Выходы:
  1. ok - флаг готовности устройства [plug=ON].
  2. T - температура (в градусах C).
  3. fresh - флаг готовности измерений(событие) [plug=OFF].
  4. cntOk - счетчик успешных измерений [plug=OFF].
  5. cntErr - счетчик успешных измерений [plug=OFF].
---------------------------------------------------------------------------------------------------
Рекомендации для FLProg: 
1.Использовать "Диспетчер задач". 
2.Блок устанавливать на плате, управляемой "Диспетчером задач" как "Свободная задача".
3.Если "Диспетчер задач" не используется, обеспечить регулярный вызов блока не реже периода измерения.
---------------------------------------------------------------------------------------------------
Блок  ds1820  измеряет температуру одного сенсора типа ds1820, подключенного через отдельный пин.
Примененный алгоритм работы позволяет минимизировать влияния на работу ds1820 аппаратных прерываний 
(например WiFi, быстрые счетчики и ультразвуковые сонары и т.п), помех, плохих контактов и т.п. 
Это достигается дроблением "длинных" инструкций от контроллера к сенсору на укороченные инструкции.
Укороченные инструкции отправляются  периодически с изменяемым периодом до получения достоверных ответов.

Алгоритм работы блока
1.По флагу run  начинается цикл измерения.
2.По при первом запуске или при смене номера пина проверяется допустимость номера выбранного пина.
3.При первом запуске или смене пина осуществляется поиск устройства на шине.
  При ошибочных транзакциях выполняются многократные до ds.maxRptAddr(default=5) повторы c изменяющимся периодом. 
  Если устройство не обнаружено, то повторный поиск возобновляется через 2сек.
  Если устройство обнаружено, то на следующих этапах транзакции поиска устройства пропускаются.
  Если достоверные результаты получить не удается, поиск устройства повторяется. 
  Из адреса выделяются  дополнительные параметры - тип сенсора  DS182S20 (устаревшая модель), 
    DS18B20(наиболее распостраненная модель),DS1822, разрядность измерения (9,10,11 или 12 бит).
4.Выполняется последовательность команд для измерения температуры. 
  При ошибочных транзакциях выполняются многократные до ds.maxRptData(default=10) повторы c изменяющимся периодом. 
  Если достоверные результаты получить не удается, фиксируется ошибка, сбрасывается флаг ok, 
  сбрасываеся значение температуры ds.vTemp до значения, опредленного при инициализации (default=0.47), 
  увеличивается счетчик ошибок ds.cntErr, устанавливается флаг ds.frеsh.
  Если температура измерена, устанавливаетс флаг ds.ok, сохраняется измеренное значение температуры ds.vTemp, увеличивается 
  счетчик успешных измерений ds.cntOk, устанавливается флаг ds.frеsh.
  Флаг ds.fresh может сбрасываться внешней функцией при передачи актуальных значений ds.ok, ds.vTemp. 
---------------------------------------------------------------------------------------------------  
ecoins@mail.ru 03.11.2022.      
---------------------------------------------------------------------------------------------------
*/
//-------------------------------------------------------------------------------------------------
//  ecoins (ecoins@mail.ru)  
//  22.10.2022: Begin version
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//-------------------------------------------------------------------------------------------------
#ifndef RT_HW_DS1820_h
#define RT_HW_DS1820_h
#define RT_HW_DS1820_VER 					12		//--Номер версии библиотеки;
#include "RT_HW_BASE.h"								//--Подключение базовой библиотеки;
//-------------------------------------------------------------------------------------------------
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//							Структура для DS1820
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
struct RT_HW_STRUCT_DS1820_ID{
uint8_t  custom=0;
uint8_t  extPin=255;    //--Новое значение пина (можно считать перед началом измерения);
uint8_t  pin=255;       //--Номер пина;
//-------------------------------------------------------------------------------------------------
//uint8_t  typeMdf=0;   //--Модификация сенсора: если addr[0]=0x10(DS18s20) =1(старая), иначе =0(новая).
uint8_t  modeSns=0;     //--Модель сенсора addr[0]: Не определена=0, DS18S20=0x10, DS18B20=0x22, DS1822=0x28;
uint8_t  modfSns=0;     //--Модификация сенсора: если addr[0]=0x10(DS18s20) =1(старая), иначе =0(новая).
uint8_t  power=1;       //--Питание сенсора: =0-паразитное питание; =1-активное питание;

uint8_t  depth=12;      //--Разрядность сенсора (9,10,11,12) (может меняться в EEPROM) 
                        //  Биты 6,5 data[4]: 00=9bit(93.75ms),01=10bit(187.5ms),10=11bit(375ms),12=12bit(750ms)[default];
//-------------------------------------------------------------------------------------------------
int16_t  raw;           //--Результаты измерения в кодах из сенсора;
float    vTemp=0.47;    //--Нормализованная температура(float);
//-------------------------------------------------------------------------------------------------
uint8_t  addr[8];       //--Буфер для адреса из сенсора ds1820;
uint8_t  crcAddr;       //--Контрольная сумма CRC8 адреса;
uint8_t  data[9];       //--Буфер для данных из сенсора ds1820;
uint8_t  crcData;       //--Контрольная сумма CRC8 данных;
//-------------------------------------------------------------------------------------------------
uint8_t  run=1;         //--Флаг для внешнего запуска измерений;
uint8_t  finish=0;      //--Флаг завершения измерения;
uint8_t  ok=0;          //--Флаг устойчивой работы(с учетом отброса ошибочных измерений);
uint8_t  fresh=1;       //--Флаги готовности достоверных измерений;
uint16_t cntOk=0;       //--Счетчик успешных измерений;
uint16_t agoCntOk=0;    //--Счетчик успешных измерений;
uint16_t cntErr=0;      //--Cчетчик ошибок;
uint16_t agoCntErr=0;   //--Cчетчик ошибок;
//-------------------------------------------------------------------------------------------------
uint8_t  codeErr=0;       //--Код последней ошибки;
uint8_t  agoCodeErr=0;
uint8_t  codeErrAddr;   //--Код последней ошибки чтения адреса;
uint8_t  codeErrData;   //--Код последней ошибки измерения данных;
//-------------------------------------------------------------------------------------------------
uint8_t  okAddr:1,okErrAddr:1,okData:1,okErrData:1,okErr:1,//--Флаги внутренних функций: готовности адреса addr[],данных data[],codeErr;
         idAddr:1;      //--Флаг адрес установлен; 
uint8_t  action:1,err:1;//--Флаги активности, выход add function;
//-------------------------------------------------------------------------------------------------
uint8_t  cntRptAddr=0;	//--Счетчик повторений успешных получения адреса;
uint8_t  agoCntRptAddr=0;
//-------------------------------------------------------------------------------------------------
uint8_t  cntRptData; 	//--Счетчик повторений успешных получения данных;
uint8_t  agoCntRptData;
//-------------------------------------------------------------------------------------------------
uint8_t  maxRptAddr=5;  //--Максимальное кол-во повторов для успешных запросов адреса;
uint8_t  maxRptData=10; //--Максимальное кол-во повторов для успешных запросов данных;
//-------------------------------------------------------------------------------------------------
uint8_t  dir=0;			//--Управление этапами управления main function;
uint8_t  agoDir=255;  	//--Управление этапами управления main function;
uint8_t  dirReturn;     	//--Номер шага для возврата       main function;
uint16_t dirSetBack;    	//--Задержка перед возвратом      main function;
//-------------------------------------------------------------------------------------------------
uint8_t  step=0;			//--Управление этапами управления add  function;
uint8_t  agoStep=255;
uint8_t  stepReturn;    	//--Номер шага для возврата       add  function;
uint16_t stepSetBack;   	//--Задержка перед возвратом      add  function;
//-------------------------------------------------------------------------------------------------
uint32_t timeDelay;      //--Рабочий параметр              add  function (timeDelay в timeDelayMs());
uint8_t  stepDelay=0;   //--Рабочий параметр              add  function (stepDelay в timeDelayMs());
//-------------------------------------------------------------------------------------------------
uint8_t  ix;            //--Рабочий индекс для использования в циклах;
uint8_t  bf8;           //--Рабочий буфер для использования в функциях; 
};


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                     КЛАСС УПРАВЛЕНИЯ DS1820
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class RT_HW_DS1820{
public:
//void xxx(){;};
//=================================================================================================
//                      0. Настройка параметров
//=================================================================================================
void setParam(RT_HW_STRUCT_DS1820_ID &id, uint8_t vPin=255)
{ 
if(id.custom==0)	//==Однократная настройка параметров;
 {
	id.extPin=vPin; id.dir=0; id.custom=1; //--Настройка номера пина;
 }	
};

//=================================================================================================
//                      1.Работа c ds1820 (основная функция)
//  1.Опрашивает одиночный сенсора (одно устройство на шине).
//  2.После определения адреса устройства, для сокращения цикла измерения опрашивается только данные.
//    Если при опросе данных выявляются ошибки, возобновляется определение адреса устройства.
//  3.При каждой ошибке сохраняется последнее значение, сбрасывается флаг ok, взводится флаг fresh.
//=================================================================================================
void direct(RT_HW_ONEWIRE &z, RT_HW_STRUCT_DS1820_ID &id){
//-------------------------------------------------------------------------------------------------
//                     1.1. Инициализация параметров и шины 1-Wire
//-------------------------------------------------------------------------------------------------
if(id.dir==0) 
{ 
 if(id.extPin==255){return;}				//--Проверка установку номера пина;
 id.bf8=1;									//--Установка флага ок;
 id.step=id.stepDelay=0; id.idAddr=0; id.codeErr=id.okAddr=id.okData=0; //--Инициализация параметров;            						
 if(id.bf8){if(!RT_HW_Base.checkPinPGM( RT_HW_PGM_PIN_DIN_ID, id.extPin)){id.codeErr=11; id.bf8=0;}} //--Проверка пина на дискретный ввод;
 if(id.bf8){if(!RT_HW_Base.checkPinPGM( RT_HW_PGM_PIN_DOT_ID, id.extPin)){id.codeErr=12; id.bf8=1;}} //--Проверка пина на дискретный вывод;  
 if(!id.bf8){id.dirSetBack=5000; id.dirReturn=0; id.dir=80; return;}   //--При ошибке возврат на полный повтор в dir=0 с  задержкой 5сек;                                                                                   //--Сохранение пина;
 id.pin=id.extPin;                     		//--Присвоение номера пина;
 z.begin(id.pin);                       	//--Инициализация шины 1-Wire;
 id.dir=10; 								//--Переход на следующий этап;  
}      
//-------------------------------------------------------------------------------------------------
//                     1.2. Ожидание внешней команды запуска
//-------------------------------------------------------------------------------------------------
if(id.dir==10)
{
 if(!id.run){return;}  						//--Ожидание внешней команды запуска;
 id.run=0;  id.finish=0;					//--Сброс флагов;  
 if(id.pin!=id.extPin){id.dir=0; return;} 	//--При изменение номера пина переход на начало;
 id.codeErr=0; id.okAddr=0; id.okData=0;    //--Сброс параметров; 
 id.step=0;    id.dir=11;        			//--Продолжение на следующий этап;
}    
//-------------------------------------------------------------------------------------------------
//                     1.3. Поиск адреса
//-------------------------------------------------------------------------------------------------
if(id.dir==11)
{
  if(id.idAddr){id.dir=12; return;}        	//--Если адрес уже установлен, то переход на следующий этап;
  search_addr(z,id);                      	//--Вызов функции Поиска адреса;
  if(id.action){return;}                 	//--Ожидание завершения функции;
//------------------------------Обработка ошибки поиска адреса-------------------------------------
  if(id.err)   
  {
	id.codeErr=id.codeErrAddr;    id.cntErr++;              //--Установка кода ошибки и увеличение счетчика Err;
	id.ok=0;     id.okErr=1;      id.fresh=1;               //--Сброс и установка флагов;
	id.idAddr=0; id.cntRptAddr=0; id.cntRptData=0;         	//--Очистка рабочих параметров;  
	id.dirSetBack=2000; id.dirReturn=100;id.dir=80; return;	//--Возврат на ожидание run с задержкой; 
  }
//------------------------------Успешная заершение получение адреса--------------------------------
  id.idAddr=1;                               				//--Установка флага получения адреса,   
  id.dirSetBack=10;    id.dirReturn=12; id.dir=80; return;	//--Продолжение на следующий этап  с задержкой;
//-------------------------------------------------------------------------------------------------  
}
//-------------------------------------------------------------------------------------------------
//                     1.4. Измерение температуры
//-------------------------------------------------------------------------------------------------
if(id.dir==12)
{  
  meter(z,id);                                                            	//--Вызов функции измерения температуры;
  if(id.action) {return;}                                                 	//--Ожидание завершения функции;
/*
  RT_HW_Base.consoleTest(String(F("12.Direct dir")),id.dir, ';');
  RT_HW_Base.consoleTest(String(F(" step")),        id.step,';');
  RT_HW_Base.consoleTestArr(String(F(" addr")),     id.addr,';','H',8);
  RT_HW_Base.consoleTestArr(String(F(" data")),     id.data,';','H',9);
  RT_HW_Base.consoleCR(); 
*/  
//------------------------------Обработка ошибки---------------------------------------------------
  if(id.err)
  {
	id.codeErr=id.codeErrAddr; id.cntErr++;               			 //--Установка кода ошибки и увеличение счетчика Err;
    id.ok=0; id.okErr=1;id.idAddr=0;id.cntRptAddr=0; id.cntRptData=0; id.fresh=1; //++ERR: сброс параметров, и установка флагов;  
	id.dirSetBack=2000; id.dirReturn=100; id.dir=80; return;		//--Возврат на ожидание run с задержкой; 
  }
//------------------------------Обработка успешного измерения--------------------------------------
  id.vTemp=((float)id.raw/16.0); id.cntOk++;                             //--Расчет температуры, увеличение счетчика;
                id.ok=1; id.okErr=0;                  id.fresh=1;        //--Установка и сброс флагов;
  id.step=0;     id.dirSetBack=500; id.dirReturn=100; id.dir=80; return; //--Возврат на ожидание run с задержкой; ;
//-------------------------------------------------------------------------------------------------
}
//-------------------------------------------------------------------------------------------------
//                     1.5. Задержка=dirSetback с возвратом на step=stepReturn
//-------------------------------------------------------------------------------------------------
if(id.dir==80){if(RT_HW_Base.timeDelayMs(id.timeDelay,id.stepDelay,id.dirSetBack)){id.dir=id.dirReturn;} return;}
//-------------------------------------------------------------------------------------------------
//                     1.6. Завершения цикла измерения
//-------------------------------------------------------------------------------------------------
if(id.dir==100){id.finish=1; id.dir=10; return;}
//-------------------------------------------------------------------------------------------------            
} //--END ds1820();

//=================================================================================================
//                      			2.Функция поиска адреса
//  Возвращает: action,err,codeErr,okAddr,addr[],cntRpt
//  1.Если ok: action=0, err=0; полученные адрес addr[], контрольную сумму crc_addr, 
//    тип дисплея(новый/старый) modefSns(0/1), ok_addr=1;
//  2.Иначе  : action=0, err=1; код ошибки codeErr;
//  3.В процесе работы: action=1, кол-во повторов cntRpt;
//    При  ошибочных транзакциях выполняются повторы до maxRptAddr(настраиваемый параметр) 
//                                                    с увеличивающимся временем между повторами;  
//=================================================================================================
void search_addr(RT_HW_ONEWIRE &z, RT_HW_STRUCT_DS1820_ID &id){
//-------------------------------------------------------------------------------------------------
//                     2.0. Инициализация параметров и шины 1-Wire
//-------------------------------------------------------------------------------------------------
if(id.step==0) 
{   
   id.err=0; id.action=1; id.codeErrAddr=0; id.cntRptAddr=0; id.modfSns=0;	//--Подготовка параметров; 
   id.step++; 																//--Продолжение на следующий этап без задержки;
}
//-------------------------------------------------------------------------------------------------
//                     2.1. Сброс шины 1-Wire
//-------------------------------------------------------------------------------------------------
if(id.step==1) 
{
  id.bf8=z.reset();    							//--Сброс шины (=1 получен ответ от устройств);             
//------------------------------Обработка отсутствия ответа от устройства--------------------------
  if(!id.bf8)
  {
	id.codeErrAddr=20;							//--Присвоение кода ошибки адреса; 
    if(++id.cntRptAddr>=id.maxRptAddr)			//--Если кол-во ошибок превышает максимальное значение
	    {id.action=0; id.err=1; id.step=0;}									//  выход по ошибке;  
    else{id.stepSetBack=212+(id.cntRptAddr*3); id.stepReturn=1; id.step=80;}//--Иначе возврат на сброс шины через динамическую задержку; 
    return;										//--Выход после обработки ошибки;
  }
//------------------------------Обработка при получении ответа от устройства-----------------------
  id.stepSetBack=11; id.stepReturn=2; id.step=80; return; //--Переход на следующий этап  с задержкой 11мс;  
//-------------------------------------------------------------------------------------------------
}
//-------------------------------------------------------------------------------------------------
//                     2.2. Поиск устройства на шине 1-Wire
//-------------------------------------------------------------------------------------------------
if(id.step==2) 
{
  id.bf8=z.search(id.addr);                     //--Поиск устройства (=1 успешный поиск);
//------------------------------Обработка отсутствия ответа от устройства--------------------------
  if(!id.bf8)									//--Обработка ошибки поиска устройства;
  {
	id.codeErrAddr=21;                         	//--Присвоение кода ошибки адреса; 
    if(++id.cntRptAddr>=id.maxRptAddr)			//--Если кол-во ошибок превышает максимальное значение
	     {id.action=0; id.err=1; id.step=0;}								//  	выход по ошибке; 
    else {id.stepSetBack=216+(id.cntRptAddr*11); id.stepReturn=2; id.step=80;} //--Иначе возврат на поиск через динамическую задержку;                 
    return;										//--Выход после обработки ошибки; 
  }  
//------------------------------Обработка при получении ответа от устройства-----------------------
  id.step++; 									//--Переход на следующий этап; 
//-------------------------------------------------------------------------------------------------
}
//-------------------------------------------------------------------------------------------------
//                     2.3. Обработка полученного адреса
//-------------------------------------------------------------------------------------------------
if(id.step==3)
{
  id.bf8=1; 									//--Установка флагов;
  id.crcAddr=z.crc8(id.addr,7);           		//--Расчет контрольной суммы CRC8;  
  if(id.crcAddr!=id.addr[7]){id.bf8=0;}         //--Сброс флагов при ошибке CRC8;
//------------------------------Обработка при ошибке CRC8 полученного адреса-----------------------
  if(!id.bf8)
  {	
	id.codeErrAddr=22;                          //--Присвоение кода ошибки адреса;
    if(++id.cntRptAddr>=id.maxRptAddr)			//--Если кол-во ошибок превышает максимальное значение
	    {id.action=0; id.err=1; id.step=0;}								//  	выход по ошибке; 
    else{id.stepSetBack=218+(id.cntRptAddr*17); id.stepReturn=1; id.step=80;} //--Иначе возврат на поиск через динамическую задержку;               
  }	
//------------------------------Обработка при совпадении CRC8 полученного адреса-------------------
  id.modeSns=id.addr[0];						//--Сохранение кода сенсора;
  if(id.modeSns==0x10){id.modfSns=1;} 			//--Старый тип сенсора(=1);
  else                {id.modfSns=0;} 			//--Новый  тип сенсора(=0);           
  id.okAddr=1; id.err=0; id.action=0; id.step=0;//--Установка/сброс параметров;
/*
  RT_HW_Base.consoleTest(String(F("Search_addr")),id.dir, ';');
  RT_HW_Base.consoleTest(String(F(" step")),        id.step,';');
  RT_HW_Base.consoleTestArr(String(F(" addr")),     id.addr,';','H',8);
  RT_HW_Base.consoleTest(String(F(" mode")),     id.modeSns,';','H');
  RT_HW_Base.consoleTest(String(F(" modf")),     id.modfSns,';','H');
  RT_HW_Base.consoleCR(); 
*/
  return;                                     	//--Успешный выход; 
}
//-------------------------------------------------------------------------------------------------
//                     2.80. Задержка=stepSetBack с возвратом на step=stepReturn
//-------------------------------------------------------------------------------------------------
if(id.step==80){if(RT_HW_Base.timeDelayMs(id.timeDelay,id.stepDelay,id.stepSetBack)){id.step=id.stepReturn;} return;} 
} //--END search_addr();

//=================================================================================================
//                      3.Функция измерения
//   При  ошибочных транзакциях выполняются повторы до maxRptAddr(настраиваемый параметр) 
//                                                    с увеличивающимся временем между повторами; 
//   Помимо CRC8 проверяется конфигурационный регистр - он должен быть не нулевым.  
//=================================================================================================
void meter(RT_HW_ONEWIRE &z, RT_HW_STRUCT_DS1820_ID &id){
//-------------------------------------------------------------------------------------------------
//                     3.0. Подготовка параметров
//-------------------------------------------------------------------------------------------------
if(id.step==0) 
{  
  id.err=0; id.action=1; id.cntRptData=0; 	//--Подготовка параметров;
  id.step++; return;  						//--Продолжение в следующий этап без задержки;     
}
//-------------------------------------------------------------------------------------------------
//                     3.1. Сброс шины 1-Wire
//-------------------------------------------------------------------------------------------------
if(id.step==1) 
{ 
  id.bf8=z.reset();                                                                            //--Сброс шины (=1 получен ответ от устройств); 
  if(id.bf8==0){id.codeErrData=30;                                                             //++ERR: присвоение кода ошибки; 
                if(++id.cntRptData>=id.maxRptData){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptData неудачных попыток; 
                id.stepSetBack=52+(3*id.cntRptData);   id.stepReturn=1;   id.step=80; return;}//++ERR: возврат на повтор с изменяемой задержкой;              
                id.stepSetBack=10;                     id.stepReturn=2;   id.step=80; return; //--Продолжение в следующий этап с задержкой;                                                  
}
//-------------------------------------------------------------------------------------------------
//                     3.2. Команды "Пропуск адреса","Преобразование температуры"
//-------------------------------------------------------------------------------------------------
if(id.step==2) 
{
  z.skip(); z.write(0x44,id.power);                                                           //--Команды 0xCC,0x44;
  id.stepSetBack=1000;                                 id.stepReturn=3;   id.step=80; return; //--Продолжение в следующий этап с задержкой 800мс;                
}
//-------------------------------------------------------------------------------------------------
//                     3.3. Сброс шины 1-Wire
//-------------------------------------------------------------------------------------------------
if(id.step==3) 
{
  id.bf8=z.reset();                                                                           //--Сброс шины 1-Wire;
  if(id.bf8==0){id.codeErrData=31;                                                            //++ERR: присвоение кода ошибки; 
                if(++id.cntRptData>=id.maxRptData){id.action=0; id.err=1; id.step=0;  return;}//++ERR: ВЫХОД после maxRptData неудачных попыток; 
                id.stepSetBack=57+(14*id.maxRptData);  id.stepReturn=3;   id.step=80; return;}//++ERR: возврат на повтор с изменяемой задержкой;
                id.stepSetBack=10;                     id.stepReturn=4;   id.step=80; return; //--Продолжение в следующий этап с задержкой;   
}
//-------------------------------------------------------------------------------------------------
//                     3.4. Команды "Пропуск адреса" и "Чтение памяти"
//-------------------------------------------------------------------------------------------------
if(id.step==4) 
{
  z.skip(); z.write(0xBE,id.power);                                                           //--Команды "Пропуск адреса" и "Чтение памяти";
  for(id.ix=0; id.ix<9; id.ix++){id.data[id.ix]=z.read();} id.okData=1;                       //--Последовательное чтение 9 байт;
                id.stepSetBack=10;                     id.stepReturn=5;   id.step=80; return; //--Продолжение в следующий этап с задержкой;
}
//-------------------------------------------------------------------------------------------------
//                     3.5. Обработка полученных данных
//-------------------------------------------------------------------------------------------------
if(id.step==5) 
{
  id.bf8=1;
  id.crcData=z.crc8(id.data,8);                                    	//--Расчет CRC8;
  if(id.data[4]==0)                     {id.bf8=0; id.codeErrData=32;}	//--Проверка регистра config [0,R1,R2,1,1,1,1,1];
  if(!id.bf8){if(id.crcData!=id.data[8]){id.bf8=0; id.codeErrData=33;}}  //--Установка ошибки по CRC8;
/*  
  RT_HW_Base.consoleTest(String(F("Data bf8")),id.bf8, ';');
  RT_HW_Base.consoleTestArr(String(F(" data")),  id.data,   ';','H',9);
  RT_HW_Base.consoleTest(String(F(" mode")),     id.modeSns,';','H');
  RT_HW_Base.consoleTest(String(F(" modf")),     id.modfSns,';','H');
  RT_HW_Base.consoleCR(); 
*/
//------------------------------------Обработка ошибки---------------------------------------------                                                
  if(!id.bf8)
  {   
	if(++id.cntRptData>=id.maxRptData)
		{id.action=0; id.err=1; id.step=0;} 								 //--Выход после max неудачных попыток получения данных;  
    else{id.stepSetBack=63+(17*id.cntRptData); id.stepReturn=3; id.step=80;} //--Расчет динамической задержки для повторной попытки; 
    return;	//--Выход;
  } 
//------------------------------Формирование температуры data[0,1,4,6,7]---------------------------              
  id.depth=12;                                                                      		  //--Предварительная установка разрядности измерения;
  id.raw=(id.data[1] << 8) | id.data[0];                                                      //--Обработка первых 2-х байт;
  if(id.modfSns){id.raw=id.raw<<3;if(id.data[7]==0x10){id.raw=(id.raw&0xFFF0)+12-id.data[6];}}//--Расчет для старого сенсора (DS18S20); 
  else          {id.bf8=id.data[4] & 0x60;                                                    //--Расчет для новых сенсоров;
                      if(id.bf8==0x00){id.raw = id.raw & ~7; id.depth=9;}                     //    9 bit res, 93.75 ms;
                 else if(id.bf8==0x20){id.raw = id.raw & ~3; id.depth=10;}                    //   10 bit res, 187.5 ms;
                 else if(id.bf8==0x40){id.raw = id.raw & ~1; id.depth=11;}}                   //   11 bit res, 375   ms; default is 12 bit res, 750 ms; 
//------------------------------Контроль выхода за дипазон целоцисленных значений------------------
  id.bf8=1;
  if((id.raw>2000) || (id.raw<(-640))){id.bf8=0;}                                             //--Контроль диапазона температуры (-40 - +125гр.С)
  if(!id.bf8)
  {
    if(++id.cntRptData>id.maxRptData)
	    {id.codeErrData=34; id.action=0; id.err=1; id.step=0;}            					  //--Выход после max неудачных попыток получения данных;  
    else{id.stepSetBack=72+(21*id.cntRptData); id.stepReturn=1; id.step=80;} //--Расчет динамической задержки для повторной попытки; 
    return;	//--Выход; 
  }
//-------------------------------------------------------------------------------------------------  
  id.codeErr=id.codeErrData=0;
  id.step=0; id.err=0; id.action=0; return; //--Успешный выход;
}                                                   
//-------------------------------------------------------------------------------------------------
//                     1.1. Задержка с возвратом на указанный step
//-------------------------------------------------------------------------------------------------
//=================Задержка=stepSetBack с возвратом на step=stepReturn=============================
if(id.step==80){if(RT_HW_Base.timeDelayMs(id.timeDelay,id.stepDelay,id.stepSetBack)){id.step=id.stepReturn;} return;} 
}  //--END measurement();

//=================================================================================================


//=================================================================================================
//                              4.1.Вывод результатов измерений
//=================================================================================================
void messDS1820(RT_HW_STRUCT_DS1820_ID &id, uint8_t cmnd=0){  
if(!id.fresh) {return;}; id.fresh=0;   
//--------------------------------------------------------------------------------------------------
if(cmnd>=1){
RT_HW_Base.consoleTest(String(F("Chip code")),id.modeSns,',','H'); 
RT_HW_Base.consoleTest(String(F(" mode")),    id.modeSns,';','H'); 
id.bf8=1;					  
RT_HW_Base.consoleVar(String(F(" name: ")));
if(id.bf8){if(id.modeSns==0x10){id.bf8=0; RT_HW_Base.consoleVar(String(F("DS18S20")));}}
if(id.bf8){if(id.modeSns==0x28){id.bf8=0; RT_HW_Base.consoleVar(String(F("DS18B20")));}}
if(id.bf8){if(id.modeSns==0x22){id.bf8=0; RT_HW_Base.consoleVar(String(F("DS1822")));}}
if(id.bf8){                     id.bf8=0; RT_HW_Base.consoleVar(String(F("ANON")));}
}
//--------------------------------------------------------------------------------------------------
if(cmnd>=2){
RT_HW_Base.consoleTest(String(F(" bit")),id.depth,' ');}
//-------------------------------------------------------------------------------------------------- 
if(id.ok){RT_HW_Base.consoleChar('+');} else {RT_HW_Base.consoleChar('-');} 
RT_HW_Base.consoleVar(String(F("Temp=")));    RT_HW_Base.consoleVar(id.vTemp,';'); //--Вывод температуры; 
RT_HW_Base.consoleVar(String(F(" CntOk=")));  RT_HW_Base.consoleVar(id.cntOk,   ';',0,'U');
//--------------------------------------------------------------------------------------------------
if(cmnd>=3){
if(id.codeErrData){
RT_HW_Base.consoleVar(String(F(" codeErrData="))); RT_HW_Base.consoleVar(id.codeErrData,';');}}
//--------------------------------------------------------------------------------------------------
if(id.cntErr>0){
RT_HW_Base.consoleVar(String(F(" CntErr=")));      RT_HW_Base.consoleVar(id.cntErr,  ';',0,'U');}
RT_HW_Base.consoleCR();
}
/*
//=================================================================================================
//                              4.2.Вывод массива с адресом
//=================================================================================================
void messAddr(RT_HW_STRUCT_DS1820_ID &id){  
if(!id.okAddr){return;}
  id.okAddr=0;
  id.bf8=id.addr[0]; 							//-Cохранение модели сенсора;
  RT_HW_Base.consoleVar(String(F("Addr->ds1820="))); RT_HW_Base.consoleArr(id.addr, ';',0,'H',8); 
  RT_HW_Base.consoleVar(String(F(" CRC8=")));        RT_HW_Base.consoleVar(id.crcAddr,';',0,'H');
  RT_HW_Base.consoleVar(String(F(" mode=")));        RT_HW_Base.consoleVar((uint8_t)id.modfSns,';');
  if(id.codeErrAddr)
  {
   RT_HW_Base.consoleVar(String(F(" codeErrAddr="))); RT_HW_Base.consoleVar(id.codeErrAddr,';');
   RT_HW_Base.consoleVar(String(F(" cntRptAddr=")));  RT_HW_Base.consoleVar(id.cntRptAddr,';');
  }
  RT_HW_Base.consoleCR();                      	//--Перевод строки;
  RT_HW_Base.consoleLine('-',80);              	//--Вывод линии;
};
//=================================================================================================
//                              4.2x.Вывод массива с адресом
//=================================================================================================
void messAddrDebug(RT_HW_STRUCT_DS1820_ID &id){  
  id.bf8=id.addr[0]; 							//-Cохранение модели сенсора;
  RT_HW_Base.consoleVar(String(F("Addr->ds1820="))); RT_HW_Base.consoleArr(id.addr, ';',0,'H',8); 
  RT_HW_Base.consoleVar(String(F(" CRC8=")));        RT_HW_Base.consoleVar(id.crcAddr,';',0,'H');
  RT_HW_Base.consoleVar(String(F(" mode=")));        RT_HW_Base.consoleVar((uint8_t)id.modfSns,';');
  if(id.codeErrAddr)
  {
   RT_HW_Base.consoleVar(String(F(" codeErrAddr="))); RT_HW_Base.consoleVar(id.codeErrAddr,';');
   RT_HW_Base.consoleVar(String(F(" cntRptAddr=")));  RT_HW_Base.consoleVar(id.cntRptAddr,';');
  }
  RT_HW_Base.consoleCR();                      	//--Перевод строки;
};

//=================================================================================================
//                              4.3.Вывод массива с данными
//=================================================================================================
void messData(RT_HW_STRUCT_DS1820_ID &id){  
if(id.okData){id.okData=0;
RT_HW_Base.consoleVar(String(F("Data=")));  	   RT_HW_Base.consoleArr(id.data,';',0,'H',9);
RT_HW_Base.consoleVar(String(F(" CRC8="))); 	   RT_HW_Base.consoleVar(id.crcData,';',0,'H');
if(id.codeErrData){
RT_HW_Base.consoleVar(String(F(" codeErrData="))); RT_HW_Base.consoleVar(id.codeErrData,';');
RT_HW_Base.consoleVar(String(F(" cntRptData=")));  RT_HW_Base.consoleVar(id.cntRptData,';');
}
RT_HW_Base.consoleCR(); 
}}
//=================================================================================================
//                              4.4.Вывод ошибок
//=================================================================================================
void messErr(RT_HW_STRUCT_DS1820_ID &id){
if((id.agoCodeErr!=id.codeErr) || (id.agoCntRptAddr!=id.cntRptAddr) || (id.agoCntRptData!=id.cntRptData)){   
id.agoCodeErr=id.codeErr; 
id.agoCntRptAddr=id.cntRptAddr; 
id.agoCntRptData=id.cntRptData;
RT_HW_Base.consoleTest(String(F("ERR: err")),   id.codeErr,    ';');
RT_HW_Base.consoleTest(String(F(" errAddr")),  	id.codeErrAddr,',');
RT_HW_Base.consoleTest(String(F(" cntRptAddr")),id.cntRptAddr, ';');
RT_HW_Base.consoleTest(String(F(" errData")),  	id.codeErrData,',');
RT_HW_Base.consoleTest(String(F(" cntRptData")),id.cntRptData, ';');
RT_HW_Base.consoleTest(String(F(" mode")),		id.addr[0],    ';','H');
RT_HW_Base.consoleTestArr(String(F(" data[8]")),id.data,       ':','H',9);
RT_HW_Base.consoleTest(String(F(" CRC")),		id.crcData,    ';','H');
RT_HW_Base.consoleCR();
}}
//=================================================================================================
//                              4.5.Вывод этапов работы
//=================================================================================================
void messDebugDir(RT_HW_STRUCT_DS1820_ID &id,uint8_t cmd=1){
id.bf8=0;
if(cmd>0){if(id.agoDir!=id.dir)  {id.bf8=1;}}
if(cmd>1){if(id.agoStep!=id.step){id.bf8=1;}}
if(!id.bf8){return;}
id.agoDir=id.dir; id.agoStep=id.step;
RT_HW_Base.consoleTest(String(F(" dir")),         id.dir,';');
RT_HW_Base.consoleTest(String(F(" step")),        id.step,';');
RT_HW_Base.consoleTest(String(F(" stepReturn")),  id.stepReturn,';');
RT_HW_Base.consoleTest(String(F(" stepSetBack")), id.stepSetBack,';');
RT_HW_Base.consoleCR(); 
};
*/

//=================================================================================================
};	//--END class RT_HW_DS1820
//=================================================================================================
extern RT_HW_DS1820 	RT_HW_ds1820; 				//--Создание объекта RT_HW_SR04;
//=================================================================================================
#endif
//=================================================================================================