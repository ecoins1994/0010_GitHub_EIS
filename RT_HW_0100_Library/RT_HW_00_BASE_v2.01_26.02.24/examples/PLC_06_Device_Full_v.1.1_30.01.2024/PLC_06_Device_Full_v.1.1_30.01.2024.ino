//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                                 Тест платы №06 ver.1.1 30.01.2024  
//                              ТЕСТИРОВАНИЕ УСТРОЙСТВ С ВЫВОДОМ НА ДИСПЛЕИ Lcd
//                            (совместим с визуальной системой программирования FLProg)
//    1.1.Инициализация параметров в т.ч. тестовые пины, которые могут быть изменены.
//    1.2.В каждом цикле loop() вызывается "Диспетчер задач" и выполняется дискретный вывод на пины:
//            control - изменяется 0/1 в каждом цикле loop() для лог.анализатора),
//            Led на плате - меандр 500ms;
//    1.3.Инициализируется консоль (в терминах Arduino IDE - монитор порта). 
//        После готовности консоли (проверка консоли особо критична для контроллеров с USB на кристалле - STM32,Raspberry Pi,ESP32-C3,S2,S3),
//        в монитор порта однократно выводится отчет о проекте (пины, наличие коммуникаций и др.),
//        сканируется шина i2c (SDA,SCL необходимо подтянуть к Vcc резисторами 10-47к).
//    1.4.Каждую секунду обрабатываются секундные параметры - быстродействие проекта, время наработки).
//    2.1.Выполняется чтение пина "Кнопка"(период 50ms) с защитой от дребезга 50ms.
//    2.2.Выполняется чтение пина   ADC   (период 50ms) с фильтром медианным 5-го порядка;
//    2.3.Выполняется запись на пин PWM значение ADC;
//    3.1.Сенсоры через пины: DS1820,HC-SR04;
//    3.2.Сенсоры через i2c: AHTxx(T,H),SHT3x(T,H),BH1750,BMPx80(Press);
//    3.3.Сенсоры через SPI: MAX6675(T);
//    4.1.Расширители через i2c: MCP4725(DAC),ADS1115(ADC);
//    4.2.Расширители через SPI: 74HC595 "Бегущая 1", 74HC165(ввод со входов с подтянутыми через 10к к Vcc);    
//    5.1.Вывод на Lcd1.i2c 16x2(0x27):
//          Кнопка=0:  строка 1:Blink(*),ADC,74HC165(HEX.2), быстродействие CORE0/1000, флаг CORE1(+), быстродействие CORE1/1000;
//                     строка 2:AHTxx.ok,AHTxx.Temp,AHTxx.Hum;  
//          Кнопка=1:  строка 1:Blink(#),DS1820.ok,DS1280.Temp,HC-SR04.ok,HC-SR04.Len;
//                     строка 2:SHT3x.ok,SHT3x.Temp,SHT3x.Hum;  
//    5.2.Вывод на Lcd2.i2c 20x4 (0x3E):
//    5.3.Вывод на Lcd3.i2c 20x4 (0x26):
//    5.4.Панель Nextion;  
//=================================================================================================
//    Подключение к выполнению различных устройств выполняется через снятие символов комментариев(//) 
//    с соответствующего макроса.
//-------------------------------------------------------------------------------------------------
// ecoins@mail.ru 27.01.2024
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    0.Секция DECLARE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                          1.Разрешения использования пинов и устройств
//================================================================================================= 
  #define RT_HW_TEST_PERMIT_AHTx            //--i2c.Разрешение использования сенсора     AHTx; 
  #define RT_HW_TEST_PERMIT_SHT3x           //--i2c.Разрешение использования сенсора     SHT3x;
  #define RT_HW_TEST_PERMIT_BH1750          //--i2c.Разрешение использования сенсора     BH1750;
  #define RT_HW_TEST_PERMIT_BMP180          //--i2c.Разрешение использования сенсора     BMP180;
//#define RT_HW_TEST_PERMIT_BME280          //--i2c.Разрешение использования сенсора     BME280;    
  #define RT_HW_TEST_PERMIT_MCP4725         //--i2c.Разрешение использования расширителя MCP4725;
  #define RT_HW_TEST_PERMIT_ADS1115         //--i2c.Разрешение использования расширителя ADS1115;    
  #define RT_HW_TEST_PERMIT_LCD1            //--i2c.Разрешение использования дисплея Lcd1;
  #define RT_HW_TEST_PERMIT_LCD2            //--i2c.Разрешение использования дисплея Lcd2;
  #define RT_HW_TEST_PERMIT_LCD3            //--i2c.Разрешение использования дисплея Lcd3;
  #define RT_HW_TEST_PERMIT_NEXTION         //--UART.Разрешение использования панели Nextion; 
  #define RT_HW_TEST_PERMIT_PLC_DOT         //--pin.Вывод на 12 дискретных выходов: pinx4 + 74HC595; 
  #define RT_HW_TEST_PERMIT_PLC_DIN         //--pin.Ввод   c 12 дискретных входов:  pinx4 + 74HC165;  
//-------------------------------------------------------------------------------------------------
  #define RT_HW_TEST_PERMIT_ETHERNET        //--Разрешение тестов работы с Ethernet;
  #define RT_HW_TEST_PERMIT_ETHERNET_NTP    //--Разрешение тестов работы c NTP-cерверами(серверы точного времени);
  #define RT_HW_TEST_PERMIT_ETHERNET_SERVER //--Разрешение тестов работы c cервером;
  #define RT_HW_TEST_PERMIT_MB_MASTER_RTU   //--Разрешение использования MasterRTU;
  #define RT_HW_TEST_PERMIT_MB_SLAVE_RTU    //--Разрешение использования SlaveRTU;  
//=================================================================================================
//                                  2.Подключение библиотек
//=================================================================================================
  #include "flprogModbusRTU.h"          //--Подключение библиотеки ModBus RTU (Включает #include RT_HW_BASE.h");  
  #include "RT_HW_BASE.h"               //--Подключение базовой библиотеки;
  #include "RT_HW_LCD44780.h"           //--Подключение библиотеки дисплеев типа HD44780;
  #include "RT_HW_SENSORS.h"            //--Подключение библиотек базовых сенсоров    (DS1820, HC-SR04,AHTx,   SHT3x,  BH1750,  BME/BMP,etc);
  #include "RT_HW_EXPANDERS.h"          //--Подключение библиотек базовых расширителей(MCP4725,ADS1115,74HC595,74HC165,MCP23x17,PCF8575,etc);
  #include "RT_HW_NEXT.h"               //--Подключение библиотеки панелей типа Nextion; 
//=================================================================================================
//                                  3.Объекты и параметры,функции 
//=================================================================================================
RT_HW_FILTER_RING_AVERAGE<uint32_t,5> FilterSpeed0; uint32_t vSpeedMCUF0;  uint16_t vspeedMCUF0;    //--Фильтр, быстродействие, быстродействие/1000 CORE 0;
RT_HW_FILTER_RING_AVERAGE<uint32_t,5> FilterSpeed1; uint32_t vSpeedMCUF1;  uint16_t vspeedMCUF1;    //--Фильтр, быстродействие, быстродействие/1000 CORE 1;
uint32_t  flagSystem=0, flagDevice=0;                                         //--Флаги системные и устройств;
int16_t counter = -10;                //--Тестовый счетчик;
//-------------------------------------------------------------------------------------------------
//                    Параметры PLC RP2040 v.5.5
//-------------------------------------------------------------------------------------------------
  RT_HW_PIN_DIR_ID    idDotPLC[4];  uint8_t pinDotPLC[4]={2,3,22,28};   uint16_t plcDOT_vr=0; uint8_t cs595PLC=17; //--12 дискретных выходов;
  RT_HW_PIN_DIR_ID    idDinPLC[4];  uint8_t pinDinPLC[4]={10,11,23,29}; uint16_t plcDIN_vr=0; uint8_t cs165PLC=20; //--12 дискретных входов;  
  uint16_t pinDOT=0,pinDIN=0;
  uint8_t  plcIdx;                            //--Рабочий индекс;
  IPAddress ethIP{0,0,0,0};                   //--IP адрес Ethernet;
  uint8_t   ethServerCnt=0;                   //--Кол-во соединений с WEB-сервером;
//-------------------------------------------------------------------------------------------------
//                                   Параметры UART для Modbus Master RTU 
//-------------------------------------------------------------------------------------------------
uint8_t uartModbusMaster=255; 
uint8_t uartModbusSlave=255;   
uint8_t  MbMasterRTU1_numUART=1;      //--Номер UART Master;
uint8_t  MbSlaveRTU1_numUART=2;       //--Номер UART     Modbus Slave RTU1; 
uint16_t rg0=0,rg1=0,rg2=0,rg3=0,rg4=0,rg5=0,rg6=0,rg7=0;
uint16_t wg0=0,wg1=0,wg2=0,wg3=0,wg4=0,wg5=0,wg6=0,wg7=0;
//-------------------------------------------------------------------------------------------------
#if defined(RT_HW_TEST_PERMIT_MB_MASTER_RTU)
  ModbusMasterRTU   MasterRTU1(1, 2);   //--Создание Master: номер UART=1; кол-во Slave=2 (Slave 0,1);
  uint8_t  MbMasterRTU1_custom=0;       //--Флаг настройки Modbus Slave RTU1;
  int tempInt;
  bool tempBool;
  int value, oldValue;
  unsigned long startTime; 
#endif
//-------------------------------------------------------------------------------------------------
//                                   Параметры UART для Modbus Slave RTU 
//-------------------------------------------------------------------------------------------------
#if defined(RT_HW_TEST_PERMIT_MB_SLAVE_RTU)
  ModbusSlaveRTU   SlaveRTU1(1);        //--Создание объекта Мodbus Slave на UART=1;
  int      MbSlaveRTU1_DI_Adr[]={8,9,10,11,12,14,15,16,17,18}; //--Таблица доступных адресов для 10-ти регистров;  
  uint8_t  MbSlaveRTU1_ID=1;            //--ID(адрес)      Modbus Slave RTU1;
  uint8_t  MbSlaveRTU1_custom=0;        //--Флаг настройки Modbus Slave RTU1;
  int16_t saveInt16=-23567;             //--Рабочая переменная int16_t;
  int32_t saveInt32=123456;             //--Рабочая переменная int32_t;
  float   saveFloat1=12.5;              //--Рабочая переменная float; 
  float   saveFloat2=23.4;              //--Рабочая переменная float;
  bool    saveBlink=0;                  //--Рабочая переменная bool;
#endif
//-------------------------------------------------------------------------------------------------
int16_t  lastError;
//=================================================================================================
//                                   1.10.Параметры UART для моста WiFi
//=================================================================================================
uint8_t uartWiFi=255;

//-------------------------------------------------------------------------------------------------
uint8_t cnsCnt=0, cnsADC=0, first=0, vAgoButton=0;                            //--Рабочие параметры;
//-------------------------------------------------------------------------------------------------
uint8_t i2cAdrAHTxx=0x38;     uint8_t  vAHTxx_ok;   float    vAHTxx_Temp, vAHTxx_Hum; //--i2c.Сенсор AHTxx;
uint8_t i2cAdrSHT3x=0x44;     uint8_t  vSHT3x_ok;   float    vSHT3x_Temp, vSHT3x_Hum; //--i2c.Сенсор SHT3x; 
uint8_t i2cAdrBME280=0x77;    uint8_t  vBMPx80_ok;  float    vBMPx80_Press;           //--i2c.Сенсор BMEx80/BMPx80;
uint8_t i2cAdrBMP180=0x77;                                                            //--i2c.Сенсор BMP180;
uint8_t i2cAdrBH1750=0x23;    uint8_t  vBH1750_ok;  uint16_t vBH1750_Lux;             //--i2c.Сенсор BH1750;
uint8_t i2cAdrMCP4725=0x60;   uint8_t  vMCP4725_ok; uint16_t vMCP4725_vr;             //--i2c.Расширитель DAC;
uint8_t i2cAdrADS1115=0x48;   uint8_t  vADS1115_ok; float    vADS1115_A0f,            //--i2c.Расширитель ADC
                                       vADS1115_A1f,vADS1115_A2f,vADS1115_A3f;        //                  ADS1115;
uint8_t i2cAdrLcd1=0x27;                                                              //--i2c.Дисплей Lcd1 HD44780 (16x2);
uint8_t i2cAdrLcd2=0x3E;                                                              //--i2c.Дисплей Lcd2 HD44780 (20x4);
uint8_t i2cAdrLcd3=0x26;                                                              //--i2c.Дисплей Lcd3 HD44780 (20x4);
uint8_t uartNextion=255;     uint8_t nxtPage=0; uint8_t nxtVr1,nxtVr2,nxtVr3,nxtVr4;  //--UART.Панель Nextion;


//-------------------------------------------------------------------------------------------------
void consoleHead();   //--Предопределение функции;
//=================================================================================================
//                            4.Подключение внутренних вкладок
//=================================================================================================
  #include "Device.hpp"                 //--Пины,cенсоры,расширители; 
  #include "Lcd1.hpp"                   //--Дисплей Lcd1(i2c) 16x4;       
  #include "Lcd2.hpp"                   //--Дисплей Lcd2(i2c) 20x4;
  #include "Lcd3.hpp"                   //--Дисплей Lcd3(i2c) 20x4;
  #include "Nextion.hpp"                //--Панель Nextion;    
  #include "Tethernet.hpp"              //--Ethernet;  
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    I.Секция SETUP()
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void setup(){}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    II.Секция LOOP()
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void loop(){
//================================================================================================= 
//                                    1.1.Инициализация параметров
//=================================================================================================
if(RT_HW_Base.isInit==0){
  RT_HW_Base.isInit=1;
  uartNextion=RT_HW_Base.device.uart.nextion; //--UART Nextion; 
//RT_HW_Base.i2cSetPins(28,29,0);}            //--Установка пинов i2c(pinSDA,pinSCL,bus) пользователем;
}
//================================================================================================= 
//                                    1.2.Диспетчер задач
//=================================================================================================
  RT_HW_Base.sheduler();                      //--Диспетчер;
//================================================================================================= 
//                                    1.3.Однократный вывод на консоль параметров проекта;
//=================================================================================================
if(RT_HW_Base.shed.frdm.num==1){
   RT_HW_Base.consoleBegin();                                     //--Инициализация консоли;
   if(RT_HW_Base.console.head){consoleHead();}}                   //--Однократный вывод отчета по MCU;
//================================================================================================= 
//                                    1.4.Обработка секундных событий
//=================================================================================================
if(RT_HW_Base.shed.eventSec){                                     //--Обработка секундных событий:
  vSpeedMCUF0=FilterSpeed0.filtered(RT_HW_Base.shed.cycle);       //  кол-во циклов в сек      с фильтром CORE0; 
  vSpeedMCUF1=FilterSpeed1.filtered(RT_HW_Base.shed.cycle1);      //  кол-во циклов в сек      с фильтром CORE1; 
  vspeedMCUF0=round(((float)vSpeedMCUF0)/1000);                   //  кол-во циклов в сек/1000 с фильтром CORE0;
  vspeedMCUF1=round(((float)vSpeedMCUF1)/1000);                   //  кол-во циклов в сек/1000 с фильтром CORE1;  
  RT_HW_Base.unixID.timeUNIX++;                                   //--Инкремент UNIX времени;
  RT_HW_Base.unixGetTotal();                                      //--Получение времени,даты,дня недели;
  if(RT_HW_Base.unixID.timeUNIX!=0){RT_HW_Base.unixID.delta=RT_HW_Base.unixID.timeUNIX-RT_HW_Base.unixID.timeUNIX_NTP;} //--Разрыв с временем NTP сервера;
}
//=================================================================================================
//                                    2.1.Управление через Ethernet
//================================================================================================= 
if(RT_HW_Base.shed.frdm.num==2){
  setParamExpEth();                             //--Настройка параметров Ethernet;             
  directExpEth();                               //--Управление модулем   Ethternet;
  messExpEth();                                 //--Вывод диагностических сообщений Ethernet(период в циклах loop);
}
//=================================================================================================
//                                    2.2.Управление NTP-сервером через Ethernet
//================================================================================================= 
if(RT_HW_Base.shed.frdm.num==3){
  setParamNtpEth();                             //--Настройка параметров NTP-сервера;
  directNtpEth();                               //--Управление работой с NTP-сервера;
  messNtpEth();                                 //--Вывод диагностических сообщений NTP-сервер;
}
//=================================================================================================
//                                    2.3 Управление сервером через Ethernet
//================================================================================================= 
if(RT_HW_Base.shed.frdm.num==4){
  directServerEth(1);                           //--Консоль: =0 Нет вывода; =1-Подключение/отключение; >=2 Все сообщения;
  messServerEth(); 
}
//================================================================================================= 
//                                    3.2.СЕНСОРЫ через i2c
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==12) {snsAHTxx();}    //--i2c.AHTxx;
  if(RT_HW_Base.shed.frdm.num==13) {snsSHT3x();}    //--i2c.SHT3x;   
  if(RT_HW_Base.shed.frdm.num==14) {snsBH1750();}   //--i2c.BH1750;
  if(RT_HW_Base.shed.frdm.num==15) {snsBME280();}   //--i2c.BME280(Press);  
  if(RT_HW_Base.shed.frdm.num==16) {snsBMP180();}   //--i2c.BMP180(Press);  
//================================================================================================= 
//                                   4.1.РАСШИРИТЕЛИ через i2cfrdm.n
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==20) {genMCP4725(); expMCP4725();}   //--i2c.MCP4725;
  if(RT_HW_Base.shed.frdm.num==21) {              expADS1115();}   //--i2c.ADS1115;
//================================================================================================= 
//                                   4.2.РАСШИРИТЕЛИ через SPI
//================================================================================================= 
  if(RT_HW_Base.shed.frdm.num==21) {              expDinPLC();}   //--Дискретный ввод; 
  if(RT_HW_Base.shed.frdm.num==22) {genDotPLC();  expDotPLC();}   //--Дискретный выход;    
//=================================================================================================
//                                   5.ДИСПЛЕИ
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==40) {Lcd1();}          //--Вывод на дисплей Lcd1(16x2,i2c,0x27);
  if(RT_HW_Base.shed.frdm.num==41) {Lcd2();}          //--Вывод на дисплей Lcd2(20x4,i2c,0x3E);
  if(RT_HW_Base.shed.frdm.num==42) {Lcd3();}          //--Вывод на дисплей Lcd3(20x4,i2c,0x26); 
  if(RT_HW_Base.shed.frdm.num==43) {Nextion();}       //--Обмен с панелью  Nextion; 
//=================================================================================================
//                                   6.ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==49){fncSetStatus();}   //--Флаги системные и готовности устройств;
  if(RT_HW_Base.shed.slow.num==1) {fncCounter();}     //--Тестовый счетчик;
//-------------------------------------------------------------------------------------------------

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                            3.Modbus
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  #include "mbMasterRTU.hpp"    //==Modbus Master RTU1;
  #include "mbSlaveRTU.hpp"     //==Modbus Slave  RTU1;


//#################################################################################################
//                       II. Переключение на ядро CORE 1 для  RP2040
//#################################################################################################
#if defined(RT_HW_PERMIT_CORE1)
} 
void loop1() {RT_HW_Base.shed.isLoop1=1;
#endif
  if(RT_HW_Base.shed.freshSec1) {RT_HW_Base.shed.cntCycle1=1; RT_HW_Base.shed.freshSec1=0;}    //--Увеличение числа циклов loop1() (для вычисления быстродействия CORE1);
  else                          {RT_HW_Base.shed.cntCycle1++;}
}; //++++END loop() or loop1=======================================================================


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    ВНЕШНИЕ ФУНКЦИИ
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                  1.Функция: Вывод на консоль параметров контроллера
//=================================================================================================
void consoleHead(){
  RT_HW_Base.consoleHead(String(F("Тест Board_06_Device_Full_v1.1")),'=');
  RT_HW_Base.consoleVar(String(F("Проект->")));                     RT_HW_Base.consoleVar(String(F(__FILE__)),'E');
  RT_HW_Base.consoleHead(String(F("Основные параметры")));          RT_HW_Base.mess.modePin='T';  RT_HW_Base.consoleBoardGeneral();           
//RT_HW_Base.consoleHead(String(F("Дополнительные параметры")));    RT_HW_Base.mess.modePin='T';  RT_HW_Base.consoleBoardAdd(); 
//RT_HW_Base.consoleHead(String(F("Параметры диспетчера задач")));  RT_HW_Base.consoleShedulerParameters();
//RT_HW_Base.consoleHead(String(F("Доступные пины")));              RT_HW_Base.mess.modePin='A';  RT_HW_Base.consolePinsAll();    
  RT_HW_Base.consoleHead(String(F("Интерфейсы")));                  RT_HW_Base.mess.modePin='T';  RT_HW_Base.consoleInterface(); 
  RT_HW_Base.consoleHead(String(F("Системные,тестовые,cs пины")));  RT_HW_Base.mess.modePin='T';  
  RT_HW_Base.consolePinsSystem(); RT_HW_Base.consolePinsTest();     RT_HW_Base.consolePinsCS(); 
  RT_HW_Base.consoleHead(String(F("Устройства на UART")));          RT_HW_Base.mess.modePin='T'; RT_HW_Base.consoleNumUART();    
//-------------------------------------------------------------------------------------------------
  RT_HW_Base.consoleHead(String(F("Сканирование i2c(bus=0)")));     RT_HW_Base.mess.modeAdr='A';  
                                                                    RT_HW_Base.i2cScanBus(0);     
//-------------------------------------------------------------------------------------------------   
  RT_HW_Base.consoleLine('+');  
};
//=================================================================================================
