//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                  1. Объекты и параметры,функции 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//-------------------------------------------------------------------------------------------------
//                                  1.1. Системные параметры
//------------------------------------------------------------------------------------------------- 
  uint32_t vSpeedMCUF0;  uint16_t vspeedMCUF0; RT_HW_FILTER_RING_AVERAGE<uint32_t,5> filterSpeed0;    //--Быстродействие, быстродействие/1000, фильтр CORE 0;
  uint32_t vSpeedMCUF1;  uint16_t vspeedMCUF1; RT_HW_FILTER_RING_AVERAGE<uint32_t,5> filterSpeed1;    //--Быстродействие, быстродействие/1000, фильтр CORE 1;
  uint32_t vDeltaNTP;   //--Разница текущего времени с последним временем от NTP-сервера;
//-------------------------------------------------------------------------------------------------
//                                  1.2. Пины Контроль,Led,Кнопка,ADC,PWM
//------------------------------------------------------------------------------------------------- 
  uint8_t pinControl=255; RT_HW_PIN_DIR_ID   idPinControl;  //--Пин контроль loop()[для логического анализатора];
  uint8_t pinLed=255;     RT_HW_PIN_DIR_ID   idPinLed;      //--Пин Led на плате;                    
  uint8_t pinButton=255;  uint8_t  vButtonF;                //--Пин Кнопка, значение с кнопки после фильтра;
  uint8_t pinADC=255;     uint16_t vADCF;                   //--Пин ADC, значение после фильтра;                                   
  uint8_t pinPWM=255;     uint16_t vPWM;                    //--Пин PWM, значение для вывода на PWM;
//-------------------------------------------------------------------------------------------------
//                                  1.3. Пины устройств, параметры
//------------------------------------------------------------------------------------------------- 
  uint8_t pinDS1820=255;        uint8_t  vDS1820_ok=0;float    vDS1820_Temp=0.0;        //--pin.Сенсор HC-SR04; 
  uint8_t pinSR04=255;          uint8_t  vSR04_ok=0;  uint16_t vSR04_Len=0;             //--pin.Сенсор HC-SR04; 
//-------------------------------------------------------------------------------------------------
//                                  1.4. CS устройств, параметры
//-------------------------------------------------------------------------------------------------
  uint8_t csMAX6675=255;        uint8_t  vMAX6675_ok; float    vMAX6675_Temp;           //--SPI.Сенсор AHTxx;
  uint8_t cs74HC595=255;                              uint16_t v74HC595_vr;             //--SPI.Расширитель 74HC595;
  uint8_t cs74HC165=255;                              uint16_t v74HC165_vr;             //--SPI.Расширитель 74HC165;
//-------------------------------------------------------------------------------------------------
//                                  1.5. Адреса устройств на шине i2c, параметры
//-------------------------------------------------------------------------------------------------
  uint8_t i2cAdrLcd1=0x27;                                                              //--i2c.Дисплей Lcd1 HD44780 (16x2);
  uint8_t i2cAdrLcd2=0x3E;                                                              //--i2c.Дисплей Lcd2 HD44780 (20x4);
  uint8_t i2cAdrLcd3=0x26;                                                              //--i2c.Дисплей Lcd3 HD44780 (20x4);
  uint8_t i2cAdrAHTxx=0x38;     uint8_t  vAHTxx_ok;   float    vAHTxx_Temp, vAHTxx_Hum; //--i2c.Сенсор AHTxx;
  uint8_t i2cAdrSHT3x=0x44;     uint8_t  vSHT3x_ok;   float    vSHT3x_Temp, vSHT3x_Hum; //--i2c.Сенсор SHT3x; 
  uint8_t i2cAdrBME280=0x77;    uint8_t  vBMPx80_ok;  float    vBMPx80_Press;           //--i2c.Сенсор BMEx80/BMPx80;
  uint8_t i2cAdrBMP180=0x77;                                                            //--i2c.Сенсор BMP180;
  uint8_t i2cAdrBH1750=0x23;    uint8_t  vBH1750_ok;  uint16_t vBH1750_Lux;             //--i2c.Сенсор BH1750;
  uint8_t i2cAdrMCP4725=0x60;   uint8_t  vMCP4725_ok; uint16_t vMCP4725_vr;             //--i2c.Расширитель DAC;
  uint8_t i2cAdrADS1115=0x48;   uint8_t  vADS1115_ok; float    vADS1115_A0f,            //--i2c.Расширитель ADC
                                         vADS1115_A1f,vADS1115_A2f,vADS1115_A3f;        //                  ADS1115;
//-------------------------------------------------------------------------------------------------
//                                  1.6. Номера UART, переменные для работы с UART
//-------------------------------------------------------------------------------------------------
uint8_t   uartNextion=255;     uint8_t nxtPage=0; uint8_t nxtVr1,nxtVr2,nxtVr3,nxtVr4;  //--UART.Панель Nextion;
//-------------------------------------------------------------------------------------------------
//                                  1.7. Параметры для работы с устройствами
//------------------------------------------------------------------------------------------------- 
  uint32_t flagSystem=0;    //--Флаги системные;
  uint32_t flagDevice=0;    //--Флаги устройств;
  uint32_t pinDIN=0;        //--Регистр дискретных входов; 
  uint32_t pinDOT=0;        //--Регистр дискретных выходов;
//-------------------------------------------------------------------------------------------------
//                                  1.8. Параметры для тестирования
//-------------------------------------------------------------------------------------------------
  int16_t   counter = -10;            //--Тестовый счетчик;                  
//-------------------------------------------------------------------------------------------------
//                                  1.10. Параметры для тестирования Ethernet0
//-------------------------------------------------------------------------------------------------                
  IPAddress ethIP0{0,0,0,0};            //--IP  адрес Ethernet1 в формате IP;  
  uint32_t  ethNumIP0=0;                //--IP  адрес Ethernet0 в uint32_t; 
  uint8_t   macAddr0[6]={0,0,0,0,0,0};  //--MAC адрес Ethernet0; 
//-------------------------------------------------------------------------------------------------
//                                  1.11. Параметры для тестирования Ethernet1
//-------------------------------------------------------------------------------------------------                
  IPAddress ethIP1{0,0,0,0};            //--IP  адрес Ethernet1 в формате IP; 
  uint32_t  ethNumIP1=0;                //--IP  адрес Ethernet1 в uint32_t; 
  uint8_t   macAddr1[6]={0,0,0,0,0,0};  //--MAC адрес Ethernet1;   
//-------------------------------------------------------------------------------------------------
//                                  1.12. Параметры для тестирования Web-сервера
//-------------------------------------------------------------------------------------------------
  uint8_t   ethServerCnt=0;             //--Кол-во соединений с WEB-сервером;
//-------------------------------------------------------------------------------------------------
//                                  1.20. Параметры для тестирования Modbus Master RTU
//-------------------------------------------------------------------------------------------------
  uint8_t   MbMasterRTU1_numUART=255;   //--Номер UART Modbus Master RTU;
  uint16_t  rg0=0,rg1=0,rg2=0,rg3=0,rg4=0,rg5=0,rg6=0,rg7=0;
  uint16_t  wg0=0,wg1=0,wg2=0,wg3=0,wg4=0,wg5=0,wg6=0,wg7=0;
//-------------------------------------------------------------------------------------------------
#if defined(RT_HW_TEST_PERMIT_MB_MASTER_RTU)
  ModbusMasterRTU   MasterRTU1(1, 2);   //--Создание Master: номер UART=1; кол-во Slave=2 (Slave 0,1);
  uint8_t   MbMasterRTU1_custom=0;      //--Флаг настройки Modbus Slave RTU1;
  int16_t   tempInt;
  bool      tempBool;
  int16_t   value, oldValue;
  uint32_t  startTime; 
#endif
//-------------------------------------------------------------------------------------------------
//                                   1.21. Параметры UART для Modbus Slave RTU 
//-------------------------------------------------------------------------------------------------
  uint8_t   MbSlaveRTU1_numUART=2;      //--Номер UART Modbus Slave RTU1; 
  int16_t   lastError;                  //--Код последней ошибки;
//uint8_t cnsCnt=0, cnsADC=0, first=0, vAgoButton=0;                            //--Рабочие параметры;1
//-------------------------------------------------------------------------------------------------
#if defined(RT_HW_TEST_PERMIT_MB_SLAVE_RTU)
  ModbusSlaveRTU   SlaveRTU1(1);        //--Создание объекта Мodbus Slave на UART=1;
  int       MbSlaveRTU1_DI_Adr[]={8,9,10,11,12,14,15,16,17,18}; //--Таблица доступных адресов для 10-ти регистров;  
  uint8_t   MbSlaveRTU1_ID=1;           //--ID(адрес)      Modbus Slave RTU1;
  uint8_t   MbSlaveRTU1_custom=0;       //--Флаг настройки Modbus Slave RTU1;
  int16_t   saveInt16=-23567;           //--Рабочая переменная int16_t;
  int32_t   saveInt32=123456;           //--Рабочая переменная int32_t;
  float     saveFloat1=12.5;            //--Рабочая переменная float; 
  float     saveFloat2=23.4;            //--Рабочая переменная float;
  bool      saveBlink=0;                //--Рабочая переменная bool;
#endif
//-------------------------------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                   2. ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void fncInitParam(){
  if(RT_HW_Base.isInit==1){return;}
     RT_HW_Base.isInit=1;
     pinControl  =RT_HW_Base.vPinControl(); //--Установка пина Control;
     pinLed      =RT_HW_Base.vPinLed();     //--Установка пина Led;
     pinButton   =RT_HW_Base.vPinButton();  //--Установка пина Кнопки;
     pinADC      =RT_HW_Base.vPinADC();     //--Установка пина ADC;   
     pinPWM      =RT_HW_Base.vPinPWM();     //--Установка пина PWM;
     pinDS1820   =RT_HW_Base.vPinOneWire(); //--Установка пина DS1820;   
     pinSR04     =RT_HW_Base.vPinSR04();    //--Установка пина HC-SR04;      
     cs74HC595   =RT_HW_Base.vSpiCS0();     //--Установка пина cs 74HC595;
     cs74HC165   =RT_HW_Base.vSpiCS1();     //--Установка пина cs 74HC165;
     csMAX6675   =RT_HW_Base.vSpiCS4();     //--Установка пина cs MAX6675;
     MbMasterRTU1_numUART =RT_HW_Base.vUartModBus1(); //--Установка номера UART Modbus Master; 
     MbSlaveRTU1_numUART  =RT_HW_Base.vUartModBus2(); //--Установка номера UART Modbus Slave; 
     uartNextion =RT_HW_Base.vUartNextion();//--UART Nextion; 
     RT_HW_Base.ethGenMacAddr(macAddr0,RT_HW_MICROS);
     RT_HW_Base.ethGenMacAddr(macAddr1,RT_HW_MICROS+10);     
   //RT_HW_Base.i2cSetPins(28,29,0);        //--Установка пинов i2c(pinSDA,pinSCL,bus) пользователем;
};  

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                   10. ФУНКЦИИ РАБОТЫ С ПИНАМИ
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                 10.1. Чтение кнопки с защитой от дребезга 50 ms
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_BUTTON
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  RT_HW_PIN_DIR_ID   idPinButton;                 uint8_t  vButton;    //--ID пина кнопки, значение с кнопки;
  RT_HW_FILTER_CHATTER<uint8_t>    filterButton;                       //--Фильтр дребезга кнопки;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void fncButton(){
     vButton=!RT_HW_Base.pinDigitalRead(idPinButton,pinButton,'U'); //--Чтение кнопки с подтяжкой пина к Vcc;
     vButtonF=filterButton.filtered(vButton,50);      //--Фильтр защиты от дребезга 50ms;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void fncButton(){;};
#endif
//=================================================================================================
//                                  10.2. Чтение ADC
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_ADC
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  RT_HW_PIN_ADC_ID   idPinADC;                         uint16_t vADC;   //--Пин ADC, значение с пина;  
  RT_HW_FILTER_RING_AVERAGE<uint16_t,10> filterADC;                     //--Фильтр ADC(median 5-го порядка), значение после фильтра;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void fncADC(){
      RT_HW_Base.pinAnalogRead(idPinADC,pinADC);             //--Чтение с пина ADC;
      vADCF=filterADC.filtered(idPinADC.vNorm);       //--Фильтр медианный средний ADC;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void fncADC(){;};
#endif  
//=================================================================================================
//                                  10.3. Запись PWM
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_PWM
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  RT_HW_PIN_PWM_ID   idPinPWM;                          uint16_t vPWMcur;       //--Пин PWM, значение для вывода на PWM;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void fncPWM(){
  if(idPinPWM.dir==0){idPinPWM.freq=1000; idPinPWM.depth=16;} //   freq=1000Hz, depth bit=16;
  RT_HW_Base.pinPWM(idPinPWM,pinPWM,vPWM);       //--Запись на пин нормализованного значения;
  vPWMcur=idPinPWM.var;                  //--Сохранение значения выводимого на пин;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void fncPWM(){;};
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                    11. ТЕСТОВЫЕ ФУНКЦИИ
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                    11.1. Формирование вектора состояний устройств
//=================================================================================================
void fncSetStatus(){
//------------------------------------------------------------------------------------------------
  bitWrite(flagSystem,1,RT_HW_Base.shed.blink500);
  bitWrite(flagSystem,2,vButtonF);
//------------------------------------------------------------------------------------------------
  bitWrite(flagDevice,0,vAHTxx_ok);
  bitWrite(flagDevice,1,vSHT3x_ok);
  bitWrite(flagDevice,7,vBH1750_ok);
  bitWrite(flagDevice,8,vDS1820_ok);
  bitWrite(flagDevice,9,vSR04_ok);
  bitWrite(flagDevice,10,vMAX6675_ok);
  bitWrite(flagDevice,30,vADS1115_ok);
};

//=================================================================================================
//                                    11.2. Счетчик для тестирования ModBus Slave RTU
//=================================================================================================
void fncCounter(){ 
    if(++counter > 10){counter = -10;}
#if defined(RT_HW_TEST_PERMIT_MB_SLAVE_RTU)
    saveBlink = !saveBlink;
    saveInt16 =counter;
    saveInt32 =counter*1000;
    saveFloat1=counter / 10.0;
    saveFloat2=counter / 100.0;
#endif     
};
//=================================================================================================
