//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                                 ТECT: Board_06 Device_Big_v.5.0_25.02.2024  
//                              ТЕСТИРОВАНИЕ УСТРОЙСТВ С ВЫВОДОМ НА ДИСПЛЕИ (LCD,Nextion)
//                            (совместим с визуальной системой программирования FLProg)
//    1.1.Инициализация параметров в т.ч. тестовые пины, которые могут быть изменены.
//    1.2.В каждом цикле loop() вызывается "Диспетчер задач" и выполняется дискретный вывод на пины:
//            control - изменяется 0/1 в каждом цикле loop() для лог.анализатора),
//            Led на плате - меандр 500ms;
//    1.3.Инициализируется консоль (в терминах Arduino IDE - монитор порта). 
//        После готовности консоли (проверка консоли особо критична для контроллеров с USB на кристалле - STM32,Raspberry Pi,ESP32-C3,S2,S3),
//        в монитор порта однократно выводится отчет о проекте (пины, наличие коммуникаций и др.),
//        сканируется шина i2c (SDA,SCL необходимо подтянуть к Vcc резисторами 10-47к).
//    1.4.Каждую секунду обрабатываются секундные параметры - быстродействие проекта, время наработки).
//    2.1.Выполняется чтение пина "Кнопка"(период 50ms) с защитой от дребезга 50ms.
//    2.2.Выполняется чтение пина   ADC   (период 50ms) с фильтром медианным 5-го порядка;
//    2.3.Выполняется запись на пин PWM значение ADC;
//    3.1.Сенсоры через пины: DS1820,HC-SR04;
//    3.2.Сенсоры через i2c: AHTxx(T,H),SHT3x(T,H),BH1750,BMPx80(Press);
//    3.3.Сенсоры через SPI: MAX6675(T);
//    4.1.Расширители через i2c: MCP4725(DAC),ADS1115(ADC);
//    4.2.Расширители через SPI: 74HC595 "Бегущая 1", 74HC165(ввод со входов с подтянутыми через 10к к Vcc);    
//    5.1.Вывод на Lcd1.i2c 16x2(0x27):
//          Кнопка=0:  строка 1:Blink(*),ADC,74HC165(HEX.2), быстродействие CORE0/1000, флаг CORE1(+), быстродействие CORE1/1000;
//                     строка 2:AHTxx.ok,AHTxx.Temp,AHTxx.Hum;  
//          Кнопка=1:  строка 1:Blink(#),DS1820.ok,DS1280.Temp,HC-SR04.ok,HC-SR04.Len;
//                     строка 2:SHT3x.ok,SHT3x.Temp,SHT3x.Hu;.  
//    5.2.Вывод на Lcd2.i2c 20x4 (0x3E):
//    5.2.Вывод на Lcd3.i2c 20x4 (0x26):  
//=================================================================================================
//    Подключение к выполнению различных устройств выполняется через снятие символов комментариев(//) 
//    с соответствующего макроса.
//-------------------------------------------------------------------------------------------------
// ecoins@mail.ru 04.02.2024
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    0.Секция DECLARE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                          1.Разрешения использования пинов и устройств
//================================================================================================= 
//#define RT_HW_TEST_PERMIT_CONTROL     //--pin.Разрешение вывода на пин Контроль; 
  #define RT_HW_TEST_PERMIT_BUTTON      //--pin.Разрешение использования пина        Button; 
  #define RT_HW_TEST_PERMIT_ADC         //--pin.Разрешение использования пина        ADC;
  #define RT_HW_TEST_PERMIT_PWM         //--pin.Разрешение использования пина        PWM;      
  #define RT_HW_TEST_PERMIT_SR04        //--pin.Разрешение использования сенсора     HC-SR04;
  #define RT_HW_TEST_PERMIT_DS1820      //--pin.Разрешение использования сенсора     DS1820;
  #define RT_HW_TEST_PERMIT_AHTx        //--i2c.Разрешение использования сенсора     AHTx; 
  #define RT_HW_TEST_PERMIT_SHT3x       //--i2c.Разрешение использования сенсора     SHT3x;
//#define RT_HW_TEST_PERMIT_BH1750      //--i2c.Разрешение использования сенсора     BH1750;
//#define RT_HW_TEST_PERMIT_BMP180      //--i2c.Разрешение использования сенсора     BMP180;
//#define RT_HW_TEST_PERMIT_BME280      //--i2c.Разрешение использования сенсора     BME280;     
//#define RT_HW_TEST_PERMIT_MAX6675     //--SPI.Разрешение использования сенсора     MAX6675; 
  #define RT_HW_TEST_PERMIT_MCP4725     //--i2c.Разрешение использования расширителя MCP4725;
  #define RT_HW_TEST_PERMIT_ADS1115     //--i2c.Разрешение использования расширителя ADS1115;    
  #define RT_HW_TEST_PERMIT_74HC165     //--SPI.Разрешение использования расширителя 74HC165;
  #define RT_HW_TEST_PERMIT_74HC595     //--SPI.Разрешение использования расширителя 74HC595;
  #define RT_HW_TEST_PERMIT_LCD1        //--i2c.Разрешение использования дисплея     Lcd1;
  #define RT_HW_TEST_PERMIT_LCD2        //--i2c.Разрешение использования дисплея     Lcd2;
  #define RT_HW_TEST_PERMIT_LCD3        //--i2c.Разрешение использования дисплея     Lcd3;
  #define RT_HW_TEST_PERMIT_NEXTION     //--UART.Разрешение использования панели     Nextion;  
  #define RT_HW_TEST_PERMIT_CNS_HEAD    //--Консоль.Разрешение вывода заголовков;
//-------------------------------------------------------------------------------------------------
  #define RT_HW_TEST_PERMIT_ETHERNET        //--Разрешение тестов работы с Ethernet;
  #define RT_HW_TEST_PERMIT_ETHERNET_NTP    //--Разрешение тестов работы c NTP-cерверами(серверы точного времени);
  #define RT_HW_TEST_PERMIT_ETHERNET_SERVER //--Разрешение тестов работы c cервером;
//-------------------------------------------------------------------------------------------------
//#define RT_HW_TEST_PERMIT_MB_MASTER_RTU   //--Разрешение использования MasterRTU;
//#define RT_HW_TEST_PERMIT_MB_SLAVE_RTU    //--Разрешение использования SlaveRTU;  
//=================================================================================================
//                                  2.Подключение библиотек
//=================================================================================================
  #include "flprogModbusRTU.h"          //--Подключение библиотеки ModBus RTU (Включает #include RT_HW_BASE.h");  
  #include "RT_HW_BASE.h"               //--Подключение базовой библиотеки;
  #include "RT_HW_LCD44780.h"           //--Подключение библиотеки дисплеев типа HD44780;
  #include "RT_HW_SENSORS.h"            //--Подключение библиотек базовых сенсоров    (DS1820, HC-SR04,AHTx,   SHT3x,  BH1750,  BME/BMP,etc);
  #include "RT_HW_EXPANDERS.h"          //--Подключение библиотек базовых расширителей(MCP4725,ADS1115,74HC595,74HC165,MCP23x17,PCF8575,etc);
  #include "RT_HW_NEXT.h"               //--Подключение библиотеки панелей типа Nextion;
//=================================================================================================
//                                4.Подключение внутренних вкладок
//=================================================================================================
  #include "Asystem.hpp"                //--Параметры;
  #include "Bconsole.hpp"               //--Вывод на консоль; 
  #include "Csensor.hpp"                //--Сенсоры; 
  #include "Device.hpp"                 //--Расширители; 
  #include "Lcd1.hpp"                   //--Дисплей Lcd1(i2c) 16x4;       
  #include "Lcd2.hpp"                   //--Дисплей Lcd2(i2c) 20x4;
  #include "Lcd3.hpp"                   //--Дисплей Lcd3(i2c) 20x4;
  #include "Nextion.hpp"                //--Панель Nextion; 
  #include "Tethernet.hpp"              //--Ethernet; 
  #include "mbMasterRTU.hpp"            //--Modbus Master RTU;   
  #include "mbSlaveRTU.hpp"             //--Modbus Slave  RTU;   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    I.Секция SETUP()
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void setup(){}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    II.Секция LOOP()
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void loop(){
//================================================================================================= 
//                                    1.1. Инициализация параметров
//=================================================================================================
  fncInitParam();                                                               // [Asystem.hpp];
//================================================================================================= 
//                                    1.2.Диспетчер задач
//=================================================================================================
  RT_HW_Base.sheduler();                                                         //--
//=================================================================================================
//                                    1.3. Вывод на контрольный пин
//=================================================================================================
#if defined(RT_HW_TEST_PERMIT_CONTROL)
  RT_HW_Base.pinDigitalWrite(idPinControl,pinControl,RT_HW_Base.shed.control);           //--Вывод  на пин;
#endif  
//================================================================================================= 
//                                    1.4. Вывод меандра на светодиод
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==1) {
    RT_HW_Base.pinDigitalWrite(idPinLed,pinLed,RT_HW_Base.shed.blink500);            //--Вывод  на пин;    
}
//================================================================================================= 
//                                    1.5. Однократный вывод на консоль параметров проекта;
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==1){
#if defined(RT_HW_TEST_PERMIT_CNS_HEAD) 
     RT_HW_Base.consoleBegin();                   //--Инициализация консоли;
  if(RT_HW_Base.console.head){consoleHead();}     //--Однократный вывод отчета по MCU;
#endif  
}
//================================================================================================= 
//                                    1.6. Обработка секундных событий
//=================================================================================================
if(RT_HW_Base.shed.eventSec){                                 //--Обработка секундных событий:
   vSpeedMCUF0=filterSpeed0.filtered(RT_HW_Base.shed.cycle);  //  кол-во циклов в сек      с фильтром CORE0; 
   vSpeedMCUF1=filterSpeed1.filtered(RT_HW_Base.shed.cycle1); //  кол-во циклов в сек      с фильтром CORE1; 
   vspeedMCUF0=round(((float)vSpeedMCUF0)/1000);              //  кол-во циклов в сек/1000 с фильтром CORE0;
   vspeedMCUF1=round(((float)vSpeedMCUF1)/1000);              //  кол-во циклов в сек/1000 с фильтром CORE1;  
   RT_HW_Base.unixIncTime();                                  //--Инкремент текущего времени;
   vDeltaNTP=RT_HW_Base.unixID.timeUNIX-RT_HW_Base.unixID.timeUNIX_NTP; //--Время прошедшее с последнего значения с NTP-сервера;
}
//================================================================================================= 
//                                    1.7. Тестовые генераторы
//=================================================================================================


//================================================================================================= 
//                                    2.ПИНЫ Button,ADC,PWM
//=================================================================================================
  if(RT_HW_Base.shed.quick.num==1) {fncButton();}   //--Чтение кнопки с защитой от дребезга(50ms);    
  if(RT_HW_Base.shed.quick.num==2) {fncADC();}      //--Чтение с  пина ADC с усреднением фильтром медианным 5-го порядка;
  if(RT_HW_Base.shed.quick.num==3) {fncPWM();}      //--Запись на пин  PWM значения с ADC;
//================================================================================================= 
//                                    3. СЕНСОРЫ через пины
//=================================================================================================  
  if(RT_HW_Base.shed.frdm.num==10) {snsDS1820();}   //--pin.DS1820. При опросе задержка 4-6 ms;    
  if(RT_HW_Base.shed.frdm.num==11) {snsSR04();}     //--pin.HC-SR04(по прерываниям); 
//================================================================================================= 
//                                    4. СЕНСОРЫ через i2c
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==12) {snsAHTxx();}    //--i2c.AHTxx;
  if(RT_HW_Base.shed.frdm.num==13) {snsSHT3x();}    //--i2c.SHT3x;   
  if(RT_HW_Base.shed.frdm.num==14) {snsBH1750();}   //--i2c.BH1750;
  if(RT_HW_Base.shed.frdm.num==15) {snsBME280();}   //--i2c.BME280(Press);  
  if(RT_HW_Base.shed.frdm.num==16) {snsBMP180();}   //--i2c.BMP180(Press);  
//================================================================================================= 
//                                    5. СЕНСОРЫ через SPI
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==17) {snsMAX6675();}  //--i2c.AHTxx;
//================================================================================================= 
//                                    6. РАСШИРИТЕЛИ через i2c
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==20) {genMCP4725(); expMCP4725();}   //--i2c.MCP4725;
  if(RT_HW_Base.shed.frdm.num==21) {              expADS1115();}   //--i2c.ADS1115;
//================================================================================================= 
//                                    7. РАСШИРИТЕЛИ через SPI
//================================================================================================= 
  if(RT_HW_Base.shed.frdm.num==21) {              exp74HC165();}   //--Вывод на 74HC165 (v74HC165_vr); 
  if(RT_HW_Base.shed.frdm.num==22) {gen74HC595(); exp74HC595();}   //--Вывод на 74HC595 (v74HC595_vr);   
//=================================================================================================
//                                    8. ДИСПЛЕИ
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==40) {Lcd1();}          //--Вывод на дисплей Lcd1(16x2,i2c,0x27);
  if(RT_HW_Base.shed.frdm.num==41) {Lcd2();}          //--Вывод на дисплей Lcd2(20x4,i2c,0x3E);
  if(RT_HW_Base.shed.frdm.num==42) {Lcd3();}          //--Вывод на дисплей Lcd3(20x4,i2c,0x26); 
  if(RT_HW_Base.shed.frdm.num==43) {Nextion();}       //--Обмен с панелью  Nextion; 
//=================================================================================================
//                                    9. ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==49){fncSetStatus();}   //--Флаги системные и готовности устройств;
//-------------------------------------------------------------------------------------------------


//=================================================================================================
//                                    2.1.Управление через Ethernet
//================================================================================================= 
if(RT_HW_Base.shed.frdm.num==2){
  setParamExpEth();                             //--Настройка параметров Ethernet;             
  directExpEth();                               //--Управление модулем   Ethternet;
  messExpEth();                                 //--Вывод диагностических сообщений Ethernet(период в циклах loop);
}
//=================================================================================================
//                                    2.2.Управление NTP-сервером через Ethernet
//================================================================================================= 
if(RT_HW_Base.shed.frdm.num==3){
  setParamNtpEth();                             //--Настройка параметров NTP-сервера;
  directNtpEth();                               //--Управление работой с NTP-сервера;
  messNtpEth();                                 //--Вывод диагностических сообщений NTP-сервер;
}
//=================================================================================================
//                                    2.3 Управление сервером через Ethernet
//================================================================================================= 
if(RT_HW_Base.shed.frdm.num==4){
  directServerEth(1);                           //--Консоль: =0 Нет вывода; =1-Подключение/отключение; >=2 Все сообщения;
  messServerEth(); 
}
//=================================================================================================
//                                   6.ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ
//=================================================================================================
  if(RT_HW_Base.shed.frdm.num==49){fncSetStatus();}   //--Флаги системные и готовности устройств;
  if(RT_HW_Base.shed.slow.num==1) {fncCounter();}     //--Тестовый счетчик;
//-------------------------------------------------------------------------------------------------

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                            3.Modbus
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  #include "mbMasterRTU.hpp"    //==Modbus Master RTU1;
  #include "mbSlaveRTU.hpp"     //==Modbus Slave  RTU1;


//#################################################################################################
//                       II. Переключение на ядро CORE 1 для  RP2040
//#################################################################################################
#if defined(RT_HW_PERMIT_CORE1)
} 
void loop1() {RT_HW_Base.shed.isLoop1=1;
#endif
  if(RT_HW_Base.shed.freshSec1) {RT_HW_Base.shed.cntCycle1=1; RT_HW_Base.shed.freshSec1=0;}    //--Увеличение числа циклов loop1() (для вычисления быстродействия CORE1);
  else                          {RT_HW_Base.shed.cntCycle1++;}
}; //++++END loop() or loop1=======================================================================
//=================================================================================================
