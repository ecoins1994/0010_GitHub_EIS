//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    3.СЕНСОРЫ через i2c
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                    3.1.AHTxx.i2c (T,H)      
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_AHTx
RT_HW_AHTxx_DEV   dvAHTxx;      RT_HW_STRUCT_SHED_TASK shAHTxx; 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void snsAHTxx(){                                                            //==Функция: Управление SHT3x;
  if(dvAHTxx.custom==0) {                                                   //--Настройка параметров устройства и задачи; 
     dvAHTxx.custom=RT_HW_Base.i2cSetParam(dvAHTxx.dvI,i2cAdrAHTxx,0,0);    //  Настройка параметров: адрес i2c, номер шины, скорость;
     shAHTxx.periodLimit=50;  RT_HW_Base.setTaskID  (shAHTxx,'P',1200);}    //  Настройка задачи:     периодически='P', период=1200ms;
     RT_HW_Base.directTask(shAHTxx);                                        //--Управление задачей;  
     RT_HW_ahtxx.direct(dvAHTxx,shAHTxx.run);                               //--Управление устройством;
     if(dvAHTxx.fresh){dvAHTxx.fresh=0; vAHTxx_ok=dvAHTxx.ok; vAHTxx_Temp=dvAHTxx.vTemp; vAHTxx_Hum=dvAHTxx.vHum;}}  //--Обновление данных;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void snsAHTxx(){;};                                                         //==Функция: Заглушка вместо функции управления snsAHTxx();
#endif
//=================================================================================================
//                                      3.2.SHT3X.i2c(T,H)
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_SHT3x
RT_HW_SHT3x_DEV   dvSHT3x;      RT_HW_STRUCT_SHED_TASK shSHT3x;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void snsSHT3x(){                                                            //==Функция: Управление SHT3x;
  if(dvSHT3x.custom==0) {                                                   //--Настройка параметров устройства и задачи;              
     dvSHT3x.custom=RT_HW_Base.i2cSetParam(dvSHT3x.dvI,i2cAdrSHT3x,0,0);    //  Настройка параметров: адрес i2c, номер шины, скорость;
     shSHT3x.periodLimit=50;  RT_HW_Base.setTaskID  (shSHT3x,'P',1200); }   //  Настройка задачи:     периодически='P', период=1200ms; 
     RT_HW_Base.directTask(shSHT3x);                                        //--Управление задачей; 
     RT_HW_sht3x.direct(dvSHT3x,shSHT3x.run);                               //--Управление устройством;
    if(dvSHT3x.fresh){dvSHT3x.fresh=0; vSHT3x_ok=dvSHT3x.ok; vSHT3x_Temp=dvSHT3x.vTemp; vSHT3x_Hum=dvSHT3x.vHum;}}; //--Обновление данных;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void snsSHT3x(){;};                                                         //==Функция: Заглушка вместо функции управления snsSHT3x();
#endif
//=================================================================================================
//                                      3.3.BH1750
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_BH1750
RT_HW_BH1750_DEV  dvBH1750;     RT_HW_STRUCT_SHED_TASK shBH1750; 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void snsBH1750(){                                                           //==Функция: Управление BH1750;
if(dvBH1750.custom==0) {                                                    //--Настройка параметров устройства и задачи; 
   dvBH1750.custom=RT_HW_Base.i2cSetParam(dvBH1750.dvI,i2cAdrBH1750,0,0);   //  Настройка параметров: адрес i2c, номер шины, скорость;
   shBH1750.periodLimit=50;  RT_HW_Base.setTaskID  (shBH1750,'P',500);}     //  Настройка задачи:     периодически='P', период=1200ms; 
   RT_HW_Base.directTask(shBH1750);                                         //--Управление задачей; 
RT_HW_bh1750.direct(dvBH1750,shBH1750.run);                                 //--Управление устройством;
//-------------------------------------------------------------------------------------------------
if(dvBH1750.fresh){dvBH1750.fresh=0; vBH1750_Lux=dvBH1750.vLux; vBH1750_ok=dvBH1750.ok;}};   //--Обновление данных;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void snsBH1750(){;};
#endif
//=================================================================================================
//                                     3.4.BME280.i2c     
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_BME280
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
RT_HW_BME280_DEV  dvBME280;     RT_HW_STRUCT_SHED_TASK shBME280Press;
//-------------------------------------------------------------------------------------------------
void snsBME280(){
//-------------------------------------------------------------------------------------------------
if(dvBME280.custom==0 ){                                                    //--Настройка параметров устройства и задачи; 
   dvBME280.custom=RT_HW_Base.i2cSetParam(dvBME280.dvI,i2cAdrBME280,0,0);   //  Настройка параметров: адрес i2c, номер шины, скорость;
   dvBME280.permitTemp=0; dvBME280.permitHum=0; dvBME280.permitPress=1;     //  Настройка разрешения измерения давления;
   shBME280Press.periodLimit=50; RT_HW_Base.setTaskID(shBME280Press,'P',1400);}//Настройка задачи:     периодически='P', период=1400ms; 
   RT_HW_Base.directTask(shBME280Press);                                    //--Управление задачей; 
   RT_HW_bme280.direct(dvBME280,shBME280Press.run);                         //--Управление устройством;   
   if(dvBME280.fresh){dvBME280.fresh=0; vBMPx80_ok=dvBME280.ok; vBMPx80_Press=dvBME280.vPress;}   //--Обновление данных;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void snsBME280(){;};
#endif
//=================================================================================================
//                                     3.5.BMP180.i2c     
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_BMP180
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
RT_HW_BMP180_DEV  dvBMP180;     RT_HW_STRUCT_SHED_TASK shBMP180Press;
void snsBMP180(){
//-------------------------------------------------------------------------------------------------
if(dvBMP180.custom==0) {                                                  //--Настройка параметров устройства и задачи; 
   dvBMP180.custom=RT_HW_Base.i2cSetParam(dvBMP180.dvI,i2cAdrBMP180,0,0); //  Настройка параметров: адрес i2c, номер шины, скорость; 
   dvBMP180.permitTemp=0; dvBMP180.permitPress=1;                         //  Настройка разрешения измерения давления;
   shBMP180Press.periodLimit=50; RT_HW_Base.setTaskID(shBMP180Press,'P',1400);}//Настройка задачи:     периодически='P', период=1400ms;
   RT_HW_Base.directTask(shBMP180Press);                                  //--Управление задачей; 
   RT_HW_bmp180.direct(dvBMP180,shBMP180Press.run);                       //--Управление устройством;   
//-------------------------------------------------------------------------------------------------
   if(dvBMP180.fresh){dvBMP180.fresh=0; vBMPx80_ok=dvBMP180.ok; vBMPx80_Press=dvBMP180.vPress;}   //--Обновление данных;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void snsBMP180(){;};
#endif
//=================================================================================================

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    5.РАСШИРИТЕЛИ через пины
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    6.РАСШИРИТЕЛИ через i2c
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                    6.1.MCP4725.i2c;
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_MCP4725
RT_HW_MCP4725_DEV        dvMCP4725;     RT_HW_STRUCT_SHED_TASK shMCP4725;
RT_HW_GENERATOR_EVENT_ID idGenMCP4725;  RT_HW_COUNTER_ID idCntMCP4725;      uint16_t vGenMCP4725=0;  //--Для генератора 0-4095 MCP4725;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void genMCP4725(){                                                                //==Функция: Генератор для DAC MCP4725;
   if(idCntMCP4725.reset){RT_HW_Base.counterReset(idCntMCP4725,4095,0,10,0);}     //--Инициал.счетчика: Upper limit=4095, Down limit=0, Change step=10, Initial value=0;
   if(RT_HW_Base.generatorEvent(idGenMCP4725,10)) {vMCP4725_vr=vGenMCP4725=RT_HW_Base.counterT(idCntMCP4725);}}; //--Генератор треугольника 10ms;
//-------------------------------------------------------------------------------------------------
void expMCP4725(){                                                                //==Функция: Управление    DAC MCP4725;  
if(dvMCP4725.custom==0){                                                          //--Настройка параметров устройства и задачи;
   dvMCP4725.custom=RT_HW_Base.i2cSetParam(dvMCP4725.dvI,i2cAdrMCP4725,0,800000); //  Настройка параметров: адрес i2c, номер шины, скорость;
                    RT_HW_Base.setTaskID(shMCP4725,'Q'); shMCP4725.period=0;}     //  Настройка задачи:  в каждом цикле при изменении во внешней функции; 
   RT_HW_Base.directTask(shMCP4725);                                              //--Управление задачей; 
   RT_HW_mcp4725.direct(dvMCP4725,vMCP4725_vr,shMCP4725.run );}                   //--Управление устройством;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void genMCP4725(){;};                                                             //==Функция: Заглушка вместо функции генератора для DAC MCP4725;
void expMCP4725(){;};                                                             //==Функция: Заглушка вместо функции управления     DAC MCP4725;  
#endif
//=================================================================================================
//                                     6.2.ADS1115.i2c;
//=================================================================================================
#ifdef RT_HW_TEST_PERMIT_ADS1115
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
RT_HW_ADS1115_DEV  dvADS1115;   RT_HW_STRUCT_SHED_TASK shADS1115;
//-------------------------------------------------------------------------------------------------
void expADS1115(){                                                                //==Функция: Управление ADS1115; 
if(dvADS1115.custom==0){                                                          //--Настройка параметров устройства и задачи;
   dvADS1115.custom=RT_HW_Base.i2cSetParam(dvADS1115.dvI,i2cAdrADS1115,0,800000); //  Настройка параметров: адрес i2c, номер шины, скорость;
   RT_HW_Base.setTaskID(shADS1115,'P',200);}                                      //  Настройка задачи: периодически='P', период=200ms; 
//------------------------------------------------------------------------------------------------
RT_HW_Base.directTask(shADS1115);                                                 //--Управление задачей;  
RT_HW_ads1115.direct(dvADS1115,shADS1115.run );                                   //--Управление устройством;
//-------------------------------------------------------------------------------------------------
if(dvADS1115.fresh){dvADS1115.fresh=0;                  vADS1115_ok=dvADS1115.ok; //--Обновление результатов измерения;
vADS1115_A0f=RT_HW_ads1115.getVar_V(dvADS1115,dvADS1115.vA0);  
vADS1115_A1f=RT_HW_ads1115.getVar_V(dvADS1115,dvADS1115.vA1); 
vADS1115_A2f=RT_HW_ads1115.getVar_V(dvADS1115,dvADS1115.vA2);  
vADS1115_A3f=RT_HW_ads1115.getVar_V(dvADS1115,dvADS1115.vA3);}};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else
void expADS1115(){;};
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                    8.ТЕСТОВЫЕ ФУНКЦИИ
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                    8.1.Формирование вектора состояний устройств
//=================================================================================================
void fncSetStatus(){
//------------------------------------------------------------------------------------------------
bitWrite(flagSystem,1,RT_HW_Base.shed.blink500);
//------------------------------------------------------------------------------------------------
bitWrite(flagDevice,0,vAHTxx_ok);
bitWrite(flagDevice,1,vSHT3x_ok);
bitWrite(flagDevice,7,vBH1750_ok);
bitWrite(flagDevice,30,vADS1115_ok);
};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                                     10.PLC RP2040 v.5.5
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//                                     10.1.Дискретный вывод
//=================================================================================================
#if defined(RT_HW_TEST_PERMIT_PLC_DOT)
RT_HW_74HC595_DEV        dv595PLC;         RT_HW_STRUCT_SHED_TASK sh595PLC;      
RT_HW_GENERATOR_EVENT_ID idGenDotPLC;      RT_HW_COUNTER_ID       idCntDotPLC;   uint16_t vDotPLC_cnt, vDotPLC_gen;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void genDotPLC(){                                                           //==Функция: Генератор для l2 дискретных выходов;
  if(idCntDotPLC.reset){RT_HW_Base.counterReset(idCntDotPLC,12,0,1,0);}     //--Инициализация счетчика: top=12, bottom=0, шаг изменения=1, начальное значение=0;
  if(RT_HW_Base.generatorEvent(idGenDotPLC,100)) {vDotPLC_cnt=RT_HW_Base.counterS(idCntDotPLC);  plcDOT_vr=vDotPLC_gen=RT_HW_Base.dc16(vDotPLC_cnt);}}; //--Пилa, бегущая "1", 12 разрядов;
void expDotPLC(){                                                           //==Функция: Дискретный вывод;                                           //==Функция: Управление дискретными выходами; 
  if(dv595PLC.custom==0){                                                     //--Настройка параметров устройства и задачи;
   dv595PLC.custom=RT_HW_Base.spiSetParam(dv595PLC.dvS,cs595PLC,0,4000000); //  Настройка параметров: cs, номер шины SPI, скорость;
   dv595PLC.mi='S'; dv595PLC.qnt=1;                                         //  Кол-во регистров 74HC595(1-4);
   dv595PLC.bitOrder=1;                                                     //  Последовательность вывода: =1 - впереди старший бит;
   RT_HW_Base.setTaskID(sh595PLC, 'Q',5);}                                  //--Вывод по изменениям с проверкой каждые 5 циклов программы; 
//----------------------------------------------------------------------------
   for(plcIdx=0; plcIdx<4; plcIdx++){RT_HW_Base.pinDigitalWrite(idDotPLC[plcIdx],pinDotPLC[plcIdx], bitRead(plcDOT_vr,plcIdx));} //--Вывод на пины;
//----------------------------------------------------------------------------
  RT_HW_Base.directTask(sh595PLC);
  if(sh595PLC.run){for(plcIdx=0; plcIdx<4; plcIdx++){RT_HW_Base.pinDigitalWrite(idDotPLC[plcIdx],pinDotPLC[plcIdx], bitRead(plcDOT_vr,plcIdx));}} //--Вывод на пины;
  uint8_t vr=plcDOT_vr>>4;
  RT_HW_74hc595.direct(dv595PLC,vr,sh595PLC.run);      
  pinDOT=plcDOT_vr;};
#else
void expDotPLC(){;};
#endif
//=================================================================================================
//                                     10.2. Дискретный ввод
//=================================================================================================
#if defined(RT_HW_TEST_PERMIT_PLC_DIN)
RT_HW_74HC165_DEV       dv165PLC;       RT_HW_STRUCT_SHED_TASK sh165PLC;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void expDinPLC(){  
if(dv165PLC.custom==0){
   dv165PLC.custom=RT_HW_Base.spiSetParam(dv165PLC.dvS,cs165PLC,0,4000000);
   dv165PLC.mi='S'; dv165PLC.qnt=1; dv165PLC.bitOrder=1;  //--qnt=Кол-во регистров 74HC595(1-4);
   RT_HW_Base.setTaskID(sh165PLC,'P',50);}                   //--Периодический вызов задачи: 'P';                      
   RT_HW_Base.directTask(sh165PLC); 
//-------------------------------------------------------------------------------------------------
   RT_HW_74hc165.direct(dv165PLC,sh165PLC.run); 
   if(dv165PLC.fresh)  {dv165PLC.fresh=0;  plcDIN_vr=dv165PLC.var<<4;
                        for(plcIdx=0; plcIdx<4; plcIdx++){bitWrite(plcDIN_vr,plcIdx,!RT_HW_Base.pinDigitalRead(idDinPLC[plcDIN_vr],pinDinPLC[plcDIN_vr]));} 
   pinDIN=plcDIN_vr;};
}; 
#else
void exp74DinPLC(){;};
#endif
