//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                                  TEST Modbus Slave RTU (HardWare)
//     *** Пояснения по Modbus в Gmodbus.hpp
//-------------------------------------------------------------------------------------------------
//    1.1.Настройка параметров в т.ч. тестовые пины, которые могут быть изменены.
//    1.2.В каждом цикле loop() вызывается "Диспетчер задач".
//    1.3.Каждую секунду обрабатываюся секундные параметры - быстродействие проекта, время наработки).
//    2.1.Инициализируется консоль (в терминах Arduino IDE - монитор порта). 
//    2.2.После готовности консоли (проверка консоли особо критична для контроллеров с USB на кристалле - STM32,Raspberry Pi,ESP32-C3,S2,S3),
//        в монитор порта однократно выводяся отчет о проекте (пины, наличие коммуникаций и др.),
//        сканируется шина i2c (SDA,SCL необходимо подтянуть к Vcc резисторами 10-47к).
//    3.1.В каждом цикле loop() меняется значение на пине Control (для логического анализатора).
//    3.2.На пин Led выводится меандр 500ms.
//    4.1.Периодически читается пин ADC(period 100ms). Отфильтрованное значение ADC выводится на пин PWM.
//    4.2.Читается значение пина "Кнопка" с защитой от дребезга 50ms.
//    5.  Сенсоры через пины: DS1820,HC-SR04;
//    6.  Сенсоры через i2c:  AHTxx(T,H),SHT3x(T,H); 
//    7.  Расширитель выходов через SPI 74HC595 "Бегущая 1" ;
//    8.  Расширитель входов  через SPI 74HC165, чтение в переменную v74HC165;
//    10. Вывод на Lcd1.i2c(0x27)
//          Кнопка=0:  строка 1:Blink(*),ADC, Регистр Holding=40, ,Speed.
//                     строка 2:AHTxx.ok,AHTxx.Temp,AHTxx.Hum.  
//          Кнопка=1:  строка 1:Blink(#),DS1820.ok,DS1280.Temp,HC-SR04.ok,HC-SR04.Len;
//                     строка 2:SHT3x.ok,SHT3x.Temp,SHT3x.Hum. 
//    11.Устройства могут отключаться через комментирование(//) определений RT_HW_TEST_PERMIT_xxx.
//-------------------------------------------------------------------------------------------------
// ecoins@mail.ru 20.01.2024
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                    0.Разрешения использования устройств
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
  #define RT_HW_TEST_PERMIT_AHTx        //--Разрешение использования сенсора SHT3x; 
  #define RT_HW_TEST_PERMIT_SHT3x       //--Разрешение использования сенсора SHT3x;
  #define RT_HW_TEST_PERMIT_BH1750      //--Разрешение использования сенсора BH1750;
  #define RT_HW_TEST_PERMIT_DS1820      //--Разрешение использования сенсора DS1820;
  #define RT_HW_TEST_PERMIT_SR04        //--Разрешение использования сенсора HC-SR04;
  #define RT_HW_TEST_PERMIT_74HC595     //--Разрешение использования расширителя 74HC595; 
  #define RT_HW_TEST_PERMIT_74HC165     //--Разрешение использования расширителя 74HC165;  
  #define RT_HW_TEST_PERMIT_ADS1115     //--Разрешение использования расширителя ADS1115(i2c);  
  #define RT_HW_TEST_PERMIT_LCD1_i2c    //--Разрешение подключения дисплея Lcd1.i2c  16x2;
//=================================================================================================
//                    1.Подключение библиотек
//=================================================================================================
  #include "flprogModbusRTU.h"          //--Подключение библиотеки ModBus RTU (Включает #include RT_HW_BASE.h");
  #include "RT_HW_LCD44780.h"           //--Подключение библиотеки дисплеев типа HD44780;
  #include "RT_HW_SENSORS.h"            //--Подключение библиотек базовых сенсоров(DS1820,HC-SR04,AHTx,BH1750,SHT3x);
  #include "RT_HW_EXPANDERS.h"          //--Подключение библиотек базовых расширителей(ADS1115,74HC595,74HC165);
//=================================================================================================
//                    2.Подключение внутренних вкладок
//=================================================================================================
  #include "Asys.hpp"                   //--Системные объекты,параметры,функции; 
  #include "Cdevice.hpp"                //--Устройства(сенсоры, расширители);  
  #include "Lcd1.hpp"                   //--Подключение вкладки Lcd1(i2c) 16x2;         
//=================================================================================================

//=================================================================================================
//                                    I.Секция SETUP()
//=================================================================================================
void setup(){}
//=================================================================================================
//                                    II.Секция LOOP()
//=================================================================================================
void loop(){
//================================================================================================= 
//                     2.1.Инициализация параметров и диспетчер
//================================================================================================= 
  initProject();                                //--Инициализация параметров;
  RT_HW_Base.sheduler(shed);                    //--Диспетчер задач(CORE0);
//================================================================================================= 
//                     2.2.Управление консолью
//=================================================================================================
if(shed.frdm.num==1){ 
  RT_HW_Base.consoleBegin();                    //--Инициализация консоли;
  if(RT_HW_Base.console.head){consoleHead();}   //--Однократный вывод отчета по MC;  
}
//================================================================================================= 
//                    2.3.Обработка секундных событий
//=================================================================================================
if(shed.eventSec){                              //--Обработка секундных событий:
  vSpeedMCU=shed.cycle;                         //  кол-во циклов в сек;
  vSpeedMCUF=FilterSpeed.filtered(vSpeedMCU);   //  кол-во циклов в сек с фильтром; 
  vSpeedSmall=round(((float)vSpeedMCUF)/1000);  //  кол-во циклов в сек с фильтром/1000;
  vMotorSec=shed.cntSec;                        //  кол-во секунд с начала работы программы;
  RT_HW_Base.unixID.timeUNIX++;                 //--Инкремент UNIX времени;
  RT_HW_Base.unixGetTotal();                    //--Получение времени,даты,дня недели;
} //--END if(shed.eventSec);
//================================================================================================= 
//                    2.4.Системные пины (console,Led,Button,ADC,флаги системные и устройств)
//=================================================================================================
  RT_HW_Base.pinDigitalWrite(idPinControl,pinControl,shed.control); //--Вывод цикла loop() на контрольный пин; 
  RT_HW_Base.pinDigitalWrite(idPinLed,    pinLed,    shed.blink500);//--Вывод меандра 500 ms на светодиод; 
  if(shed.quick.num==1) {fncButton();}                              //--Чтение кнопки с защитой от дребезга;
  if(shed.quick.num==2) {fncADC();}                                 //--Чтение ADC;  
  if(shed.frdm.num==4)  {fncSetStatus();}                           //--Установка флагов системных и устройств; 
  if(shed.slow.num==1)  {fncCounter();}                             //--Тестовый счетчик;
//================================================================================================= 
//                    2.5.Устройства (сенсоры,расширители)
//=================================================================================================
  if(shed.frdm.num==20){snsDS1820();}             //--pin.DS1820. При опросе задержка 4-6 ms;   
  if(shed.frdm.num==22){snsSR04();}               //--pin.HC-SR04(по прерываниям); 
  if(shed.frdm.num==24){snsAHTxx();}              //--i2c.AHTxx;
  if(shed.frdm.num==26){snsSHT3x();}              //--i2c.SHT3x;
  if(shed.frdm.num==28){snsBH1750();}             //--i2c.BH1750
  if(shed.frdm.num==30){expADS1115();}            //--i2c.Аналоговый ввод  с  ADS1115 (16-разрядный ADC, 4 канала);
  if(shed.frdm.num==32){exp74HC595();}            //--SPI.Дискретный вывод на 74HC595;  
  if(shed.frdm.num==34){exp74HC165();}            //--SPI.Дискретный ввод  с  74HC165; 
//=================================================================================================
//                   2.6.ДИСПЛЕИ
//=================================================================================================
  if(shed.frdm.num==40){Lcd1();}                 //--Output Lcd1(16x2,i2c,0x27);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
//                     3.1.Управление Modbus Slave RTU1
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//================================================================================================= 
//                     3.1.УПРАВЛЕНИЕ Modbus Slave RTU1
//=================================================================================================
if(shed.frdm.num==10){
if(MbSlaveRTU1_custom==0){    //--Однократные действия
   MbSlaveRTU1_custom=1;
//------------------------------------------------------------------------------------------------- 
//                                3.1.1.Настройка UART
//-------------------------------------------------------------------------------------------------
  MbSlaveRTU1_numUART=RT_HW_Base.device.uart.modbus2; //--Определение     номера UART RTU Slave Master из описания контроллера;
//MbSlaveRTU1_numUART=3;                              //--Переопределения номера UART RTU Slave Master (при необходимости);
  SlaveRTU1.setUart(MbSlaveRTU1_numUART);             //--Установка       номера UART RTU Slave Master;
  SlaveRTU1.setSpeedUart(FLPROG_SPEED_115200);        //--Установка скорости                   [default=9600];
  SlaveRTU1.setDataBitUart(8);                        //--Установка кол-ва бит данных (5,7,8)  [default=8];
  SlaveRTU1.setStopBitUart(1);                        //--Установка количество стоп-бит(0,1,2) [default=1];
  SlaveRTU1.setParityUart(0);                         //--Устан.четности:0=NONE, 1=EVEN, 2=ODD [default=0];
  SlaveRTU1.setSlaveAddress(MbSlaveRTU1_ID);          //--Определение адреса(ID) Slave(ID=1);
//-------------------------------------------------------------------------------------------------
//                               3.1.2.Задание областей памяти ModBus
//-------------------------------------------------------------------------------------------------
  SlaveRTU1.configDataTable(FLPROG_HOLDING_REGISTR,50);     //--10 регистров типа HOLDING REGISTER, стартовый адрес=0 (адреса 0-39);
  SlaveRTU1.configDataTable(FLPROG_INPUT_REGISTR,  10);     //--10 регистров типа INPUT   REGISTER, стартовый адрес=0 (адреса 0-9);
  SlaveRTU1.configDataTable(FLPROG_COIL,           15, 5);  //--15 регистров типа COIL,             стартовый адрес=5 (адреса 5-14);
  SlaveRTU1.setDataTable   (FLPROG_DISCRETE_INPUT, 10,MbSlaveRTU1_DI_Adr); //--10 регистров типа DISCRETE INPUT, с адресами в соответствии с таблицей;  
//-------------------------------------------------------------------------------------------------  
} //--END if(MbSlaveRTU1_custom==0)  
//-------------------------------------------------------------------------------------------------
//                               3.1.4.Управление ModBus Slave RTU1
//-------------------------------------------------------------------------------------------------
  SlaveRTU1.pool();
}
//================================================================================================= 
//                    3.2.Запись в таблицу битовых значений COIL (кол-во COIL=16, начальный адрес=5)
//=================================================================================================
if(shed.quick.num==1){
  SlaveRTU1.saveBool(saveBlink,           FLPROG_COIL, 5);    //--Blink 1 сек;
  SlaveRTU1.saveBool(shed.blink250,       FLPROG_COIL, 6);    //--Меандр 250ms;
  SlaveRTU1.saveBool(shed.blink500,       FLPROG_COIL, 7);    //--Меандр 500ms;
  SlaveRTU1.saveBool(vChatBut,            FLPROG_COIL, 8);    //--Кнопка на плате;   
};
//-------------------------------------------------------------------------------------------------
//                     3.2.3.Запись в таблицу Holding Registers быстрых int16
//-------------------------------------------------------------------------------------------------
if(shed.quick.num==2){
  SlaveRTU1.saveInteger(saveInt16,     FLPROG_HOLDING_REGISTR, 0);
  SlaveRTU1.saveInteger(vADCF,         FLPROG_HOLDING_REGISTR, 1);
  SlaveRTU1.saveInteger(vSR04Len,      FLPROG_HOLDING_REGISTR, 2);
  SlaveRTU1.saveInteger(vBH1750Lux,    FLPROG_HOLDING_REGISTR, 3);
  SlaveRTU1.saveInteger(v74HC165,      FLPROG_HOLDING_REGISTR, 4);
  SlaveRTU1.saveInteger(flagSystem,    FLPROG_HOLDING_REGISTR, 5); 
  SlaveRTU1.saveInteger(flagDevice,    FLPROG_HOLDING_REGISTR, 6);   
};
//-------------------------------------------------------------------------------------------------
//                     3.2.3.Запись в таблицу Holding Registers медленных int32
//-------------------------------------------------------------------------------------------------
if(shed.slow.num==1){
  SlaveRTU1.saveInteger     (RT_HW_Base.unixID.hours,   FLPROG_HOLDING_REGISTR, 7);
  SlaveRTU1.saveInteger     (RT_HW_Base.unixID.minutes, FLPROG_HOLDING_REGISTR, 8);
  SlaveRTU1.saveInteger     (RT_HW_Base.unixID.seconds, FLPROG_HOLDING_REGISTR, 9);  
  SlaveRTU1.saveUnsignedLong(vMotorSec,                 FLPROG_HOLDING_REGISTR,10);
  SlaveRTU1.saveUnsignedLong(RT_HW_Base.unixID.timeUNIX,FLPROG_HOLDING_REGISTR,12);  
};
//-------------------------------------------------------------------------------------------------
//                     3.2.4.Запись в таблицу Holding Registers медленных float
//-------------------------------------------------------------------------------------------------
if(shed.quick.num==2){
  SlaveRTU1.saveFloat(vADS1115_A0f, FLPROG_HOLDING_REGISTR, 30);
  SlaveRTU1.saveFloat(vADS1115_A1f, FLPROG_HOLDING_REGISTR, 32);
  SlaveRTU1.saveFloat(vADS1115_A2f, FLPROG_HOLDING_REGISTR, 34);
  SlaveRTU1.saveFloat(vADS1115_A3f, FLPROG_HOLDING_REGISTR, 36);   
};
//-------------------------------------------------------------------------------------------------
//                     3.2.5.Запись в таблицу Holding Registers медленных float
//-------------------------------------------------------------------------------------------------
if(shed.slow.num==2){
  SlaveRTU1.saveFloat(vAHTxx_Temp, FLPROG_HOLDING_REGISTR, 20);
  SlaveRTU1.saveFloat(vAHTxx_Hum,  FLPROG_HOLDING_REGISTR, 22);
  SlaveRTU1.saveFloat(vSHT3x_Temp, FLPROG_HOLDING_REGISTR, 24);
  SlaveRTU1.saveFloat(vSHT3x_Hum,  FLPROG_HOLDING_REGISTR, 26);
  SlaveRTU1.saveFloat(vDS1820Temp, FLPROG_HOLDING_REGISTR, 28);       
};
//-------------------------------------------------------------------------------------------------
//                     3.2.6.Чтение из таблицу Holding Registers медленных int16
//-------------------------------------------------------------------------------------------------
if(shed.slow.num==2){
  rg0=SlaveRTU1.readInteger(FLPROG_HOLDING_REGISTR, 40);    
};
//-------------------------------------------------------------------------------------------------
//  lastError = SlaveRTU1.getLastError();  //--Получение последней ошибки MB SlaveRTU1;
//
};    //--End loop();
