 #include "RT_HW_BASE.h"
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//						1.Структуры для работы с устройствами
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	
//=================================================================================================
//						1.1.Структура рабочих буферов (объекты создаются в RT_HW_BASE.h)
//=================================================================================================				  
struct RT_HW_STRUCT_BUFF	{
	uint8_t  bf8, ba8;
    uint8_t  arr[10]; 			//--Рабочий массив;
	char chr; 							 
    int8_t i,j,m;				//--Рабочие индексы
	uint32_t bf32;
#if defined(RT_HW_PERMIT_ETH)
  IPAddress ip;					//--Рабочий IP адрес;
#endif							 				 							 
};
//=================================================================================================
//						1.0.Структура параметров платы (include to RT_HW_STRUCT_DEVICE)
//=================================================================================================
struct RT_HW_STRUCT_BOARD{
	uint32_t id=0xC02F4478;		//--ID проекта(получает случайное значение при компиляции проекта;		                       
	uint8_t  blockCheckPin=1;	//--Флаги блокировки проверки допустимости использования пина:				 
    uint8_t  depth=12;			//--Системное разрешение для нормализация параметров ADC,TOUCH,PWM,DAC;
};
//=================================================================================================
//						1.1.Структура для работы с DIN
//=================================================================================================	
struct RT_HW_STRUCT_DIN{
};
//=================================================================================================
//						1.2.Структура для работы с ADC
//=================================================================================================			
struct RT_HW_STRUCT_ADC{
	uint8_t  depth;				//--Разрешение ADC;
	uint8_t  driftVar=0;		//--Допустимый дрейф показаний ADC;
	uint8_t  driftNull=0; 		//--Допустимый дрейф нуля ADC;
};
//=================================================================================================
//						1.3.Структура для работы с TOUCH
//=================================================================================================			
struct RT_HW_STRUCT_TCH{
#if defined(RT_HW_PERMIT_TCH)
	uint8_t  depth;				//--Разрешение ADC;
#endif
};
//=================================================================================================
//						1.4.Структура для работы с DOT
//=================================================================================================	
struct RT_HW_STRUCT_DOT{
};
//=================================================================================================
//						1.5.Структура для работы с PWM
//=================================================================================================
struct RT_HW_STRUCT_PWM{
	uint8_t  depth;				//--Разрешение PWM;
#if defined(RT_HW_CORE_ESP32)	
	uint8_t  idx; 				//--Рабочий индекс;
	uint8_t  qntChannel=16; 	//--Макс.кол-во каналов (ESP32);
	uint16_t channel; 			//--Биты занятости каналов;
	uint16_t freq;				//--Частота PWM;
#endif
}; 
//=================================================================================================
//						1.6.Структура для работы с DAC
//=================================================================================================			
struct RT_HW_STRUCT_DAC{
#if defined(RT_HW_PERMIT_DAC)
	uint8_t  depth;				//--Разрешение ADC;
#endif
};		
//=================================================================================================
//						1.9.Структура для работы с ETHERNET
//=================================================================================================	
struct RT_HW_STRUCT_ETH{
#if defined(RT_HW_PERMIT_ETH) || defined(RT_HW_PERMIT_ETH0)
  IPAddress ip0;					//--ip адрес для Ethernet0;
#endif
#if defined(RT_HW_PERMIT_ETH1) 
  IPAddress ip1;					//--ip адрес для Ethernet0;
#endif
};
//=================================================================================================
//						1.10.Структура для работы с WiFi
//=================================================================================================	
struct RT_HW_STRUCT_WFI{
#if defined(RT_HW_PERMIT_WFI) 
  IPAddress ipw;					//--ip адрес для Wi-Fi;
#endif
};
//=================================================================================================
//						1.6.Структура для работы с таймерами 
//=================================================================================================
struct RT_HW_STRUCT_TIMER{
#if defined(RT_HW_CORE_ESP32)
	uint8_t  qnt=16; 			//--Максимальное кол-во таймеров;       
	uint16_t busy=0;			//--Биты занятости каналов;
#endif
};
//=================================================================================================
//						1.10.Временная заглушка для совместимости с FLProgWiznetClass
//=================================================================================================
struct RT_HW_STRUCT_SPI{
    uint8_t busETH=255;  
    uint8_t csETH=255;   
};




//=================================================================================================
//						1.10.Обобщенная структура системных устройств (объект создается в RT_HW_BASE.h)
//=================================================================================================
struct RT_HW_STRUCT_DEVICE{
RT_HW_STRUCT_BOARD      brd;	//--Параметры контроллера (архитектура,ID и пр.);
RT_HW_STRUCT_ADC 		adc;	//--Для ADC;
RT_HW_STRUCT_TCH 		tch;	//--Для TOUCH ESP32;
RT_HW_STRUCT_PWM 		pwm;	//--Для PWM ESP32;
RT_HW_STRUCT_DAC 		dac;	//--Для DAC;
RT_HW_STRUCT_ETH 		eth;	//--Для Ethernet;
RT_HW_STRUCT_WFI 		wfi;	//--Для Wi-Fi;
RT_HW_STRUCT_TIMER  	tmr;  	//--Timer->макс.кол-во таймеров,биты занятости таймеров; 
RT_HW_STRUCT_SPI        spi;    //--SPI: Временная заглушка для совместимости с FLProgWiznetClass;
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//						2.Структуры для управления задачами 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//						2.1.Вспомогательная структура для диспетчера задач
//=================================================================================================
struct RT_HW_STRUCT_SHAD{
 uint8_t  num=0; 		//--номер задачи как событие; 
 uint8_t  cnt=0;		//--текущий счетчик задач(рабочий параметр);
 uint8_t  qnt=5;		//--максимальное кол-во задач;
};
//=================================================================================================
//						2.2.Cтруктура для диспетчера задач
//		CORE0 - ядро MCU основное. Поддерживается в секциях: void setup();  void loop();
//		CORE1 - ядро MCU второе.   Поддерживается в секциях: void setup1(); void loop1();
//=================================================================================================
struct RT_HW_STRUCT_SHED{
  RT_HW_STRUCT_SHAD 	
		 tick,							//--Параметры миллисекундных задач;
		 quick, 						//--Параметры оперативной задачи;
		 fast,  						//--Параметры быстрой     задачи;
		 slow,  						//--Параметры медленной   задачи;
		 back,  						//--Параметры фоновой     задачи;
		 frdm,							//--Параметры свободной   задачи;
		 frdm1;							//--Параметры свободной   задачи для loop1();		 
//-------------------------------------------------------------------------------------------------
  uint8_t  ready=0;                    	//--Флаг запуска проекта ready.
  uint8_t  blink1=1,blink10=1,blink25=1,blink50=1,blink100=1,blink250=1,blink500=1,blinkSec=1; //--Состояние меандров 10,25,50,100,250,500,1000ms;
  uint8_t  eventSec=1;					//--Событие 1 сек;
  uint8_t  event=0,run=0; 				//--Рабочие флаги
//-------------------------------------------------------------------------------------------------
  uint32_t cntSec=0;					//--Счетчик секунд с начала запуска программы [Мотосекунды];
  uint8_t  initParam=0;					//--Состояние инициализации параметров проекта (для использования пользователем);
//-------loop() CORE0 -----------------------------------------------------------------------------
  uint8_t  control=1;					//--Изменение в каждом цикле loop()  (для наблюдения на пине логическим анализатором);
  uint32_t cycle; 						//--Кол-во циклов loop()       в сек (Быстродействие CORE0 в кол-ве циклов loop()/сек);
  uint16_t smallCycle;    				//--Кол-во циклов loop()/1000  в сек (Быстродействие CORE0 в кол-ве циклов loop()/1000/сек);
  uint32_t cntCycle=0;    				//--Рабочий счетчик для расчета кол-во циклов loop();
//-------loop1()------------------------------------------------------------------------------------
  uint8_t  isLoop1=0;					//--Флаг наличия  loop1() (для MCU c дополнит.ядром  CORE1 [RP2040,...]); 
  uint8_t  freshSec1=0;					//--Флаг события секунды для вычисления быстродействия loop1;
  uint8_t  control1=1;					//--Изменение в каждом цикле loop1() (для наблюдения на пине логическим анализатором);
  uint32_t cycle1; 						//--Кол-во циклов loop1()      в сек (Быстродействие CORE1 в кол-ве циклов loop1()/сек);
  uint16_t smallCycle1;    				//--Кол-во циклов loop1()/1000 в сек (Быстродействие CORE1 в кол-ве циклов loop1()/1000/сек);
  uint32_t cntCycle1=0;    				//--Рабочий счетчик для расчета кол-ва циклов loop1();

//-------------------------------------------------------------------------------------------------
  uint32_t timeStart1=1, timeStart10=0, timeStart25=0;//--Рабочие таймеры для периодов 10 и 2ms; 
  uint8_t  workSec;						//--Рабочий параметр;
  uint8_t  cnt50=0, cnt100=0, cnt250=0; //--Рабочие счетчики событий 50,100,250ms
};  	
//=================================================================================================
//                  	2.3.Структура управления задачами
// Работает совместно с функциями directTask и при необходимости с SetTaskID
//	(uint8_t)periodLimit - ограничение частоты вызова в циклах вхождения в функцию [режимы С,A]; default=5;
//  (uint16_t)periodTask - период вызова в мс [режимы P,T,A] default=1000;
//  Режимы запуска: 
//	 'C'-запуск по внешним условиям(например изменения входных параметров для расширителя) 
//       с ограничением частоты вызова в циклах вызова функции[periodLimit];
//   'P'-периодический безусловный запуск;       
//   'T'-периодический запуск по внешним условиям(как в режиме 'C')
//	 'A'-запуск по внешним условиям(как в режиме'C') или периодически 
//       (обычно с большим периодом для повышения устойчивости проекта); 		
//   'Q'-запуск в каждом цикле по внешним условиям (для быстрых процессов и для тестирования);
//   'E'-запуск в каждом цикле. Может быть использован для управления через вход EN, 
//       в т.ч. для периодического вызова события=1 на входе EN;
//   'F'-однократное выполнение. Для повтора можно установить id.first=1;
//
//   'N'-запуск отключен;
//  Вход:
//  run-может устанавливаться внешней функцией. run=5 -означает, что функция запущена на выполнение;
//  Выходы:
//  run-  =0 нет запуска; 
//        =1 безусловный запуск; 
//        =2 будет запуск проверке условий  внешней функции (например по изменению выводимого параметра);
//=================================================================================================
struct RT_HW_STRUCT_SHED_TASK{                    //--Управление задачами полный
uint8_t  custom=0;    
char    mode='C'; 				//--Режим задачи: 
uint16_t period=1000; 
uint16_t Period=2500; 		//--Период
uint8_t  cntLimit=0;  uint8_t periodLimit=5; 
uint8_t  first=1;								//--Флаг первого запуска;     
uint8_t  agoEN=1;  uint8_t extEN=1;  uint8_t run=0;     
uint32_t timeBegin; 
uint32_t TimeBegin;       
};
//=================================================================================================
//                  	2.4.Структура для функции динамической задержки 
//=================================================================================================
struct RT_HW_STRUCT_TIME{                    
uint32_t startTime,curTime;		//--Переменные для работы со временем;
uint16_t sizeDelay;				//--Время задержки;
uint8_t  state=0;				//--Состояние функции (1 - ожидание завершение задержки);
uint8_t  pointTime; 			//--Точка возрата из функции(для пользовательского использования);
};
//=================================================================================================

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//						3.Структуры работы с UNIX временем
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	
//=================================================================================================
//					    3.1.Cтруктура для работы с UNIX временем
//                    (объект с именем unixTime создается в RT_HW_BASE.h)
//=================================================================================================
struct   RT_HW_STRUCT_UNIX_ID{
uint32_t timeUNIX_NTP=0, 			//--1.Время от NTP  в сек от 01.01.1970г. по Гринвичу;
		 timeUNIX,  				//--2.Время текущее в сек от 01.01.1970г. по Гринвичу;
		 timeZone;					//--3.Время текущее в сек от 01.01.1970г. по часовому поясу;
uint8_t  zone:4,					//--4.Номер часового пояса.
		 freshHours:1,freshDay:1, 	//--5.Флаг обновления часов,дней;
		 fresh:1;					//--6.Флаг обновления часов и/или дней;
uint8_t  hours,minutes,seconds;		//--7.Время:часы,минуты,секунды;
uint8_t  weekDay,day,month,year;    //--8.Дата: день,месяц,день недели,две младших цифры в годе;						
};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//						4.Структуры работы с консолью и сообщениями
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	
//=================================================================================================
//						4.1.Структура для работы с консолью (объект создается в RT_HW_BASE.h)
// dir-этапы настройки консоли; 
// ok-флаг готовности консоли; 
// head-флаг разрешения вывода заголовков (включается на один цикл при ok=1); 
// all-разрешение вывода после вывода заголовков;
// numUart: =0-8-аппаратные UART; =9-программный UART;  
// 
//=================================================================================================
struct RT_HW_STRUCT_CONSOLE {
uint8_t dir=0; 
uint8_t run=0;
uint8_t ok=0; 
uint8_t head=0; 
uint8_t all=0; 
uint8_t numUart=0; 
//uint8_t bf8; 
uint8_t i; 
uint8_t idxOk,idx;
uint8_t lenText,lenBuff;
//uint8_t arr[10];
};
//=================================================================================================
//						4.2.Структуры для работы с сообщениями (объект создается в RT_HW_BASE.h)   
//=================================================================================================	
struct RT_HW_STRUCT_MESS {
uint8_t size=0;					//--Размер формируемого поля;
char 	agoAlig,    alig='L';  	//--Выравнивание в поле ('N',L','C','R');
char 	agoBlank,   blank=' ';	//--Код символа заполнителя;
char 	agoSignBit, signBit='1';//--Код набора символов  при выводе в битовой форме ('0','1'...'9');
char 	orderBit='F'; 			//--Порядок вывода битов при выводе в битовой форме;  
char 	modePin='T';   			//--Форматы вывода номера пина: D-десятичный, T-текстовый,   A-комбинированный;
char 	modeAdr='T';   			//--Форматы вывода адреса  i2c: D-десятичный, H-шестнадцат., A-комбинированный;
char    modeVar='B';			//--Формат переменной B,W,L,F,R,C,S;
char    mode='Z';				//--Формат вывода P,A,X,T,C,F,B,H,U,I,Z,z,0,1,2,3;
char    suff='~';				//--Суффикс;
char    separator=',';			//--Разделитель. Используется при выводе массивов;
uint8_t qntBit=8;				//--Кол-во выводимых бит при выводе в битовой форме;
//--------------------------------------------------------------------------------------------------
uint8_t lenPin=3;	  			//--Длина поля для выводимого пина;
uint8_t lenSuff,lenCR,hexShort=0;//--Длина mess.str,длины заполнителей до и после mess.str;
uint8_t lenVar,lenBegin,lenEnd;	//--Длины заполнителей до и после mess.str;
uint8_t bf8;					//--Рабочий регистр;
uint8_t index;					//--Индекс для выбора символов RT_HW_READ_BYTE_PGM(RT_HW_ARR_BOOL_SIGN_x,index);
uint8_t idx;					//--Рабочий индекс для реализации циклов;
uint8_t adx=255;				//--Индекс для вывода массивов переменных;
uint8_t qnt;					//--Рабочее кол-во; 
String  str;			    	//--Формируемая строка;
};
//=================================================================================================	



















//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//						4.Структура для преобразования числа в символы
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
struct RT_HW_BASE_VAL_ID {uint32_t val; uint16_t len:4, index:4, num:4, mess:4; uint8_t mode:2,minus:1,point:2,pnt:1;};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//						5.Структура для callback
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
typedef void(*CallBack)(void);
//=================================================================================================


