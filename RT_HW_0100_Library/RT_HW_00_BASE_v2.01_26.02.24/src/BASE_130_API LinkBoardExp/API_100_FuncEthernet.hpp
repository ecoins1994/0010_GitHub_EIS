//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                  1. MAC-адрес
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//						   		1.1. Генератор случайного MAC-адреса
//  Три старших байта определяются в параметрах(default=0x78,0xAC,0xC0);
//  Три младших байта получает из генератоа случайных чисел с дополнительным параметров base(default=0);
//	mac - указатель на целевой массив uint8_t [6] для MAC-адреса;
//=================================================================================================
void ethGenMacAddr(uint8_t *mac, uint8_t base=0, uint8_t b0=0x78, uint8_t b1=0xAC, uint8_t b2=0xC0)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint32_t  bf32;
#endif
//-------------------------------------------------------------------------------------------------
  bf32=genRandom(24, base); 
  mac[0]=b0; 				 mac[1]=b1; 			    mac[2]=b2;
  mac[3]=(bf32>>16)&0xFF;  mac[4]=(bf32>> 8)&0xFF;	mac[5]=bf32&0xFF;
};
//=================================================================================================
//								1.2. Переустановка MAC-адреса.
//	Возвращает 1, если MAC-адрес изменился.
//=================================================================================================
uint8_t ethApplyMac(uint8_t m0, uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t m5, uint8_t *target)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint32_t  bf8;
#endif
//-------------------------------------------------------------------------------------------------
  if(target[0]!=m0){target[0]=m0; bf8=1;}
  if(target[1]!=m1){target[1]=m1; bf8=1;}
  if(target[2]!=m2){target[2]=m2; bf8=1;}
  if(target[3]!=m3){target[3]=m3; bf8=1;}
  if(target[4]!=m4){target[4]=m4; bf8=1;}
  if(target[5]!=m5){target[5]=m5; bf8=1;}
  return bf8;
};
//=================================================================================================
//								1.3. Парсинг строки с MAC-адресом в целевой массив из 6-ти байт.
//=================================================================================================
void ethParseMacAdrString(String str, uint8_t *target)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  j,m;
  uint8_t  arr[6];
#endif
//-------------------------------------------------------------------------------------------------
  for(m=0; m<6; m++){arr[m]=255;}						//--Заполнение буферного массива;	
  m=0;  												//--Очистка индекса index.m(индекс i используется ethHexStrToInt();	
  str.toUpperCase();									//--Строка с прописными значениями;
//-------------------------------------------------------------------------------------------------
  while((str.length()>0) && (m<6)){						//==ПАРСИНГ строки:
      j=str.indexOf(':');								//--Возвращает номер 1-го разделительного символа в строке; 
   if(j==1){arr[m]=(uint8_t)(ethHexStrToInt(str));                str="";}
   else    {arr[m]=(uint8_t)(ethHexStrToInt(str.substring(0,j))); str=str.substring(j+1);}	 
   m++;}												//--Увеличение индекса;
//-------------------------------------------------------------------------------------------------
  if(ethCheckMacAdr(arr)){								//--Обновление MAC-адреса 
   for(m=0; m<6; m++){target[m]=arr[m];}} 				//--в целевом массиве target;
//-------------------------------------------------------------------------------------------------
};
//=================================================================================================
//								1.4. Получение строки с MAC-адрес из целевого массива
//=================================================================================================
String ethMacAdrToString(uint8_t *target)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i;
#endif
//-------------------------------------------------------------------------------------------------
  mess.str="";											//--Очистка целевого буфера;
  for(i=0; i<6; i++){									//--Цикл на 6 действий; 
   if(String(target[i],HEX).length()<2){mess.str+='0';} //--Добавление значащего нуля;
   mess.str+=String(target[i],HEX);						//--Добавление HEX-значения;
   if(i<5) {mess.str+=':';}}							//--Добавления разделителя;
  mess.str.toUpperCase();								//--Строка с прописными значениями;
  return mess.str;										//--Возвращает строку с MAC-адресом;
};
//=================================================================================================
//								1.5. Проверка достоверности MAC-адреса (целевой массив)
//  Возвращает 1 если в MAC-адресе отсутствуют значения 255.
//=================================================================================================
uint8_t ethCheckMacAdr(uint8_t *target)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i;
#endif
//-------------------------------------------------------------------------------------------------
  for(i=0; i<6; i++){if(target[i]==255){return 0;}} return 1;
};
//=================================================================================================
//								1.6. Проверка достоверности MAC-адреса (строка)
//  Возвращает 1 если в MAC-адресе отсутствуют значения 255.
//=================================================================================================
uint8_t ethCheckMacAdrString(String str)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)					//==Если контроллер не многоядерный;
  uint8_t  i;
  uint8_t  arr[6];  
#endif
//-------------------------------------------------------------------------------------------------
  for(i=0; i<6; i++){arr[i]=255;}			//--Заполнение буферного массива;
  ethParseMacAdrString(str, arr);			//--Парсинг строки в массив buff.arr;
  return ethCheckMacAdr(arr);				//--Возвращает результат проверки MAC-адреса;
};
//=================================================================================================
//								1.7. Сравнение MAC-адреса(целевой массив) с MAC-адресом(строка)
//  Возвращает 1 при совпадении адресов.
//=================================================================================================
uint8_t ethCompareMacAdrWithString(uint8_t *target, String str)
{
  return str.equals(ethMacAdrToString(target));
};
//=================================================================================================
//								1.8. Сравнение MAC-адреса(целевой массив 1) с MAC-адресом(целевой массив 2)
//  Возвращает 1 при совпадении адресов.
//=================================================================================================
uint8_t ethCompareMacAdr(uint8_t *target1, uint8_t *target2)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i; 
#endif
//-------------------------------------------------------------------------------------------------
  for(i=0; i<6; i++){if (target1[i]!=target2[i]){return 0;}}
  return 1;
};
//=================================================================================================
//								1.9. Копирование MAC-адреса(целевой массив 1) в MAC-адрес(целевой массив 2)
//  Возвращает 1 при совпадении адресов.
//=================================================================================================
void ethCopyMacAdr(uint8_t *target1, uint8_t *target2)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i; 
#endif
//-------------------------------------------------------------------------------------------------
  for(i=0; i<6; i++){target1[i]=target2[i];}
};
//=================================================================================================
//								1.9. Конвертирование старших 3-байт MAC-адреса -> uint32_t
//  Возвращает 1 при совпадении адресов.
//=================================================================================================
uint32_t ethGetMacAdrHigh(uint8_t *target)
{
  return (((uint32_t)target[0]<<16) | ((uint16_t)target[1]<<8) | target[2]);
};
//=================================================================================================
//								1.10. Конвертирование младших 3-байт MAC-адреса -> uint32_t
//  Возвращает 1 при совпадении адресов.
//=================================================================================================
uint32_t ethGetMacAdrLow(uint8_t *target)
{
  return (((uint32_t)target[3]<<16) | ((uint16_t)target[4]<<8) | target[5]);
};

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                  2. IP-адрес
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//								2.1. Конвертирование char[] -> IP ???
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
uint8_t ethInet_aton(const char *address, IPAddress &result)
{
    uint16_t acc = 0;
    uint8_t dots = 0;
  while(*address){
    char c = *address++;
    if (c >= '0' && c <= '9'){acc = acc * 10 + (c - '0');if (acc > 255){return 0;}}
    else if(c == '.'){
              if (dots == 3){return 0;}
              result[dots++] = acc;
              acc = 0;}
			  else		 {return 0;}}
  if (dots != 3){return 0;}
  result[3] = acc;
  return 1;
};
#endif
//=================================================================================================
//								2.2. Конвертирование IP -> target[4]
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
void ethIptoArray(IPAddress ip, uint8_t *target)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i;  
#endif
//-------------------------------------------------------------------------------------------------
  for(i=0; i<4; i++){target[i]=ip[i];}
};
#endif
//=================================================================================================
//								2.3. Конвертирование IP -> uint32_t
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
uint32_t ethIpToNumber(IPAddress vr)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint32_t  bf32;  
#endif
//-------------------------------------------------------------------------------------------------
  bf32=(((uint32_t)vr[0])<<24) | (((uint32_t)vr[1])<<16) | (((uint16_t)vr[2])<<8)  | vr[3]; 
  return bf32;
};
#endif
//=================================================================================================
//								2.4. Конвертирование IP -> String
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
String ethIpToString(const IPAddress &ipAddress)
{
  mess.str =String(ipAddress[0]);	mess.str+='.';
  mess.str+=String(ipAddress[1]);	mess.str+='.'; 
  mess.str+=String(ipAddress[2]);	mess.str+='.';
  mess.str+=String(ipAddress[3]); 
  return mess.str;
};
#endif
//=================================================================================================
//								2.5. Конвертирование uint32_t -> IP
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
IPAddress ethNumberToIp(uint32_t vr)
{
  IPAddress vIP;
  vIP[0]=vr      &0xFF;
  vIP[1]=(vr>> 8)&0xFF;
  vIP[2]=(vr>>16)&0xFF;
  vIP[3]=(vr>>24)&0xFF;
  return vIP;
};
#endif
//=================================================================================================
//								2.6. Конвертирование String->IP
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
IPAddress ethStringToIp(String vr)
{
   IPAddress vIP;	
   vIP.fromString(vr);	return vIP;
};
#endif	
//=================================================================================================
//								2.7. Конвертирование uint32_t(IP)->String
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
String ethNumIpToString(uint32_t vr)
{
  mess.str =String((vr>>24)&0xFF);	mess.str+='.';
  mess.str+=String((vr>>16)&0xFF); 	mess.str+='.'; 
  mess.str+=String((vr>> 8)&0xFF); 	mess.str+='.';
  mess.str+=String((vr)    &0xFF); 
return mess.str;  
};
#endif
//=================================================================================================
//								2.8. Проверяет допустимость IP в строковой переменной ???
//=================================================================================================
#if defined(RT_HW_LINK_ETH)
IPAddress ethCheckIpToString(String vr)
{
  IPAddress vIP;	
  vIP.fromString(vr);	return vIP;
};
#endif
//=================================================================================================

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                                  3. Утилиты
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//								3.1. Конвертирование String(первые 8 символов) -> uint32_t
//=================================================================================================
uint32_t ethHexStrToInt(String str)
{
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i;
  uint8_t  bf8;
  char     chr;
  uint32_t bf32;  
#endif
//-------------------------------------------------------------------------------------------------
  bf32=0;							//--Очистка буфера выходного результата;
  bf8=str.length();				//--Определения длины входной строки;
  if(bf8==0) {return bf32;}		//--Выход =0, если пустая строка;
//-------------------------------------------------------------------------------------------------
  for(i=0; i<8; i++){	//--Проверка в цикла первых 8 символов входной строки;
      chr=str[i];				//  Сохранение в буфере текущего символа (char);
   if(chr==0) {break;}				//	Выход если символ окончания строки (=0);
   bf32<<=4; 						//  Подготовка буфера к новому значению;
   if(isdigit(chr)){bf32|=(uint8_t)(chr-'0');}		//--Преобразование если это 0-9; 
   else            {bf32|=(uint8_t)(chr-'A'+10);}}	//--Преобразование если это символ(ожидается A,B,C,D,E,F);
//---------------------------------------------------------------------------------------------------
return bf32;
};
//=================================================================================================