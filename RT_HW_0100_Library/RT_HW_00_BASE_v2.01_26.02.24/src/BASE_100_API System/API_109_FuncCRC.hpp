//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//										Работа с контрольными суммами
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//							//==Расчет CRC8 (Dallas Semiconductor 8 bit CRC);
//=================================================================================================
uint8_t crc8(const uint8_t* addr,  uint8_t len){											
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t bf8;
#endif
//-------------------------------------------------------------------------------------------------
while (len--) {bf8 = *addr++ ^ bf8;  bf8 = pgm_read_byte(RT_HW_PGM_TABLE_CRC8_2X16 + (bf8 & 0x0f)) ^ pgm_read_byte(RT_HW_PGM_TABLE_CRC8_2X16 + 16 + ((bf8 >> 4) & 0x0f));}
return bf8;}
//=================================================================================================
//							Расчет CRC16;
//=================================================================================================
uint16_t crc16(const uint8_t* input, uint16_t len, uint16_t crc){								
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t i;
#endif
//-------------------------------------------------------------------------------------------------
  static const uint8_t oddparity[16] ={ 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0 };
  for (i=0; i<len; i++) {uint16_t cdata = input[i]; cdata = (cdata ^ crc) & 0xff; crc >>= 8;
                                  if (oddparity[cdata & 0x0F] ^ oddparity[cdata >> 4]) {crc ^= 0xC001;}
								  cdata <<= 6; crc ^= cdata; cdata <<= 1; crc ^= cdata; }
return crc;}
//=================================================================================================
//								Проверка CRC16
//=================================================================================================
bool check_crc16(const uint8_t* input, uint16_t len, const uint8_t* inverted_crc, uint16_t crc){
 crc = ~crc16(input, len, crc); return (crc & 0xFF) == inverted_crc[0] && (crc >> 8) == inverted_crc[1];}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++