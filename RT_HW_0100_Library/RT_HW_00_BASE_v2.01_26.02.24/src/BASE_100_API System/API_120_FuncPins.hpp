//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// 								1.СЕРВИСНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С ПИНАМИ
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// 										1.РАБОТА С ПИНАМИ
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//									1.1.Функции контроля допустимости пинов 
//      Функции перебирают табличные значения DIN,DOT,ADC,TOUCH,DOT,PWM,DAC.
//      Рекомендуется использоваться однократно при настройке устройства привязааного к конкретному пину.   
//=================================================================================================
uint8_t checkPin(uint8_t pin, uint8_t mode)
{
  if(mode==RT_HW_PIN_MODE_DIN){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_DIN)){if(!checkPinPGM(RT_HW_PGM_PIN_DIN_ID,pin)) {return 0;}}}  
  if(mode==RT_HW_PIN_MODE_ADC){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_ADC)){if(!checkPinPGM(RT_HW_PGM_PIN_ADC_ID,pin)) {return 0;}}} 
  if(mode==RT_HW_PIN_MODE_TCH){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_TCH)){if(!checkPinPGM(RT_HW_PGM_PIN_TCH_ID,pin)) {return 0;}}}  
  if(mode==RT_HW_PIN_MODE_DOT){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_DOT)){if(!checkPinPGM(RT_HW_PGM_PIN_DOT_ID,pin)) {return 0;}}} 
  if(mode==RT_HW_PIN_MODE_PWM){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_PWM)){if(!checkPinPGM(RT_HW_PGM_PIN_PWM_ID,pin)) {return 0;}}}  
  if(mode==RT_HW_PIN_MODE_DAC){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_DAC)){if(!checkPinPGM(RT_HW_PGM_PIN_DAC_ID,pin)) {return 0;}}} 
  if(mode==RT_HW_PIN_MODE_SRV){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_DAC)){if(!checkPinPGM(RT_HW_PGM_PIN_PWM_ID,pin)) {return 0;}}} //--Доступны пины PWM;
  if(mode==RT_HW_PIN_MODE_FRQ){if(bitRead(board.blockCheckPin, RT_HW_PIN_MODE_DAC)){if(!checkPinPGM(RT_HW_PGM_PIN_PWM_ID,pin)) {return 0;}}} //--Доступны пины PWM;
  if(pin==255)         																									       {return 0;}
  return 1;		//--Выход с флагом доступности пина;
};
//=================================================================================================
//									1.2.Функции контроля допустимости пинов
//								(пока остается для совместимости со старыми библиотеками)  
//=================================================================================================
bool checkPinDIN(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_DIN_ID,pin);};	//--Проверка допустимости на дискретный ввод;
bool checkPinADC(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_ADC_ID,pin);};	//--Проверка допустимости на аналоговый ввод;
bool checkPinTCH(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_TCH_ID,pin);};	//--Проверка допустимости на сенсорный  ввод;
bool checkPinDOT(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_DOT_ID,pin);};	//--Проверка допустимости на дискретный вывод;
bool checkPinPWM(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_PWM_ID,pin);};	//--Проверка допустимости на    PWM     вывод;
bool checkPinDAC(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_DAC_ID,pin);};	//--Проверка допустимости на    DAC     вывод;
bool checkPinSRV(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_PWM_ID,pin);};	//--Проверка допустимости на    Servo   вывод;
bool checkPinFRQ(uint8_t pin){return checkPinPGM(RT_HW_PGM_PIN_PWM_ID,pin);};	//--Проверка допустимости на    Freq    вывод;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// 								ФУНКЦИИ ВВОДА-ВЫВОДА НА ПИНАХ КОНТРОЛЛЕРА
//									  
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//									2.Дискретный ввод 
// mode:    I->дискретный ввод; 
//          U->дискретный ввод с подтяжкой к +Vcc; 
//		    D->дискретный ввод с подтяжкой к  GND; 
// 	 	    F->дискретный ввод с плавающим входом (STM32) (floating entrance);
// Примечание: если указан недопустимый режим(помимо перечисленных) 
//             или режим недопустимый для выбранного MCU инициализируется как ввод без подтяжки;
//=================================================================================================
uint8_t pinDigitalRead(RT_HW_PIN_DIR_ID &id, uint8_t pin, char mode='I')
{ (void)id; (void)pin;
//-------------------------------------------------------------------------------------------------
//									2.0. Настройка пина
//-------------------------------------------------------------------------------------------------
  if(id.dir==0){
  if(!checkPinDIN(pin)){id.dir=50; return 0;}				//--Проверка допустимости пина 
  RT_HW_PIN_DIR_SET_ID(id,pin)								//--Настройка ID;	
  id.mode=mode;												//--Сохранение режима настройки пина;
//-------------------------------------------------------------------------------------------------
//									2.0.1. AVR || SAMX 
//-------------------------------------------------------------------------------------------------
  #if   defined(RT_HW_CORE_AVR) || defined(RT_HW_CORE_SAMX) 
	if(id.mode=='U') {pinMode(id.pin, INPUT_PULLUP);}		//--Инициализация дискретного ввода с подтяжкой к +Vcc;
    else 			 {pinMode(id.pin, INPUT);}				//--Инициализация дискретного ввода без подтяжки;
//-------------------------------------------------------------------------------------------------
//									2.0.3. ESP8266 
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_ESP8266)
         if(id.mode=='U') {pinMode(id.pin, INPUT_PULLUP);}	//--Инициализация дискретного ввода с подтяжкой к +Vcc;
    else if(id.mode=='D') {pinMode(id.pin, INPUT_PULLDOWN);}//--Инициализация дискретного ввода с подтяжкой к +GND;
    else 				  {pinMode(id.pin, INPUT);}			//--Инициализация дискретного ввода без подтяжки;
//-------------------------------------------------------------------------------------------------
//									2.0.5. ESP32 
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_ESP32)
         if(id.mode=='U') {pinMode(id.pin, INPUT_PULLUP);}	//--Инициализация дискретного ввода с подтяжкой к +Vcc;
    else if(id.mode=='D') {pinMode(id.pin, INPUT_PULLDOWN);}//--Инициализация дискретного ввода с подтяжкой к +GND;
    else 				  {pinMode(id.pin, INPUT);}			//--Инициализация дискретного ввода без подтяжки;
//-------------------------------------------------------------------------------------------------
//									2.0.6. STM32 
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_STM32)	 
	     if(id.mode=='U') {pinMode(id.pin, INPUT_PULLUP);}	//--Инициализация дискретного ввода с подтяжкой к +Vcc;
    else if(id.mode=='D') {pinMode(id.pin, INPUT_PULLDOWN);}//--Инициализация дискретного ввода с подтяжкой к +GND;
    else if(id.mode=='F') {pinMode(id.pin, INPUT);}			//--Инициализация дискретного ввода с подтяжкой к +GND;
    else 				  {pinMode(id.pin, INPUT);}			//--Инициализация дискретного ввода без подтяжки;
//-------------------------------------------------------------------------------------------------
//									2.0.7. RP2040
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_RP2040)
	     if(id.mode=='U') {pinMode(id.pin, INPUT_PULLUP);}	//--Инициализация дискретного ввода с подтяжкой к +Vcc;
    else if(id.mode=='D') {pinMode(id.pin, INPUT_PULLDOWN);}//--Инициализация дискретного ввода с подтяжкой к +GND;
    else 				  {pinMode(id.pin, INPUT);}			//--Init as discret input;
//-------------------------------------------------------------------------------------------------
//									2.0.10. Другие MCU 
//-------------------------------------------------------------------------------------------------
  #else
	 if(id.mode=='U')     {pinMode(id.pin, INPUT_PULLUP);}	//--Инициализация дискретного ввода с подтяжкой к +Vcc;
     else 				  {pinMode(id.pin, INPUT);}			//--Инициализация дискретного ввода без подтяжки;
  #endif
//-------------------------------------------------------------------------------------------------
  id.dir=1;
  }
//-------------------------------------------------------------------------------------------------
//									2.1.1. Чтение пина
//-------------------------------------------------------------------------------------------------
  if(id.dir==1)
  {
   #if !defined(RT_HW_BLOCK_QUICK_PIN	)
	return RT_HW_PIN_DIR_READ(id);							//--Быстрое чтение; 
   #else
	return digitalRead(id.pin);								//--Чтение функцией Arduino IDE;
   #endif
  }
//-------------------------------------------------------------------------------------------------
  return 0;
};	//--END pinDigitalRead();

//=================================================================================================
//									2x. Функция защиты от дребезга
//   Устаревшая функция - оставлена для совместимости со старыми блоками FLProg (26.02.2024)
//   Рекомендуется использовать RT_HW_FILTER_CHATTER.h - фильтр дребезга переменной.
//=================================================================================================
bool chatterDIN(RT_HW_CHATTER_DIN &id, uint8_t var, uint16_t period)
{
  if(id.dir==0) {if(id.ago!=var){id.timeBegin=RT_HW_MILLIS; id.dir++;}               return id.ago;}
  if(id.dir==1) {if((getPastMs  (id.timeBegin)< period) && (id.ago==var)) {id.dir=0; return id.ago;} 
			     if( getPastMs  (id.timeBegin)> period)    {id.ago=var;	   id.dir=0; return id.ago;}}
//-------------------------------------------------------------------------------------------------
}; //--END chatterDIN();

//=================================================================================================
//									3. Дискретный вывод (DOT)
// mode:   N->нормальный вывод; 
//         O->открытый коллектор;
//=================================================================================================
void  pinDigitalWrite(RT_HW_PIN_DIR_ID &id, uint8_t pin, uint8_t var, char mode='N')
{  (void)id; (void)pin; (void)var; (void)mode;
//-------------------------------------------------------------------------------------------------
//									3.1. Настройка пина
//-------------------------------------------------------------------------------------------------
  if(id.dir==0)
  { 
   if(!checkPinDOT(pin)){id.dir=50; return;}				//--Проверка допустимости пина 	
   RT_HW_PIN_DIR_SET_ID(id,pin)								//--Настройка ID;	
   id.mode=mode;											//--Сохранение режима настрйоки пина;
//-------------------------------------------------------------------------------------------------
//									3.1.1. AVR || SAMX 
//-------------------------------------------------------------------------------------------------
  #if   defined(RT_HW_CORE_AVR) || defined(RT_HW_CORE_SAMX) 
	digitalWrite(id.pin,0);	  pinMode(id.pin, OUTPUT);		//--Инициализация дискретного вывода;
     Serial.print("3.1.1.DOT pin="); Serial.println(pin);
//-------------------------------------------------------------------------------------------------
//									3.1.3. ESP8266 
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_8266)
	digitalWrite(id.pin,0);	  pinMode(id.pin, OUTPUT);		//--Инициализация дискретного вывода;
//-------------------------------------------------------------------------------------------------
//									3.1.5. ESP32 
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_ESP32)
  if(id.mode=='O'){digitalWrite(id.pin,0); pinMode(id.pin, OUTPUT); id.dir=1;} //--Инициализация дискретного вывода с открытым коллектором;
  else 			  {digitalWrite(id.pin,0); pinMode(id.pin, OUTPUT); id.dir=1;} //--Инициализация дискретного вывода;

//-------------------------------------------------------------------------------------------------
//									3.1.6. STM32 
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_STM32)	 
  if(id.mode=='O'){digitalWrite(id.pin,1); pinMode(id.pin, OUTPUT); id.dir=2;} //--Инициализация дискретного вывода с открытым коллектором;
  else 			  {digitalWrite(id.pin,0); pinMode(id.pin, OUTPUT); id.dir=1;} //--Инициализация дискретного вывода;
//-------------------------------------------------------------------------------------------------
//									3.1.7. RP2040
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_RP2040)
				  digitalWrite(id.pin,0); pinMode(id.pin, OUTPUT); id.dir=1;	 //--Инициализация дискретного вывода;

//-------------------------------------------------------------------------------------------------
//									3.1.10. Другие MCU 
//-------------------------------------------------------------------------------------------------
  #else
				 digitalWrite(id.pin,0); pinMode(id.pin, OUTPUT); id.dir=1;	 //--Инициализация дискретного вывода;
  #endif
//-------------------------------------------------------------------------------------------------
  id.dir=1;		//--Переход после иниицализации;
//-------------------------------------------------------------------------------------------------
  }
//-------------------------------------------------------------------------------------------------
//									3.2. Запись пина прямого значения
//-------------------------------------------------------------------------------------------------
  if(id.dir==1)
  {
   #if !defined(RT_HW_BLOCK_QUICK_PIN	)
    RT_HW_PIN_DIR_WRITE(id,var);							//--Быстрая запись; ; 
   #else
    digitalWrite(id.pin,var);								//--Запись функцией Arduino IDE; 
  #endif
  return;
  }
//-------------------------------------------------------------------------------------------------
//									3.3. Запись пина прямого значения (STM32)
//-------------------------------------------------------------------------------------------------
  if(id.dir==2)
  {
   #if !defined(RT_HW_BLOCK_QUICK_PIN	)
    RT_HW_PIN_DIR_WRITE(id,!var);							//--Быстрая запись; 
  #else
    digitalWrite(id.pin,!var);								//--Запись функцией Arduino IDE;
  #endif
  return;
  }
//-------------------------------------------------------------------------------------------------
};	//--END pinDigitalWrite();

//=================================================================================================
//									4. Аналоговый ввод (ADC)
//-------------------------------------------------------------------------------------------------
//	id.vPin;				//--Значение с пина [analogRead(pin)];
//	id.adcVar;	    		//--Значение с пина с фильтром дрейфа показаний (device.depth.adcDrift) и дрейфа нуля (device.depth.фвсNull); 
//	id.vNorm;				//--Нормализованное значение id.vFltr с системным разрешением device.depth.sys; 
//=================================================================================================
void  pinAnalogRead(RT_HW_PIN_ADC_ID &id, uint8_t pin)
{ (void)id; (void)pin;
//-------------------------------------------------------------------------------------------------
//									4.1. Настройка пина (ADC)
//-------------------------------------------------------------------------------------------------
  if(id.dir==0)
  {
  if(!checkPinADC(pin)){id.dir=50; return;}//--Проверка допустимости пина 
   id.pin=pin;												//--Сохранение номера пина;	
   id.adcMax=maxBitDepth(device.adc.depth);					//--Сохранение максимально допустимого значения;
//-------------------------------------------------------------------------------------------------
//									4.1.1. AVR,SAMX,ESP8266,ESP32 
//-------------------------------------------------------------------------------------------------
  #if   defined(RT_HW_CORE_AVR) || defined(RT_HW_CORE_SAMX) || defined(RT_HW_CORE_ESP8266) || defined(RT_HW_CORE_ESP32)
    pinMode(id.pin, INPUT);									//--Настройка пина для STM32;;
//-------------------------------------------------------------------------------------------------
//									4.1.6. STM32 
//-------------------------------------------------------------------------------------------------
  #elif   defined(RT_HW_CORE_STM32) 
    pinMode(id.pin, INPUT_ANALOG);							//--Настройка пина для STM32;;
//-------------------------------------------------------------------------------------------------
//									4.1.7. RP2040 
//-------------------------------------------------------------------------------------------------
  #elif   defined(RT_HW_CORE_RP2040) 
    pinMode(id.pin, INPUT);									//--Настройка пина для STM32;;
//-------------------------------------------------------------------------------------------------
//									4.1.10. Другие MCU 
//-------------------------------------------------------------------------------------------------
  #else
	pinMode(id.pin, INPUT);									//--Настройка пина для других MCU;
  #endif
//-------------------------------------------------------------------------------------------------
  id.dir=1;
  }
//-------------------------------------------------------------------------------------------------
//									4.2. Чтение пина (ADC)
//-------------------------------------------------------------------------------------------------
  if(id.dir==1)
  {
   id.vPin=analogRead(id.pin);
//-------------------------------------------------------------------------------------------------
//									4.2.1. Нормализация значения с пина для платы RT_HW_BOARD_ESP32C3_DEV
// Примечание: на этой плате на пин 0 установлен резисторный делитель
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_BOARD_ESP32C3_DEV)
   if(id.pin==0){id.vPin=(uint32_t)id.vPin*3300/1000;}	
  #endif	
//-------------------------------------------------------------------------------------------------
//									4.2.2. Фильтр дрейфа показаний и дрейфа нуля
//-------------------------------------------------------------------------------------------------
  if(id.vPin>id.adcVar){if((id.vPin-id.adcVar)>device.adc.driftVar){id.adcVar=id.vPin;}}
  if(id.vPin<id.adcVar){if((id.adcVar-id.vPin)>device.adc.driftVar){id.adcVar=id.vPin;}}
  if(id.adcVar>id.adcMax){id.adcVar=id.adcMax;}
  if(id.adcVar<device.adc.driftNull){id.adcVar=0;}
//-------------------------------------------------------------------------------------------------
//									4.2.3. Нормализация значения adcVar
//-------------------------------------------------------------------------------------------------
  id.vNorm=normADC(id.adcVar);
  }
//-------------------------------------------------------------------------------------------------
};	//--END pinADC();

//=================================================================================================
//									5. Широтно-импульсная модуляция (PWM)
//-------------------------------------------------------------------------------------------------
//	freq	- частота PWM [ESP32]
//	channel	- номер канала [ESP32]
//	depth   - разрядность. Если равно 255, тогда устанавливается равной vDepthPWM();
//	freq    - частота;
//	char     mode='N';			//--Output type (N-normal, O-open collector);
//	uint8_t  idx;				//--Working index;
//	uint32_t var;				//--External direct;
//	uint16_t duration;			//--The value of the PWM pulse normalized to depth;
//	uint16_t duty;				//--The value written to the pin (taking into account the PWM bit depth);
// }
//=================================================================================================
void  pinPWM(RT_HW_PIN_PWM_ID &id, uint8_t pin, uint16_t var)
{ (void)id; (void)var; 
//-------------------------------------------------------------------------------------------------
//									5.1. Настройка пина (PWM)
//-------------------------------------------------------------------------------------------------
  if(id.dir==0)
  {
   if(!checkPin(pin,RT_HW_PIN_MODE_PWM)){id.dir=50; return;}//--Проверка допустимости пина 
   id.pin=pin;												//--Сохранение номера пина;	
//-------------------------------------------------------------------------------------------------
//									4.1.1. AVR || SAMX || ESP8266
//-------------------------------------------------------------------------------------------------
   #if   defined(RT_HW_CORE_AVR) || defined(RT_HW_CORE_SAMX) || defined(RT_HW_CORE_ESP8266) 
					pinMode(id.pin, OUTPUT);				//--Инициализация дискретного вывода(PWM);
//-------------------------------------------------------------------------------------------------
//									4.1.3. ESP32
//-------------------------------------------------------------------------------------------------
   #elif defined(RT_HW_CORE_ESP32) 
					pinMode(id.pin,OUTPUT);					//--Инициализация дискретного вывода(PWM);
  if(id.depth==255){id.depth=vDepthPWM();} 					//--Инициализация deafult разрешения (в разрядах);
  if(id.depth>16)  {id.depth=16;}				  			//--Ограничение максиальной разрядности;
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_CORE_ESP32C3)
    if(id.depth>14)  {id.depth=14;}				  			//--Ограничение максиальной разрядности для ESP32C3;
  #endif	
//-------------------------------------------------------------------------------------------------
  if(id.channel==255){										//--Захват свободного канала, если он не определен внешней настройкой; 
	for(id.idx=0; id.idx<RT_HW_MAX_NUM_CHANNEL; id.idx++){	//--Поиск первого свободного канала;
    if(!bitRead(device.pwm.channel,id.idx)){				//--Захват свободного канала 
	 bitSet(device.pwm.channel,id.idx); id.channel=id.idx; break;}}} // с прекращением поиска;
  if(id.channel>=RT_HW_MAX_NUM_CHANNEL) {id.dir=52; return;}//--Проверка допустимости номера канала;
  ledcSetup(id.channel,id.freq,id.depth);					//--Инициализация канала: частота, разрешение;
  ledcAttachPin(id.pin,id.channel);							//--Подключение пина к номеру канала (CORE реализует PWM по прерываниям;	
//-------------------------------------------------------------------------------------------------
//									4.1.6. STM32 
//-------------------------------------------------------------------------------------------------
  #elif   defined(RT_HW_CORE_STM32) 
   if(id.mode=='O'){pinMode(id.pin,OUTPUT_OPEN_DRAIN);}		//--Инициализация выхода как открытый коллектор;
   else            {pinMode(id.pin,OUTPUT);}				//--Инициализация выхода нормальный;
//-------------------------------------------------------------------------------------------------
//									4.1.10. Другие MCU 
//-------------------------------------------------------------------------------------------------
#else
  id.dir=52; return;											//--Выход по ошибке;											
#endif
//-------------------------------------------------------------------------------------------------
   id.dir=1;
  } 
//-------------------------------------------------------------------------------------------------
//									5.2. Запись пина (PWM)
//-------------------------------------------------------------------------------------------------
  if(id.dir==1)
  {
//-------------------------------------------------------------------------------------------------
//									5.2.1. AVR || SAMX || ESP8266
//-------------------------------------------------------------------------------------------------
  #if   defined(RT_HW_CORE_AVR) || defined(RT_HW_CORE_SAMX) || defined(RT_HW_CORE_ESP8266) 
   id.var=normPWM(var); analogWrite(id.pin,id.var); return;
//-------------------------------------------------------------------------------------------------
//									5.2.2. ESP32
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_ESP32) 
   //ledcChangeFrequency(id.channel,id.freq,id.depth); 
   id.var=var;
   id.duration=id.var;										//--Save duration variable; 
   id.duty=normDepth(id.duration,id.depth); 			    //--Save duty mcs; 
   ledcWrite(id.channel,id.duty); 							//--Вывод PWM ESP32;		
   return;
//-------------------------------------------------------------------------------------------------
//									5.2.3. STM32
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_STM32) 
   id.var=normPWM(var); analogWrite(id.pin,id.var); return;	//--PWM output STM32;
//-------------------------------------------------------------------------------------------------
//									5.2.4. RP2040
//-------------------------------------------------------------------------------------------------
  #elif defined(RT_HW_CORE_RP2040) 
   id.var=normPWM(var); analogWrite(id.pin,id.var); return;	//--PWM output STM32;
//-------------------------------------------------------------------------------------------------
//									5.3.5. Другой MCU
//-------------------------------------------------------------------------------------------------
  #else
	return;
  #endif
  }
//-------------------------------------------------------------------------------------------------
};	//--END pinPWM();

//=================================================================================================
//									6. Аналоговый вывод (DAC)
//=================================================================================================
void pinDAC(RT_HW_PIN_DAC_ID &id, uint8_t pin, uint16_t var)
{  (void)id; (void)pin;  (void)var;
  #if defined(RT_HW_PERMIT_DAC) 
//-------------------------------------------------------------------------------------------------
//									6.1. Настройка пина
//-------------------------------------------------------------------------------------------------
  if(id.dir==0)
  {
   if(!checkPin(pin,RT_HW_PIN_MODE_DAC)){id.dir=50; return;}//--Проверка допустимости пина; 
   id.pin=pin;												//--Сохранение номера пина;	 
   id.dir=1;
  } 				   
//-------------------------------------------------------------------------------------------------
//									6.2. Настройка пина
//-------------------------------------------------------------------------------------------------
  if(id.dir==1) 
  {
  #if defined(RT_HW_CORE_ESP32) 	
    id.vPin=normDAC(var); dacWrite(id.pin,id.vPin);	 return;
  #endif
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_CORE_STM32)	 
    id.vPin=normDAC(var); analogWrite(id.pin,id.vPin); return;
  #endif
//-------------------------------------------------------------------------------------------------
  }  //--END if (id.dir==1)
  #endif
//-------------------------------------------------------------------------------------------------
};	//--END pinDAC();


//=================================================================================================
//									7.Сенсорный ввод [ESP32]
//=================================================================================================
void  pinTouchRead(RT_HW_PIN_TCH_ID &id, uint8_t pin){	
(void)id; (void)pin;
#if defined(RT_HW_PERMIT_TOUCH)
//-------------------------------------------------------------------------------------------------
//									7.1. Настройка пина
//-------------------------------------------------------------------------------------------------
if(id.dir==0){
if(!checkPin(pin,RT_HW_PIN_MODE_TCH)){id.dir=50; return;}	//--Проверка допустимости пина 
id.pin=pin;													//--Сохранение номера пина;	
id.dir=1;}
//-------------------------------------------------------------------------------------------------
//									7.2. Чтение с пина
//-------------------------------------------------------------------------------------------------
if(id.dir==1){
//-------------------------------------------------------------------------------------------------
//									7.2.1. ESP32 
//-------------------------------------------------------------------------------------------------
#if defined(RT_HW_CORE_ESP32)	
id.vPin=touchRead(id.pin); id.vNorm=id.vNorm; 
//-------------------------------------------------------------------------------------------------
//									7.2.10. Для других контроллеров 
//-------------------------------------------------------------------------------------------------	
#else
id.vPin=id.vNorm=0;
#endif
}
//-------------------------------------------------------------------------------------------------
#endif
};
//=================================================================================================
//void  pinTouchRead(RT_HW_PIN_DIR_ID &id, uint8_t pin){			//--8x.Расширенная функция чтения сенсорного пина;
//(void)id; (void)pin;
//#if defined(RT_HW_PERMIT_TOUCH)
//if(id.dir==0){RT_HW_PIN_DIR_SET_ID(id,pin); id.dir=1;}  
//if(id.dir==0){pinTouchRead(id,);}
//#endif
//};
//=================================================================================================

//=================================================================================================
//									8. Чтение датчика Холла [ESP32]
//=================================================================================================
void pinReadHALL(RT_HW_PIN_HALL_ID &id)
{ (void)id;
  #if defined(RT_HW_PERMIT_HALL)
//-------------------------------------------------------------------------------------------------
//									8.1. ESP32 
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_CORE_ESP332)
    id.vPin=hallRead();
    id.vNorm=map(id.vPin,-128,127,0,maxBitDepth(device.depth.sys));	return;
//-------------------------------------------------------------------------------------------------
//									8.2. Другие MCU
//-------------------------------------------------------------------------------------------------
  #else
    id.vPin=id.vNorm=0;	
  #endif
  #endif
};


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// 									9.SERVO CONTROL
//-------------------------------------------------------------------------------------------------
//struct RT_HW_PIN_SERVO_ID{
//	uint8_t  dir=0;				//--Stage number in the executive function; 
//	uint8_t  pin=255;			//--Pin number;
//	uint8_t  channel=4;			//--Channel number[ESP32]
//	uint8_t  depth=16;			//--Bit depthESP32];
//	uint16_t freq=50;			//--Frequency;
//	uint16_t maxAngle=180;		//--The maximum angle of rotation (-360,+360);
//	uint16_t minWidth=800;		//--Minimum pulse width(mcs);   
//	uint16_t maxWidth=2300;		//--Maximum pulse width(mcs);  
//	uint16_t maxDepth=0xFFFF;   //--Maximum value for the selected bit depth;
//	uint16_t period=20000;		//--Period of control pulses(calculated variable=1000000/freq); 
//-------------------------------
//	uint8_t  idx;				//--Working index;
//	uint16_t var;				//--External pulse duration setting;
//	uint16_t duration;			//--Estimated pulse duration;
//	uint16_t duty;				//--The value written to the device (taking into account the PWM bit depth);
//};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//								  9.1. УСТАНОВКА ПАРАМЕТРОВ СЕРВО
//=================================================================================================
void pinServoSet_MG90S (RT_HW_PIN_SERVO_ID &id){id.freq=50; id.minWidth=650; id.maxWidth=2200; id.maxAngle=180;}
void pinServoSet_MG996R(RT_HW_PIN_SERVO_ID &id){id.freq=50; id.minWidth=650; id.maxWidth=2200; id.maxAngle=180;}
//=================================================================================================
//								  9.2. Нормализация значения ширины управляющего импульса(mcs)
//=================================================================================================
uint16_t pinServoNormSYS  (RT_HW_PIN_SERVO_ID &id, uint16_t var){return map(var,0,((1<<board.depth)-1),id.minWidth,id.maxWidth);}
//=================================================================================================
//								  9.3. Нормализация угла поворота
//=================================================================================================
int16_t  pinServoNormAngle(RT_HW_PIN_SERVO_ID &id, uint16_t var){return map(var,0,id.maxAngle,id.minWidth,id.maxWidth);}



//=================================================================================================
//								  9.4. УПРАВЛЕНИЕ СЕРВО (ESP32)
//=================================================================================================
void pinServo(RT_HW_PIN_SERVO_ID &id, uint8_t pin, uint16_t var)
{  (void)id; (void)pin; (void)var; 	
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_CORE_ESP32)
//-------------------------------------------------------------------------------------------------
//								  9.4.1. Проверка допустимости и настройка пина ESP32
//-------------------------------------------------------------------------------------------------
  if(id.dir==0)
  {
   if(!checkPinPWM(pin)){id.dir=50; return;} 				//--Проверка допустимости номера пина; 	
   id.pin=pin;	 											//--Сохранение номера пина;
   pinMode(id.pin,RT_HW_PIN_MODE_OUTPUT);					//--Настройка пина на вывод;   
//-------------------------------------------------------------------------------------------------
//								  9.4.1.1. Настройка рарядности пина ESP32
//-------------------------------------------------------------------------------------------------
   if(id.depth==255){id.depth=device.pwm.depth;} 			//--Установка используемой разрядности шины (ESP32);
   if(id.depth>16)  {id.depth=16;}				  			//--Ограничение разрядности;
#if defined(RT_HW_CORE_ESP32C3)
   if(id.depth>14)  {id.depth=14;}				  			//--Ограничение разрядности для ESP32C3;
#endif
//-------------------------------------------------------------------------------------------------
//								  9.4.1.2. Выбор номера канала PWM (ESP32)
//-------------------------------------------------------------------------------------------------
   if(id.channel==255){for(id.idx=0; id.idx<RT_HW_MAX_NUM_CHANNEL; id.idx++){	//--Выбор свободного канала;
                       if(!bitRead(device.pwm.channel,id.idx)){bitSet(device.pwm.channel,id.idx); id.channel=id.idx; break;}}}
   if(id.channel==255){id.dir=51; return;} 					//--Выход по ошибке "Нет свободного канала;
//-------------------------------------------------------------------------------------------------
//								  9.4.1.3. Настройка канала PWM (ESP32)
//-------------------------------------------------------------------------------------------------
   if(id.freq<40){id.freq=40;} if(id.freq>100){id.freq=100;}//--Нормализация частоты;
   id.period=1000000UL/id.freq;								//--Расчет периода вывода импульсов;
   id.maxDepth=((1 << id.depth) - 1);						//--Расчет максимального значения для выбранной разрядности;
   ledcSetup(id.channel,id.freq,id.depth);					//--Настройка канала id.channel: частота и разрешение;
   ledcAttachPin(id.pin,id.channel);						//--Привязка пина к номеру канала;
   id.dir=1;
  }
//-------------------------------------------------------------------------------------------------
//								  9.4.1.4. Вывод на серво(ESP32)
//-------------------------------------------------------------------------------------------------
  if(id.dir==1)
  { 
   id.duration=id.var; 
   if(id.duration<id.minWidth){id.duration=id.minWidth;} 		//--Ограничение импульса снизу;
   if(id.duration>id.maxWidth){id.duration=id.maxWidth;}		//--Ограничение импульса сверху;
   id.duty=map(id.duration,0,id.period,0,id.maxDepth);			//--Расчет длительности с учетом разрядности depth;
   ledcWrite(id.channel,id.duty);
   return;
  }	
//-------------------------------------------------------------------------------------------------
  #endif	//--END if defined(RT_HW_CORE_ESP32)
//-------------------------------------------------------------------------------------------------
};	//--END pinServo()

//=================================================================================================
//									10. Генератор частоты [ESP32]
//=================================================================================================
//struct RT_HW_PIN_PWM_ID{
//	uint8_t  dir=0;				//--Stage number in the executive function; 
//	uint8_t  pin=255;			//--Pin number;
//	uint8_t  channel=255;		//--Channel number[ESP32]
//	uint8_t  depth=255;			//--Bit depth PWM[ESP32]. If=255 then depth=device.depth.pwm;
//	uint16_t freq=1000;			//--Frequency;
//	char     mode='N';			//--Output type (N-normal, O-open collector);
//	uint8_t  idx;				//--Working index;
//	uint32_t var;				//--External direct;
//	uint16_t duration;			//--The value of the PWM pulse normalized to depth;
//	uint16_t duty;				//--The value written to the pin (taking into account the PWM bit depth);
// }
//=================================================================================================
void pinFreq(RT_HW_PIN_PWM_ID &id, uint8_t pin, uint16_t freq, uint8_t var)
{ (void)pin; (void)var; (void)freq;
//-------------------------------------------------------------------------------------------------
//								10.1. Настройка пина
//-------------------------------------------------------------------------------------------------
  if(id.dir==0)
  {
   if(!checkPin(pin,RT_HW_PIN_MODE_FRQ)){id.dir=50; return;}//--Проверка допустимости пина 
   id.pin=pin;												//--Сохранение номера пина;	 
   pinMode(id.pin,OUTPUT); 									//--Инициализация пина;
//-------------------------------------------------------------------------------------------------
//								10.1.1. Настройка пина для ESP32
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_CORE_ESP32) 
//-------------------------------------------------------------------------------------------------
   if(id.depth==255){id.depth=device.pwm.depth;} 			//--Инициализация разрешения по умолчанию;
   if(id.depth>16)  {id.depth=16;}				  			//--Ограничение   разрешения;
   #if defined(RT_HW_CORE_ESP32C3)
     if(id.depth>14)  {id.depth=14;}				  		//--Ограничение   разрешения для ESP32C3;
   #endif	
   if(id.channel==255){for(id.idx=0; id.idx<RT_HW_MAX_NUM_CHANNEL; id.idx++){	//--Поиск свободного канала;
                      if(!bitRead(device.pwm.channel,id.idx)){bitSet(device.pwm.channel,id.idx); 
					  id.channel=id.idx; break;}}}
  ledcSetup(id.channel,id.freq,id.depth);					//--Инициализация   выбранного канала: частота, разрешение;
  ledcAttachPin(id.pin,id.channel);							//--Привязка пина к выбранному каналу;	
//-------------------------------------------------------------------------------------------------
  #endif   //--Завершение настройки пина для ESP32
//-------------------------------------------------------------------------------------------------
  id.dir=1;
  }  
//-------------------------------------------------------------------------------------------------
//								10.2. Контроль изменения частоты или переменной
//-------------------------------------------------------------------------------------------------
  if(id.dir==1)
  {
   if((id.freq!=freq) || (id.var!=var)){id.dir=2;}
   //id.dir=2;
  }
//-------------------------------------------------------------------------------------------------
//								10.3. Вывод частоты
//-------------------------------------------------------------------------------------------------
  if(id.dir==2)
  {
//-------------------------------------------------------------------------------------------------
//								10.3.1. Вывод на пин для ESP32
//-------------------------------------------------------------------------------------------------
  #if defined(RT_HW_CORE_ESP32) 
//-------------------------------------------------------------------------------------------------
   if(id.freq!=freq)
   {
	id.freq=freq;											//--Изменение частоты
    //ledcChangeFrequency(id.channel,id.freq,id.depth); 
   }
   id.var=var;
   id.duration=id.var;										//--Save duration variable; 
   id.duty=normDepth(id.duration,id.depth); 				//--Получение длительности импульса в mcs; 
   ledcWrite(id.channel,id.duty); 							//--Вывод PWM ESP32;		
   id.dir=1; 												//--Возврат на ожидание изменение частоты или значения
   return;
//-------------------------------------------------------------------------------------------------
//								10.3.2. Вывод на пин других контроллеров
//-------------------------------------------------------------------------------------------------
  #else
     id.freq=freq; id.var=var;								//--Ничего не выводится
  #endif
}
//-------------------------------------------------------------------------------------------------
};	//--END pinFreq();
//=================================================================================================



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//							ФУНКЦИИ ЗАПИСИ-ЧТЕНИЯ ПИНОВ
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//bool changeProtectPinDI(RT_HW_CHANGE_PINDI_ID &id, uint8_t timeChange, uint8_t val){//==Защита от дребезга значения на пине DI;
//if(id.dir==0) {if(id.ago!=val) {id.time=RT_HW_MILLIS; id.dir++;}                       return id.ago;}
//if(id.dir==1) {if((getPastMs(id.time)< (timeChange)) && (id.ago==val))  	{id.dir=0; return id.ago;} 
//				if( getPastMs(id.time)>= timeChange)     {id.ago=val;		 id.dir=0; return id.ago;}}
//																					   return id.ago;};
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
