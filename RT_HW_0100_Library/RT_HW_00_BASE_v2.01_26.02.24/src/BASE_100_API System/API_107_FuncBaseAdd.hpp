//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//								СИСТЕМНЫЕ ФУНКЦИИ ОБЩИЕ
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//=================================================================================================
//				Функции гистерезиса меняют значение var на cur при его отклонение на delta) 
//=================================================================================================	
uint16_t makeDelta(uint16_t &var, uint16_t cur, uint8_t delta){			
  if(cur>var){if((cur-var)>delta){var=cur;}} 
  if(cur<var){if((var-cur)>delta){var=cur;}} return var;} 
//=================================================================================================
//						Обмен битов uint8_t
//=================================================================================================
uint8_t changeBitByte(uint8_t val){
return((val&0x01)<<7)|((val&0x02)<<5)|((val&0x04)<<3)|((val&0x08)<<1)|((val&0x10)>>1)|((val&0x20)>>3)|((val&0x40)>>5)|((val&0x80)>>7);};	  
//=================================================================================================
//						Обмен битов uint16_t
//=================================================================================================
uint16_t changeBitWord(uint16_t val){
return((val&0x0001)<<15)|((val&0x0002)<<13)|((val&0x0004)<<11)|((val&0x0008)<<9)|((val&0x0010)<<7)|((val&0x0020)<<5)|((val&0x0040)<<3) | ((val&0x0080)<<1) |
      ((val&0x8000)>>15)|((val&0x4000)>>13)|((val&0x2000)>>11)|((val&0x1000)>>9)|((val&0x0800)>>7)|((val&0x0400)>>5)|((val&0x0200)>>3) | ((val&0x0100)>>1);}                                     
//=================================================================================================
//						Reverse bit v8
//=================================================================================================
inline uint8_t reverseV8(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;}
//=================================================================================================
//						Reverse bit v16
//=================================================================================================
//  uint16_t x = _dataOut;                              //  x = 0123456789ABCDEF
//  x = (((x & 0xAAAA) >> 1) | ((x & 0x5555) << 1));    //  x = 1032547698BADCFE
//  x = (((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2));    //  x = 32107654BA98FEDC
//  x = (((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4));    //  x = 76543210FEDCBA98
//  x = (x >> 8) | ( x << 8);                           //  x = FEDCBA9876543210
uint16_t reverseV16(uint16_t v) {//uint8_t v0=v & 0xFF; uint8_t v1=(v>>8) & 0xFF; 
return ((reverseV8(v & 0xFF)<< 8) | reverseV8((v>>8) & 0xFF));}
//=================================================================================================
//						Reverse bit v24
//=================================================================================================
uint32_t reverseV24(uint32_t v) {uint8_t v0=v & 0xFF; uint8_t v1=(v>>8) & 0xFF; uint8_t v2=(v>>16) & 0xFF; 
return (                                    (((uint32_t)reverseV8(v0))<<16) | (((uint32_t)reverseV8(v1))<< 8) | reverseV8(v2));}
//=================================================================================================
//						Reverse bit v32
//=================================================================================================
uint32_t reverseV32(uint32_t v) {uint8_t v0=v & 0xFF; uint8_t v1=(v>>8) & 0xFF; uint8_t v2=(v>>16) & 0xFF; uint8_t v3=(v>>24) & 0xFF; 
return ((((uint32_t)reverseV8(v0))<<24) | (((uint32_t)reverseV8(v1))<<16) | (((uint32_t)reverseV8(v2))<< 8) | reverseV8(v3));}
//=================================================================================================
//						Извлечение цифры из числа
//=================================================================================================
char 	 getCharVal(uint32_t val,uint8_t upper,char mode,uint8_t len,uint8_t n){//==Возвращает цифру(как символ) из val начиная со старшей позиции;
//-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint32_t  bf32;
#endif
//-------------------------------------------------------------------------------------------------
//---mode B,b,H,h,D,I,0,1,2,3,T; upper =0 верхний регистр, =1 нижний регистр;
bf32=0;
if((mode=='B') || (mode=='b')) {bf32=(val>>(len-n))&1;}
if((mode=='H') || (mode=='h')) {bf32=(val>>(len-n)*4)&0xf;}
if((mode=='D') || (mode=='I') ||(mode=='U')|| (mode=='0') ||(mode=='1') ||(mode=='2') || (mode=='3') || (mode=='T')) 
                                        {n=len-n+1; while(n!=0) {bf32=val; val/=10; bf32=bf32-(val*10); n--;};}
if(bf32<=9) {bf32=bf32 +'0';} else {bf32=bf32-10+(upper ? 'A' : 'a') ;}
return (uint8_t)bf32;}; 
//=================================================================================================
