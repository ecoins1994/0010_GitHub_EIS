//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//								ПОИСК СВОБОДНЫХ УСТРОЙСТВ
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=================================================================================================
//							Поиск номера первого свободного бита в регистре состояний						
// Возвращает номер первого свободного бита (0:15) или -1;	
//=================================================================================================
int8_t getFistFreeBit    (uint16_t &reg, uint8_t maxNum=15){
 //-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i;
#endif
//-------------------------------------------------------------------------------------------------
 if(maxNum>16) {return -1;} for(i=0;i<maxNum; i++){if(!bitRead(reg,i)) return i;} return -1;};
//=================================================================================================
//		Функции поиска и захвата первый свободный бит в регистре состояний						
// Возвращает номер первого свободного бита (0:15) или -1;	
//=================================================================================================
int8_t setFirstFreeBit   (uint16_t &reg, uint8_t maxNum=15){
if(maxNum>16) {return -1;} for(uint8_t i=0;i<maxNum;i++){if(!bitRead(reg,i)) {bitSet(reg,i); return i;}} return -1;};	
//=================================================================================================
//							Проверяет занятость в reg номера бита num(0:15) 
// при ограничении его номера maxNum(if(num>max){return 0;}; 					
// Возвращает номер первого свободного бита (0:15) или -1;	
//=================================================================================================
bool checkBusyNumBit   (uint16_t &reg, uint8_t num, uint8_t maxNum=15){if(maxNum>16) {return 0;} return bitRead(reg,num);};		
//=================================================================================================
//							Занимает в reg номер первого свободного устройства(1:16) и возращает его номер или 0; 								
//=================================================================================================
uint8_t  setFistFreeDevice (uint16_t &reg, uint8_t maxNum=16){				//==Занимает в reg номер первого свободного устройства(1:16) и возращает его номер или 0; 	
 //-------------------------------------------------------------------------------------------------
#if !defined(RT_HM_COREM)				//==Если контроллер не многоядерный;
  uint8_t  i;
#endif
//-------------------------------------------------------------------------------------------------
 if((maxNum>16) || (maxNum==0)) {return 0;} 
 for(i=1; i<=maxNum; i++){if(!bitRead(reg,(i-1))) {bitSet(reg,(i-1)); return i;}} return 0;};	
//=================================================================================================
//							Занимает в reg номер первого свободного устройства(1:16) и возращает его номер или 0; 
//==Проверяет занятость номера устройства(1:16); 								
//=================================================================================================	
bool  checkBusyNumDevice(uint16_t &reg, uint8_t num, uint8_t maxNum=16) {if((maxNum>16) || (num==0)) {return 0;} return bitRead(reg,(num-1));};	
//=================================================================================================
