//=================================================================================================
//						    Nextion	структуры							
//=================================================================================================
struct  RT_HW_STRUCT_NEXT_HIVE{             //--Структура данных рабочих параметров
//--------------------------------------------------------------------------------------------------
//                    Структура данных рабочих параметров
// set - флаги занятости устройства
// qnt - кол-во занятых устройств
//--------------------------------------------------------------------------------------------------
uint16_t set=0;						//--Флаги занятости устройства 
uint8_t  qnt=0; 					//--Кол-во зарегистрированных устройств;
uint8_t  arrByte[2]={0,0};			//--1-байтовый массив для недопустимых устройств;
uint16_t arrWord[1]={0};			//--2-байтовый массив для недопустимых устройств;
uint32_t arrLong[1]={0};			//--4-байтовый массив для недопустимых устройств;
//-------------------------------------------------------------------------------------------------
uint16_t setGrafic=0;				//--Флаги занятости графиков; 
uint8_t  qntGrafic=0; 			    //--Кол-во зарегистрированных графиков;
uint8_t  arrGrafic[2]={0,0};	    //--1-байтовый массив данных для недопустимых графиков;
};
//=================================================================================================
//		         Структура данных управляющего блока
// Блок:
// 1.Синхронизирует работу внешних блоков меандром RT_HW_Next.blink:
//     -RT_HW_Next.blink=RT_HW_Base.shed.blink50, если включен диспетчер задач RT_HW_Base.sheduler(),
//                                   (флаг включения диспетчера RT_HW_Base.shed.ready=1); 
//     -RT_HW_Next.blink=внутренний генератор меандра 50мс,если RT_HW_Base.shed.ready=0;
// 2.Принимает посылки из NEXTION по программному протоколу 
//			все данные хранятся в массиве RT_HW_NEXT_DEVICE_ID *ptr[RT_HW_NEXT_MAX_DEVICE+1],
//			создаваемом при создании класса RT_HW_NEXT.
//=================================================================================================
struct  RT_HW_STRUCT_NEXT_DEVICE{           //--Структура для приема транзакций из NEXTION по протоколу ModBus+; 		   
//-----------------Основные параметры управления---------------------------------------------------
uint8_t  custom=0;				//--Код настройки: =0 не настраивался; =1 успешно настроен; >1 код ошибки настройки;
uint8_t  num=0; 				//--Номер устройства (от 1 до MAX_DEVICE).По этому номеру внешние блоки привязываются к устройству;
//-------------------------------------------------------------------------------------------------
uint8_t  ddr=0;					//--Этапы основной       программы управления устройствами;
uint8_t  step;					//--Этапы дополнительной программы управления устройствами;
//-------------------------------------------------------------------------------------------------
uint8_t  busy=0;				//--Флаг занятости UART(доступ RT_HW_Next.ptr[num]->busy);
uint8_t  blink=0, agoBlink=0;   	//--Меандр 50мс        (доступ RT_HW_Next.ptr[num]->blink);
uint8_t  wdBusy=0;				//--Счетчик сторожевого таймера от зависания флага занятости UART(busy);
//-----------------Параметры корректируемые до вызова функции setID()------------------------------
uint8_t  uart=255;				//--Номер UART;
uint32_t speed=115200;			//--Скорость UART;
uint8_t  ready=0;				//--Флаг успешной настройки UART;
//-----------------Параметры для работы с массивами данных-----------------------------------------
uint8_t  lenArrByte=2;			//--Длина массива uint8_t  arrByte[];
uint8_t  lenArrWord=1;			//--Длина массива uint16_t arrWord[];
uint8_t  lenArrLong=1;			//--Длина массива uint32_t arrLong[];
uint8_t	 *ptrArrByte;			//--Указатель на массив uint8_t  arrByte[];
uint16_t *ptrArrWord;			//--Указатель на массив uint16_t arrWord[];
uint32_t *ptrArrLong;			//--Указатель на массив uint32_t arrLong[];
//-----------------Параметры системные-------------------------------------------------------------
uint8_t  arrSys[4];             //--Системные параметры из Nextion ([0]=page;);
uint8_t  ok=0;
uint8_t  vSleep=0;				//--Режим спит/не спит;
uint8_t  vPage=99;				//--Номер текущей страницы;
uint8_t  vYear,vMonth,vDay,vHour,vMin,vSec,vWeek;	//--Параметры времени
//-----------------Основные параметры управления---------------------------------------------------
uint8_t  codeErr;				//--Код ошибки;
//-----------------------------------------------------------------------------
uint8_t  readyRead:1;	//--Флаги; 			//--Счетчик отправленных пакетов;
//----------------------------------------
uint32_t timeBeginGen;          //--Рабочий регистр для тактирующего генератора;
uint32_t timeBeginBusy;         //--Рабочий регистр для задержки флага busy;
uint32_t timeGet;				//--Рабочий регистр;
uint8_t	 timeOutGetByte=10;		//--Тайм-аут на прием очередного байта транзакции;
//---------------------------------------------------------------------------
uint8_t  index;					//--Счетчик кол-ва принятых байт;
uint8_t  head,func,adr,qnt,crc;
uint32_t crcCalc;
uint16_t cntGetPackAll; 		//--Счетчик принятых всего    транзакций;
uint16_t cntGetPackOk;			//--Счетчик принятых успешных транзакций; 
uint16_t qntByte;
//-----------------------------------------
//uint8_t  dp=0;					//--Номер текущей страницы;
uint8_t  buff[RT_HW_NEXT_BUFF_REG_SIZE];	//--Буфер для приема данных      из принятой транзакции;
//-----------------------------------------
uint8_t  freshHead;             //--Флаг принятого байта до кода заголовка (0x3A);
uint8_t  codeGetHead;			//--Код  принятого байта до кода заголовка (0x3A);
};
//==================================================================================================
//                   Структура для отправки данных
//==================================================================================================
struct  RT_HW_STRUCT_NEXT_WRITE_VAR{		//==Структура для записи в Nextion целого значения с именем inx;
//-----------------Основные параметры управления---------------------------------------------------
uint8_t  num=0; 			//--Номер устройства(от 1 до MAX_DEVICE). По этому номеру внешние блоки(FLProg) привязываются к устройству;
uint8_t  custom=0;			//--Код настройки; 
uint8_t  ddr=0;				//--Этапы основной программы управления устройствами;
char     modeTask='A';  	//--Режим вызова задачи [C,P,T,A,E,Q,F];
//char     modeSend='-';      //--Режим вызова задачи [V,U,T,N,F,S,-];
uint8_t  page=99;			//--Номер страницы текущего вывода. Если >=99 - вывод без контроля страницы;
uint8_t  agoEN,extEN=1;		//--Предыдущее значение внешней переменной EN-разрешение вывода; 
uint8_t  agoBlink,blink;	//--Для внутреннего генератора меандра;
uint8_t  numReg=0;			//--Номер регистра;
uint8_t  cntLimit,periodLimit; //--Счетчик и период для вывода по изменениям с ограничением периода; 
uint8_t  cntTask, periodTask;  //--Счетчик и период для периодического вывода; 
uint8_t  checkPage=0;
uint8_t  first=1;			//--Флаг первого запуска;
uint8_t  run=1,cmdRun=0; 	//--Флаг для внешнего запуска отправки транзакции;
int32_t  agoVar,var;		//--Предыдущее значение выводимой переменной;		   
//uint32_t timeBeginDelay;
};








//##################################################################################################
/*
struct  RT_HW_STRUCT_NEXT_HIVE{             //--Структура данных рабочих параметров
//--------------------------------------------------------------------------------------------------
//                    Структура данных рабочих параметров
// set - флаги занятости устройства
// qnt - кол-во занятых устройств
//--------------------------------------------------------------------------------------------------
uint16_t set=0;						//--Флаги занятости устройства 
uint8_t  qnt=0; 					//--Кол-во зарегистрированных устройств;
uint8_t  arrByte[2]={0,0};			//--1-байтовый массив для недопустимых устройств;
uint16_t arrWord[1]={0};			//--2-байтовый массив для недопустимых устройств;
uint32_t arrLong[1]={0};			//--4-байтовый массив для недопустимых устройств;
//-------------------------------------------------------------------------------------------------
uint16_t setGrafic=0;				//--Флаги занятости графиков; 
uint8_t  qntGrafic=0; 			    //--Кол-во зарегистрированных графиков;
uint8_t  arrGrafic[2]={0,0};	    //--1-байтовый массив данных для недопустимых графиков;
};
*/
//=================================================================================================
//		         Структура данных управляющего блока
// Блок:
// 1.Синхронизирует работу внешних блоков меандром RT_HW_Next.blink:
//     -RT_HW_Next.blink=RT_HW_Base.shed.blink50, если включен диспетчер задач RT_HW_Base.sheduler(),
//                                   (флаг включения диспетчера RT_HW_Base.shed.ready=1); 
//     -RT_HW_Next.blink=внутренний генератор меандра 50мс,если RT_HW_Base.shed.ready=0;
// 2.Принимает посылки из NEXTION по программному протоколу 
//			все данные хранятся в массиве RT_HW_NEXT_DEVICE_ID *ptr[RT_HW_NEXT_MAX_DEVICE+1],
//			создаваемом при создании класса RT_HW_NEXT.
//=================================================================================================
/*
struct  RT_HW_STRUCT_NEXT_DEVICE{           //--Структура для приема транзакций из NEXTION по протоколу ModBus+; 		   

//-----------------Основные параметры управления---------------------------------------------------
uint8_t  num=0; 				//--Номер устройства (от 1 до MAX_DEVICE).По этому номеру внешние блоки привязываются к устройству;
uint8_t  busy=0;				//--Флаг занятости UART(доступ RT_HW_Next.ptr[num]->busy);
uint8_t  blink=0, agoBlink=0;   //--Меандр 50мс        (доступ RT_HW_Next.ptr[num]->blink);
uint32_t timeBeginGen;          //--Рабочий регистр для тактирующего генератора;
uint32_t timeBeginBusy;         //--Рабочий регистр для задержки флага busy;
uint8_t  wdBusy=0;				//--Счетчик сторожевого таймера от зависания флага занятости UART(busy);
uint8_t  custom=0;				//--Код настройки: =0 не настраивался; =1 успешно настроен; >1 код ошибки настройки;
//-------------------------------------------------------------------------------------------------
uint8_t  ddr=0;					//--Этапы основной программы управления устройствами;
//-----------------Параметры корректируемые до вызова функции setID()------------------------------
uint8_t  uart=255;				//--Номер UART;
uint32_t speed=115200;			//--Скорость UART;
uint8_t  ready=0;				//--Флаг успешной настройки UART;
//-----------------Параметры для работы с массивами данных-----------------------------------------
uint8_t  lenArrByte=2;			//--Длина массива uint8_t  arrByte[];
uint8_t  lenArrWord=1;			//--Длина массива uint16_t arrWord[];
uint8_t  lenArrLong=1;			//--Длина массива uint32_t arrLong[];
uint8_t	 *ptrArrByte;			//--Указатель на массив uint8_t  arrByte[];
uint16_t *ptrArrWord;			//--Указатель на массив uint16_t arrWord[];
uint32_t *ptrArrLong;			//--Указатель на массив uint32_t arrLong[];
//-----------------Параметры системные-------------------------------------------------------------
uint8_t  arrSys[4];             //--Системные параметры из Nextion ([0]=page;);
uint8_t  ok=0;
uint8_t  vPage=99;				//--Номер текущей страницы;
uint8_t  vYear,vMonth,vDay,vHour,vMin,vSec,vWeek;	//--Параметры времени
uint8_t  vRsv1,vRsv2;		    //--Резервные параметры;
//-----------------Основные параметры управления---------------------------------------------------
uint8_t  codeErr;				//--Код ошибки;
//-----------------------------------------------------------------------------
uint8_t  readyRead:1;	//--Флаги; 			//--Счетчик отправленных пакетов;
//----------------------------------------
uint32_t timeGet;				//--Рабочий регистр;
uint8_t	 timeOutGetByte=10;		//--Тайм-аут на прием очередного байта транзакции;
uint8_t  index;					//--Счетчик кол-ва принятых байт;
uint8_t  step;
uint8_t  head,func,adr,qnt,crc;
uint32_t crcCalc;
uint16_t cntGetPackAll; 		//--Счетчик принятых всего    транзакций;
uint16_t cntGetPackOk;			//--Счетчик принятых успешных транзакций; 
uint16_t qntByte;
//-----------------------------------------
uint8_t  dp=0;					//--Номер текущей страницы;
uint8_t  buff[RT_HW_NEXT_BUFF_REG_SIZE];	//--Буфер для приема данных      из принятой транзакции;
//-----------------------------------------
uint8_t  freshHead;             //--Флаг принятого байта до кода заголовка (0x3A);
uint8_t  codeGetHead;			//--Код  принятого байта до кода заголовка (0x3A);
}; 
*/
//==================================================================================================
// Структура данных для приема посылок из нескольких NEXTION  
// Данные по каждому из хранятся в массиве RT_HW_NEXT_DEVICE_ID *ptr[RT_HW_NEXT_MAX_DEVICE+1],
//			создаваемом при создании класса RT_HW_NEXT.
//==================================================================================================
struct  RT_HW_STRUCT_NEXT_GET_NEXTION{      //==Структура данных для приема посылок из NEXTION по протоколу ModBus+;  		   
uint8_t  dir=0;								//--Управление;
uint8_t  head,func;							//--Буферы: заголовок(0x3A), код функции(=0x06 send byte('B'), =0x16 send word('W'), =0x26 send long('L');
uint8_t  adr,qnt,crc,qntByte;				//--Буферы: адрес массива, кол-во регистров,контрольная сумма;
uint8_t  buff[RT_HW_NEXT_BUFF_REG_SIZE];	//--Буфер для приема данных      из принятой транзакции;
uint8_t  cnt;								//--Количество принятых байт;
uint8_t  codeErr=0;							//--Код ошибки;
uint32_t timeStart;
}; 



/*

//==================================================================================================
//                   Структура для отправки данных
//==================================================================================================
struct  RT_HW_STRUCT_NEXT_WRITE_VAL{		//==Структура для записи в Nextion целого значения с именем inx;
//-----------------Основные параметры управления---------------------------------------------------
uint8_t  num=0; 		//--Номер устройства(от 1 до MAX_DEVICE). По этому номеру внешние блоки(FLProg) привязываются к устройству;
uint8_t  custom=0;		//--Код настройки; 
uint8_t  state;			//--state=1: Выполнение вывода внешней переменной безусловное; 
						//  state=2: Выполнение вывода внешней переменной по изменению относительно agoVal; 
uint8_t  ddr=0;			//--Этапы основной программы управления устройствами;
char     mode;          //--Режим вызова задачи [C,P,T,A,E,S,F,N];;
uint8_t  agoEN;			//--Предыдущее значение внешней переменной EN-разрешение вывода; 
uint8_t  blink;			//--Для внутреннего генератора меандра;
uint8_t  cntLimit,periodLimit; //--Счетчик и период для вывода по изменениям с ограничением периода; 
uint8_t  cntTask, periodTask;  //--Счетчик и период для периодического вывода; 
uint8_t  adr=0;			//--Адрес записываемого регистра в Nextion с именем inXX(proram.c);
uint8_t  run=1;         //--Флаг для внешнего запуска отправки транзакции;
int32_t  agoVal;		//--Предыдущее значение выводимой переменной;		   
//uint32_t timeBeginDelay;
};
*/
//==================================================================================================
//                   Структура для отправки графиков
//==================================================================================================

struct  RT_HW_STRUCT_NEXT_GRAFIC{		    //==Структура для записи в Nextion графика;
//-----------------Параметры корректируемые до вызова функции setID()------------------------------
uint8_t  tick=2;				//--Период в тиках;
//-----------------Основные параметры управления---------------------------------------------------
uint8_t  numDevice=0; 			//--Номер устройства (от 1 до MAX_DEVICE).По этому номеру внешние блоки привязываются к устройству;
//-------------------------------------------------------------------------------------------------
uint8_t  page=0;				//--Номер страницы Nexttion с графиком;
uint8_t  ID=1;					//--ID графика на странице Nextion;
uint8_t  chanel=0;				//--Номер канала графика;
String   head="gr";			    //--Заголовок переменных в Nextion;
//-------------------------------------------------------------------------------------------------
uint8_t  custom=0;				//--Код настройки; 
uint8_t  dir=0;					//--Этапы основной программы управления устройствами;
uint8_t  run=1;					//--Флаг готовности графика к отправке в Nextion;
uint8_t  cnt=0;					//--Счетчик для вычисления периода (в тикак); 	   
//-------------------------------------------------------------------
uint8_t  lenArrByteGrafic=2;	//--Размер массива графика;
uint8_t  numGrafic=0;			//--Номер графика (для связи с блоками);
uint8_t	 *ptrArrByteGrafic;		//--Указатель на массив uint8_t  arrByte[];
};
